<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>详解Promise</title>
      <link href="/2024/04/27/80-xiang-jie-promise/"/>
      <url>/2024/04/27/80-xiang-jie-promise/</url>
      
        <content type="html"><![CDATA[<h1>1.1. Promise 是什么?</h1><h3>1.1.1. 理解</h3><p>1. 抽象表达:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) Promise 是一门新的技术(ES6规范)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) Promise 是JS 中进行异步编程的新解决方案</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;备注：旧方案是单纯使用回调函数</p><p>2. 具体表达:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) 从语法上来说: Promise是一个构造函数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p><h3>1.1.2. promise 的状态改变</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. pending 变为resolved</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. pending 变为rejected</p><p>说明: 只有这2种, 且一个promise对象只能改变一次</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论变为成功还是失败, 都会有一个结果数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;成功的结果数据一般称为value, 失败的结果数据一般称为reason</p><h3>1.1.3. promise 的基本流程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img alt="" height="265" src="/medias/images/All/193.png" width="1110"></p><h3>1.1.4. promise 的基本使用&nbsp;</h3><pre><code class="language-javascript">const fs = require('fs');//回调函数 形式// fs.readFile('./resource/content.txt', (err, data) =&gt; {//     // 如果出错 则抛出错误//     if(err)  throw err;//     //输出文件内容//     console.log(data.toString());// });//Promise 形式let p = new Promise((resolve , reject) =&gt; {    fs.readFile('./resource/content.tx', (err, data) =&gt; {        //如果出错        if(err) reject(err);        //如果成功        resolve(data);    });});//调用 then p.then(value=&gt;{    console.log(value.toString());}, reason=&gt;{    console.log(reason);});</code></pre><p>封装一个Promise函数</p><pre><code class="language-javascript">/** * 封装一个函数 mineReadFile 读取文件内容 * 参数:  path  文件路径 * 返回:  promise 对象 */function mineReadFile(path){    return new Promise((resolve, reject) =&gt; {        //读取文件        require('fs').readFile(path, (err, data) =&gt;{            //判断            if(err) reject(err);            //成功            resolve(data);        });    });}mineReadFile('./resource/content.txt').then(value=&gt;{    //输出文件内容    console.log(value.toString());}, reason=&gt;{    console.log(reason);});</code></pre><p>util.promisify 方法&nbsp;</p><p>它的主要作用是将一个原本采用 Node.js 回调风格（即接受&nbsp;<code>(err, result)</code>&nbsp;形式的回调作为最后一个参数）的函数转换为返回 Promise 的函数。</p><pre><code class="language-javascript">/** * util.promisify 方法 *///引入 util 模块const util = require('util');//引入 fs 模块const fs = require('fs');//返回一个新的函数let mineReadFile = util.promisify(fs.readFile);mineReadFile('./resource/content.txt').then(value=&gt;{    console.log(value.toString());});</code></pre><h1>1.2. 为什么要用Promise?</h1><h3>1.2.1. 指定回调函数的方式更加灵活</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 旧的: 必须在启动异步任务前指定</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个)&nbsp;</p><h3>1.2.2. 支持链式调用, 可以解决回调地狱问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 什么是回调地狱?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 回调地狱的缺点?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不便于阅读</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不便于异常处理</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 解决方案?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promise 链式调用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.&nbsp;终极解决方案?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async/await</p><h1>1.3. 如何使用Promise?</h1><h3>1.3.1. API</h3><p>1. Promise 构造函数: Promise (excutor) {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行</p><p>2.Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: 指定用于得到成功value的成功回调和用于得到失败reason的失败回调 返回一个新的promise对象</p><p>3. Promise.prototype.catch 方法: (onRejected) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: then()的语法糖, 相当于: then(undefined, onRejected)</p><p>4. Promise.resolve 方法: (value) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) value: 成功的数据或promise对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: 返回一个成功/失败的promise对象</p><p>5. Promise.reject 方法: (reason) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) reason: 失败的原因</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: 返回一个失败的promise对象</p><p>6. Promise.all 方法: (promises) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) promises: 包含 n 个 promise 的数组</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: 返回一个新的promise, 只有所有的promise都成功才成功, 只要有一个失败就直接失败</p><p>7. Promise.race 方法: (promises) =&gt; {}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) promises: 包含 n 个 promise 的数组</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说明: 返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态</p><pre><code class="language-javascript">const p1 = Promise.resolve(1);const p2 = Promise.resolve(Promise.resolve(3));const p3 = Promise.resolve(Promise.reject(5));const p4 = Promise.reject(7);const p5 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        if (Date.now() % 2 === 0) {            resolve(1);        } else {            reject(2);        }    }, 100);});const pAll = Promise.all([p1, p2, p5]);pAll.then(    (values) =&gt; {        console.log("all成功了", values);    },    (reason) =&gt; {        console.log("all失败了", reason);    });// const pRace = Promise.race([p5, p4, p1])const pRace = Promise.race([p5, p1, p4]);pRace.then(    (value) =&gt; {        console.log("race成功了", value);    },    (reason) =&gt; {        console.log("race失败了", reason);    });</code></pre><h3>1.3.2. promise 的几个关键问题</h3><p>1. &nbsp;如何改变promise的状态?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) resolve(value): 如果当前是 pending 就会变为resolved</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) reject(reason): 如果当前是 pending 就会变为rejected</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 抛出异常: 如果当前是pending就会变为rejected</p><p>2. 一个promise 指定多个成功/失败回调函数, 都会调用吗?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当promise 改变为对应状态时都会调用</p><p>3.改变promise状态和指定回调函数谁先谁后?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 如何先改状态再指定回调?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 在执行器中直接调用resolve()/reject()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 延迟更长时间才调用then()</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 什么时候才能得到数据?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p><p>4. promise.then()返回的新 promise 的结果状态由什么决定?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) 简单表达: 由then()指定的回调函数执行的结果决定</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 详细表达:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 如果抛出异常, 新promise变为rejected, reason为抛出的异常</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 如果返回的是非promise的任意值, 新promise变为resolved, value为返回的值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 如果返回的是另一个新promise, 此promise的结果就会成为新promise的结果</p><p>5. promise 如何串连多个操作任务?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) promise 的 then()返回一个新的promise, 可以开成then()的链式调用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) 通过then的链式调用串连多个同步/异步任务&nbsp;</p><p>6. promise异常传透?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) 当使用promise的then链式调用时, 可以在最后指定失败的回调,</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理</p><p>7. 中断promise链?</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) 当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 办法: 在回调函数中返回一个pendding状态的promise对象</p><h1>2.1.&nbsp; async与await</h1><h3>&nbsp;2.1.1. mdn 文档</h3><pre><code class="language-javascript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await&nbsp;&nbsp;</code></pre><h3>&nbsp;2.1.2.&nbsp;async 函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 函数的返回值为promise对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. promise 对象的结果由async函数执行的返回值决定</p><h3>2.1.3&nbsp;await 表达式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. await 右侧的表达式一般为promise对象, 但也可以是其它的值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 如果表达式是promise对象, await返回的是promise成功的值</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 如果表达式是其它值, 直接将此值作为await的返回值</p><h3>2.1.4. 注意</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. await 必须写在async函数中, 但async函数中可以没有await</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 如果await的promise失败了, 就会抛出异常, 需要通过try...catch捕获处理</p><pre><code class="language-javascript">function fn1() {    return Promise.resolve(1);}function fn2() {    return 2;}function fn3() {    return Promise.reject(3);    // return fn3.test() // 程序运行会抛出异常}function fn4() {    return fn3.test(); // 程序运行会抛出异常}// 没有使用await的async函数async function fn5() {    return 4;}async function fn() {    // await右侧是一个成功的promise    const result = await fn1();    // await右侧是一个非promise的数据    // const result = await fn2()    // await右侧是一个失败的promise    // const result = await fn3()    // await右侧抛出异常    // const result = await fn4()    console.log("result: ", result);    return result + 10;}async function test() {    try {        const result2 = await fn();        console.log("result2", result2);    } catch (error) {        console.log("error", error);    }    const result3 = await fn4();    console.log("result4", result3);}// test()</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript获取操作系统的方法</title>
      <link href="/2024/04/27/79-javascript-huo-qu-cao-zuo-xi-tong-de-fang-fa/"/>
      <url>/2024/04/27/79-javascript-huo-qu-cao-zuo-xi-tong-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<pre><code class="language-javascript">function getOperationSystemInfo() {    let sUserAgent = window.navigator.userAgent.toLocaleLowerCase();    let isWin = sUserAgent.indexOf('win32') &gt; -1 || sUserAgent.indexOf('windows') &gt; -1;    let isMac = sUserAgent.indexOf('mac68k') &gt; -1 || sUserAgent.indexOf('macppc') &gt; -1 || sUserAgent.indexOf('macintosh') &gt; -1 || sUserAgent.indexOf('macintel') &gt; -1;    if (isMac) return 'Mac';    if (sUserAgent.indexOf('x11') &gt; -1 &amp;&amp; !isWin &amp;&amp; !isMac) return 'Unix';    if (sUserAgent.indexOf('linux') &gt; -1) return 'Linux';    if (isWin) {        if (sUserAgent.indexOf('windows nt 5.0') &gt; -1 || sUserAgent.indexOf('windows 2000') &gt; -1) return 'Win2000';        if (sUserAgent.indexOf('windows nt 5.1') &gt; -1 || sUserAgent.indexOf('windows xp') &gt; -1) return 'WinXP';        if (sUserAgent.indexOf('windows nt 5.2') &gt; -1 || sUserAgent.indexOf('windows 2003') &gt; -1) return 'Win2003';        if (sUserAgent.indexOf('windows nt 6.0') &gt; -1 || sUserAgent.indexOf('windows vista') &gt; -1) return 'WinVista';        if (sUserAgent.indexOf('windows nt 6.1') &gt; -1 || sUserAgent.indexOf('windows 7') &gt; -1) return 'Win7';        if (sUserAgent.indexOf('windows nt 10.0') &gt; -1 || sUserAgent.indexOf('windows 10') &gt; -1) return 'Win10';    }    if (sUserAgent.indexOf('android') &gt; -1) return 'Android';    if (sUserAgent.indexOf('iphone') &gt; -1) return 'iPhone';    if (sUserAgent.indexOf('symbianos') &gt; -1) return 'SymbianOS';    if (sUserAgent.indexOf('windows phone') &gt; -1) return 'Windows Phone';    if (sUserAgent.indexOf('ipad') &gt; -1) return 'iPad';    if (sUserAgent.indexOf('ipod') &gt; -1) return 'iPod';    return 'others';}</code></pre><p>值得注意的是，在window11操作系统下&nbsp;window.navigator.userAgent 返回的也是10的版本</p><p><img alt="" height="105" src="/medias/images/All/192.png" width="1147"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 如何判断当前浏览器是不是IE浏览器</title>
      <link href="/2024/04/26/78-javascript-ru-he-pan-duan-dang-qian-liu-lan-qi-shi-bu-shi-ie-liu-lan-qi/"/>
      <url>/2024/04/26/78-javascript-ru-he-pan-duan-dang-qian-liu-lan-qi-shi-bu-shi-ie-liu-lan-qi/</url>
      
        <content type="html"><![CDATA[<p>如果只是需要区分当前浏览器是不是IE浏览器，那只需要借助 ActiveXObject 来实现就行了，</p><p>ActiveXObject 是 Internet Explorer (IE) 浏览器中的一个内置对象，用于创建和操作各种 ActiveX 控件和 COM 对象。它提供了与客户端操作系统和其他应用程序交互的能力。ActiveXObject 只在 IE 浏览器中可用，并且在现代浏览器中往往不被支持。</p><pre><code class="language-javascript">// 判断浏览器是不是 IE 浏览器function isIE () {    if (!!window.ActiveXObject || "ActiveXObject" in window)        return true;    else        return false;};</code></pre><p>如果需要判断主流的浏览器版本，则需要使用window.navigator.userAgent来实现</p><pre><code class="language-javascript">function getBrowserType() {    // 获取浏览器 userAgent    var ua = navigator.userAgent;    // 是否为 Opera    var isOpera = ua.indexOf('Opera') &gt; -1;    // 返回结果    if (isOpera) {        return 'Opera';    }    // 是否为 IE    var isIE = ua.indexOf('compatible') &gt; -1 &amp;&amp; ua.indexOf('MSIE') &gt; -1 &amp;&amp; !isOpera;    var isIE11 = ua.indexOf('Trident') &gt; -1 &amp;&amp; ua.indexOf('rv:11.0') &gt; -1;    // 返回结果    if (isIE11) {        return 'IE11';    } else if (isIE) {        // 检测是否匹配        var re = new RegExp('MSIE (\\d+\\.\\d+);');        re.test(ua);        // 获取版本        var ver = parseFloat(RegExp['$1']);        // 返回结果        if (ver == 7) {            return 'IE7';        } else if (ver == 8) {            return 'IE8';        } else if (ver == 9) {            return 'IE9';        } else if (ver == 10) {            return 'IE10';        } else {            return 'IE';        }    }    // 是否为 Edge    var isEdge = ua.indexOf('Edge') &gt; -1;    // 返回结果    if (isEdge) {        return 'Edge';    }    // 是否为 Firefox    var isFirefox = ua.indexOf('Firefox') &gt; -1;    // 返回结果    if (isFirefox) {        return 'Firefox';    }    // 是否为 Safari    var isSafari = ua.indexOf('Safari') &gt; -1 &amp;&amp; ua.indexOf('Chrome') == -1;    // 返回结果    if (isSafari) {        return 'Safari';    }    // 是否为 Chrome    var isChrome = ua.indexOf('Chrome') &gt; -1 &amp;&amp; ua.indexOf('Safari') &gt; -1 &amp;&amp; ua.indexOf('Edge') == -1;    // 返回结果    if (isChrome) {        return 'Chrome';    }    // 是否为 UC    var isUC = ua.indexOf('UBrowser') &gt; -1;    // 返回结果    if (isUC) {        return 'UC';    }    // 是否为 QQ    var isQQ = ua.indexOf('QQBrowser') &gt; -1; // 返回结果    if (isQQ) {        return 'QQ';    }    // 都不是    return '';}</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> IE浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动实现 Promise</title>
      <link href="/2024/04/26/77-shou-dong-shi-xian-promise/"/>
      <url>/2024/04/26/77-shou-dong-shi-xian-promise/</url>
      
        <content type="html"><![CDATA[<pre><code class="language-javascript">class Promise {    constructor(executor) {        // 添加属性        this.PromiseState = "pending";        this.PromiseRuesult = null;        // 声明属性，用来保存回调函数        this.callbacks = [];        // 保存实例对象的this值        const self = this;        // resolve 函数        function resolve(data) {            // 判断状态            if (self.PromiseState !== "pending") return;            // 1. 修改对象的状态 （promiseState）            self.PromiseState = "fulfilled";            // 2. 设置对象结果值 （promiseResult）            self.PromiseRuesult = data;            // 执行回调            setTimeout(() =&gt; {                self.callbacks.forEach((item) =&gt; {                    item.onResolved(data);                });            });        }        // reject 函数        function reject(data) {            // 判断状态            if (self.PromiseState !== "pending") return;            // 1. 修改对象的状态 （promiseState）            self.PromiseState = "rejected";            // 2. 设置对象结果值 （promiseResult）            self.PromiseRuesult = data;            // 执行回调            setTimeout(() =&gt; {                self.callbacks.forEach((item) =&gt; {                    item.onRejected(data);                });            });        }        try {            // 同步调用 【执行器函数】            executor(resolve, reject);        } catch (e) {            reject(e);        }    }    // then 方法封装    then(onResolved, onRejected) {        const self = this;        // 判断回调函数参数        if (typeof onRejected !== "function") {            onRejected = (reason) =&gt; {                throw reason;            };        }        if (typeof onResolved !== "function") {            onResolved = (value) =&gt; value;        }        return new Promise((resolve, reject) =&gt; {            function callback(typeFunc) {                try {                    // 获取回调函数的执行结果                    let result = typeFunc(self.PromiseRuesult);                    // 判断                    if (result instanceof Promise) {                        result.then(                            (v) =&gt; {                                resolve(v);                            },                            (r) =&gt; {                                reject(r);                            }                        );                    } else {                        resolve(result);                    }                } catch (e) {                    reject(e);                }            }            // 调用回调函数            if (this.PromiseState === "fulfilled") {                callback(onResolved);            }            if (this.PromiseState === "rejected") {                callback(onRejected);            }            // 判断pending的状态            if (this.PromiseState === "pending") {                this.callbacks.push({                    onResolved: function () {                        callback(onResolved);                    },                    onRejected: function () {                        callback(onRejected);                    },                });            }        });    }    //catch 方法    catch(onRejected) {        return this.then(undefined, onRejected);    }    //添加 resolve 方法    static resolve(value) {        //返回promise对象        return new Promise((resolve, reject) =&gt; {            if (value instanceof Promise) {                value.then(                    (v) =&gt; {                        resolve(v);                    },                    (r) =&gt; {                        reject(r);                    }                );            } else {                //状态设置为成功                resolve(value);            }        });    }    //添加 reject 方法    static reject(reason) {        return new Promise((resolve, reject) =&gt; {            reject(reason);        });    }    //添加 all 方法    static all(promises) {        //返回结果为promise对象        return new Promise((resolve, reject) =&gt; {            //声明变量            let count = 0;            let arr = [];            //遍历            for (let i = 0; i &lt; promises.length; i++) {                //                promises[i].then(                    (v) =&gt; {                        //得知对象的状态是成功                        //每个promise对象 都成功                        count++;                        //将当前promise对象成功的结果 存入到数组中                        arr[i] = v;                        //判断                        if (count === promises.length) {                            //修改状态                            resolve(arr);                        }                    },                    (r) =&gt; {                        reject(r);                    }                );            }        });    }    //添加 race 方法    static race(promises) {        return new Promise((resolve, reject) =&gt; {            for (let i = 0; i &lt; promises.length; i++) {                promises[i].then(                    (v) =&gt; {                        //修改返回对象的状态为 『成功』                        resolve(v);                    },                    (r) =&gt; {                        //修改返回对象的状态为 『失败』                        reject(r);                    }                );            }        });    }}</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解js中的console对象</title>
      <link href="/2024/04/25/76-xiang-jie-js-zhong-de-console-dui-xiang/"/>
      <url>/2024/04/25/76-xiang-jie-js-zhong-de-console-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p>对于前端开发而言，console对象大家肯定都很熟悉，最常用的 console.log() 是开发调试必用的</p><p>但是对于console对象的其他方法，相对而言使用的就比较少了。下面详细介绍一下：</p><p>谷歌浏览器输出console对象：</p><p><img alt="" height="715" src="/medias/images/All/177.png" width="1179"></p><p>值得一提的是不同浏览器输出console对象的内容有些许差异，像火狐浏览器中就没有context()和creatTask() 方法，我们这里只介绍通用的。按照分类如下：</p><h1>1、log、warn、info、error、debug 日志级别</h1><pre><code class="language-javascript">console.log("我是console.log 输出内容");console.warn("我是console.warn 输出内容");console.error("我是console.error 输出内容");console.info("我是console.info 输出内容"); // 谷歌、edge浏览器不支持info方法，火狐浏览器器显示和log一样console.debug("我是console.debug 输出内容"); // 谷歌和edge浏览器不支持debug方法，火狐浏览器器显示和log一样</code></pre><p>Edge：&nbsp;</p><p><img alt="" height="219" src="/medias/images/All/178.png" width="596"></p><p>Chrome:</p><p><img alt="" height="319" src="/medias/images/All/179.png" width="939">&nbsp;Firefox:</p><p><img alt="" height="257" src="/medias/images/All/180.png" width="791"></p><p>&nbsp;只有火狐浏览器显示了 console.debug，并且显示了 console.info 前面的图标。</p><h1>2、console.assert()</h1><pre><code class="language-javascript"> console.assert(expression, message[, ...args]);</code></pre><blockquote><ul><li><code>expression</code>: 必需参数，这是一个要进行断言判断的布尔表达式。如果其计算结果为&nbsp;<code>true</code>，则断言通过；否则，断言失败。</li>    <li><code>message</code>: 必需参数，当断言失败时要在控制台输出的错误消息字符串。可以使用模板字面量（template literals）或字符串拼接等方式包含动态信息。</li>    <li><code>[...args]</code>: 可选参数，零个或多个附加参数。这些参数将在&nbsp;<code>message</code>&nbsp;字符串中按照占位符的位置被替换。类似于&nbsp;<code>console.log()</code>&nbsp;中的参数扩展。</li></ul></blockquote><pre><code class="language-javascript">console.assert(1 + 1 === 3, "出错啦，1+1应该等于2");</code></pre><p><img alt="" height="204" src="/medias/images/All/181.png" width="778"></p><h1>3、console.dir()</h1><p>用于以结构化、可交互的方式显示给定对象的所有属性和方法。此方法有助于开发者深入理解对象的内部结构及其继承关系。&nbsp;</p><pre><code class="language-javascript">const person = {    name: "Alice",    age: 30,    greet() {        console.log("Hello, " + this.name);    },};console.log(person.greet);console.dir(person.greet);</code></pre><p>&nbsp;第一个是 console.log() 输出内容，第二个是 console.dir() 输出内容<img alt="" height="809" src="/medias/images/All/182.png" width="1200"></p><h1>&nbsp;4、console.count() 和&nbsp;console.countReset()</h1><p><code>console.count()</code>&nbsp;是一个用于统计特定标签在控制台中出现次数的方法。每次调用&nbsp;<code>console.count()</code>&nbsp;时，如果传入的标签与之前调用过的相同，则对应的计数值会递增；如果标签不同，则会创建一个新的计数项。这种方法对于跟踪代码中特定事件（如用户交互、循环迭代等）的发生次数非常有用。</p><p><code>console.countReset()</code>&nbsp;是与&nbsp;<code>console.count()</code>&nbsp;配合使用的控制台方法，用于重置特定标签的计数器。当需要重新开始计数或者清除某个计数器时，可以调用此方法。</p><pre><code class="language-javascript">console.count("Button clicked");console.count("Form submitted");console.count("Button clicked");console.countReset("Button clicked");console.log("已经执行了countReset方法");console.count("Button clicked");</code></pre><p>&nbsp;<img alt="" height="302" src="/medias/images/All/183.png" width="674"></p><h1>5、console.dirxml()&nbsp;</h1><p><code>console.dirxml()</code>&nbsp;是一个用于在浏览器控制台中以结构化方式显示 XML 或 HTML 元素及其子节点的方法。它特别适用于查看 DOM 节点的层次结构和属性。</p><pre><code class="language-javascript">// 获取页面上的一个元素const myElement = document.getElementById("myDiv");// 使用 console.dirxml() 输出该元素的结构和属性console.dirxml(myElement);</code></pre><p><img alt="" height="468" src="/medias/images/All/184.png" width="708"></p><h1>6、console.group()、console.groupEnd()、console.groupCollapsed()</h1><p><code>console.group()</code>&nbsp;是一个用于在浏览器控制台中组织日志输出的方法，它允许将一系列相关的日志消息归类到一个可折叠的组内，从而提高日志的可读性和管理性。</p><p>console.groupCollapsed() 和 console.group() 的区别就是&nbsp;console.groupCollapsed()默认是折叠的，可以手动展开。console.group() 默认是展开的，可以手动折叠</p><pre><code class="language-javascript">// 创建一个名为 "User Login Process" 的日志分组console.group("User Login Process");// 在分组内输出相关日志console.log("Checking user credentials...");console.warn("Weak password detected!");console.info("Session token generated.");// 结束当前日志分组console.groupEnd();// 创建一个名为 "User Login Process" 的日志分组console.groupCollapsed("groupCollapsed");// 在分组内输出相关日志console.log("Checking user credentials...");console.warn("Weak password detected!");console.info("Session token generated.");// 结束当前日志分组console.groupEnd();</code></pre><p>&nbsp;<img alt="" height="367" src="/medias/images/All/185.png" width="653"></p><h1>&nbsp;7、console.memory()&nbsp;</h1><p><code>console.memory</code>&nbsp;提供了有关当前网页所占用内存的相关信息。通过访问和打印&nbsp;<code>console.memory</code>，开发者可以获取到有关页面内存使用情况的概览数据，这对于诊断内存泄漏、优化性能等问题非常有用。</p><blockquote><ul><li><code>usedJSHeapSize</code>: 返回当前页面已使用的 JavaScript 堆大小（以字节为单位）。这包括了 V8 引擎分配给 JavaScript 对象、闭包、字符串、正则表达式等的内存。</li>    <li><code>totalJSHeapSize</code>: 返回当前页面 JavaScript 堆的总大小（以字节为单位），包括已使用部分和尚未分配的部分。</li>    <li><code>jsHeapSizeLimit</code>: 返回当前页面 JavaScript 堆的最大允许大小（以字节为单位）。超过此限制可能会导致 V8 引擎触发垃圾回收或内存压缩。</li></ul></blockquote><pre><code class="language-javascript">// 输出当前内存使用情况console.log(console.memory);// totalJSHeapSize: 整个 JavaScript 堆的大小（以字节为单位），包括已分配对象和空闲空间。console.log("Total JS Heap Size:", console.memory.totalJSHeapSize);// usedJSHeapSize: 已分配给 JavaScript 对象的实际内存（以字节为单位），不包括空闲空间。console.log("Used JS Heap Size:", console.memory.usedJSHeapSize);// jsHeapSizeLimit: JavaScript 堆的最大允许大小（以字节为单位）。console.log("JS Heap Size Limit:", console.memory.jsHeapSizeLimit);</code></pre><p><img alt="" height="257" src="/medias/images/All/186.png" width="978"></p><h1>8、console.profile() 和 console.profileEnd()</h1><p><code>console.profile()</code>&nbsp;是一个用于启动 JavaScript CPU 性能分析器的方法。它可以追踪指定时间段内函数调用、事件处理等的执行情况，包括调用次数、耗时、CPU 占用等信息，有助于识别代码中的性能瓶颈。</p><pre><code class="language-javascript">// 执行需要分析的代码function heavyComputation() {    // 启动一个名为 "My Function Performance" 的性能分析 session    console.profile("My Function Performance");    for (let i = 0; i &lt; 10000000000; i++) {}    // 结束性能分析 session    console.profileEnd();}heavyComputation();</code></pre><p><img alt="" height="1140" src="/medias/images/All/187.png" width="1200"></p><h1>9、&nbsp;console.table()</h1><p><code>console.table()</code>&nbsp;是一个用于在浏览器控制台以表格形式展示数组或对象集合的方法。它将数据结构清晰、直观地呈现出来，便于开发者快速浏览和分析大量数据。</p><pre><code class="language-javascript">// 示例一：展示数组数组const products = [    ["Product A", 10, 20],    ["Product B", 15, 25],    ["Product C", 20, 30],];console.table(products);// 示例二：展示对象数组const users = [    { name: "Alice", age: 25, role: "Admin" },    { name: "Bob", age: 30, role: "Editor" },    { name: "Charlie", age: 35, role: "Viewer" },];console.table(users);// 示例三：指定显示的列console.table(users, ["name", "role"]);</code></pre><p><img alt="" height="740" src="/medias/images/All/188.png" width="1200"></p><h1>10、console.time()、console.timeEnd()、console.timeLog()、console.timeStamp()</h1><p><code>console.time()</code>&nbsp;是一个用于测量一段代码执行时间的方法。它可以帮助开发者量化代码块或特定任务的运行时长，用于性能分析和优化。</p><p><code>console.timeEnd()</code>&nbsp;是与&nbsp;<code>console.time()</code>&nbsp;配合使用的另一个方法，用于停止计时器并输出测量的代码执行时间。</p><p><code>console.timeLog()</code>&nbsp;是一个用于在计时器运行期间输出中间时间点的方法。它与&nbsp;<code>console.time()</code>&nbsp;和&nbsp;<code>console.timeEnd()</code>&nbsp;结合使用，允许在计时器未结束时记录和输出中间时间点的信息，有助于更细粒度地监控和分析代码执行情况。</p><p><code>console.timeStamp()</code>&nbsp;是一个用于在浏览器控制台的时间轴（Timeline）面板中插入标记的方法。它可以帮助开发者在时间线上标注特定事件的发生时间，以便于分析和可视化程序执行流程。</p><pre><code class="language-javascript">console.time("for循环这段代码执行了");for (let i = 0; i &lt; 100000000; i++) {}console.timeEnd("for循环这段代码执行了");// 开始计时器，标记为 "Long Running Task"console.time("Long Running Task");// 执行需要计时的任务for (let i = 0; i &lt; 100; i++) {    // 在任务的不同阶段记录中间时间点    if (i === 50) {        console.timeLog(            "Long Running Task",            "Halfway through the task"        );    }    // ... 执行任务相关代码 ...}// 结束计时器并输出总执行时间console.timeEnd("Long Running Task");// 标记一个名为 "User Interaction" 的时间点console.timeStamp("User Interaction");// ... 进行其他操作 ...// 标记另一个名为 "Async Request Start" 的时间点console.timeStamp("Async Request Start");// ... 异步请求处理 ...// 标记名为 "Async Request End" 的时间点console.timeStamp("Async Request End");</code></pre><p><img alt="" height="369" src="/medias/images/All/189.png" width="790"></p><h1>11、console.trace()</h1><p><code>console.trace()</code>&nbsp;是一个用于在浏览器控制台输出当前执行位置的调用堆栈跟踪信息的方法。可以帮助开发者定位代码执行的具体路径，特别是在处理错误、异常或调试复杂调用关系时非常有用。</p><pre><code class="language-javascript">function outerFunction() {    innerFunction();}function innerFunction() {    console.trace(); // 输出堆栈跟踪信息}outerFunction();</code></pre><p><img alt="" height="249" src="/medias/images/All/190.png" width="590"></p><h1>12、console.clear()</h1><p>清空控制台</p><p><img alt="" height="212" src="/medias/images/All/191.png" width="857"></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IE浏览器，文件下载失败，onDownloadProgress方法里报错：无法获取未定义或null引用的属性“getResponseheader“</title>
      <link href="/2024/04/25/75-ie-liu-lan-qi-wen-jian-xia-zai-shi-bai-ondownloadprogress-fang-fa-li-bao-cuo-wu-fa-huo-qu-wei-ding-yi-huo-null-yin-yong-de-shu-xing-getresponseheader/"/>
      <url>/2024/04/25/75-ie-liu-lan-qi-wen-jian-xia-zai-shi-bai-ondownloadprogress-fang-fa-li-bao-cuo-wu-fa-huo-qu-wei-ding-yi-huo-null-yin-yong-de-shu-xing-getresponseheader/</url>
      
        <content type="html"><![CDATA[<p>问题背景：</p><p>谷歌、火狐、edge都没有问题，ie11浏览器也没有问题，ie10及以下会报错，无法获取未定义或null引用的属性"getResponseheader</p><p><img alt="" height="497" src="/medias/images/All/175.jpeg" width="1156"></p><p>&nbsp;查看代码，getResponseHeader这个方法是在获取进度条的时候使用，</p><pre><code class="language-javascript">//xml返回数据的钩子函数，可以用来获取数据的进度 具体可查看axios的官网onDownloadProgress: progressEvent =&gt; {    //progressEvent.loaded 下载文件的当前大小    //progressEvent.total  下载文件的总大小 如果后端没有返回 请让他加上！    let progressBar = Math.round((progressEvent.loaded / progressEvent.srcElement.getResponseHeader('x-content-length')) * 100);    // ...其他逻辑操作}</code></pre><p>在ie10浏览器下，控制台打印&nbsp;progressEvent 对象，发现 progressEvent.srcElement 为null，其他版本的浏览器&nbsp;progressEvent.srcElement 是有值的，并且可以通过&nbsp;getResponseHeader() 获取到响应头里的值。</p><p><img alt="" height="1020" src="/medias/images/All/176.png" width="1200"></p><p>修改后：使用&nbsp;progressEvent?.target?.getResponseHeader() 方法获取，x-content-length需要后端接口设置在响应头中。问题解决</p><pre><code class="language-javascript">let progressBar = Math.round((progressEvent.loaded / progressEvent?.target?.getResponseHeader('x-content-length')) * 100);</code></pre><p>这里说一下为什么不使用&nbsp;progressEvent.total 或者&nbsp;content-length 来获取下载文件的总大小？</p><p>因为当开启了gzip之后，这两个值是有问题的。影响进度条的准确性，可以和后台约定好一个字段，比如 x-content-length 返回文件总大小，然后通过&nbsp;progressEvent.target.getResponseHeader('x-content-length') 方法获取就行了。</p><p>问题解决。</p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> IE浏览器兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> 文件下载 </tag>
            
            <tag> IE浏览器兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins 打包报错记录 error: index-pack died of signal 15</title>
      <link href="/2024/04/23/74-jenkins-da-bao-bao-cuo-ji-lu-error-index-pack-died-of-signal-15/"/>
      <url>/2024/04/23/74-jenkins-da-bao-bao-cuo-ji-lu-error-index-pack-died-of-signal-15/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;问题背景，打包每次到92%时就会报错，试了好几次都是同样的错误</p><p><img alt="" height="873" src="/medias/images/All/170.png" width="1200"></p><pre><code class="language-java">14:56:53 fatal: index-pack failed14:56:53 14:56:53 at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.launchCommandIn(CliGitAPIImpl.java:2734)14:56:53 at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.launchCommandWithCredentials(CliGitAPIImpl.java:2111)14:56:53 at org.jenkinsci.plugins.gitclient.CliGitAPIImpl.access$500(CliGitAPIImpl.java:87)14:56:53 at org.jenkinsci.plugins.gitclient.CliGitAPIImpl$1.execute(CliGitAPIImpl.java:623)14:56:53 at hudson.plugins.git.GitSCM.fetchFrom(GitSCM.java:1000)</code></pre><p>&nbsp;看着报错像是和git有关的，怀疑是拉取代码超时，修改配置：</p><p><img alt="" height="975" src="/medias/images/All/171.png" width="1200"></p><p>&nbsp;<img alt="" height="1175" src="/medias/images/All/172.png" width="1200"><img alt="" height="784" src="/medias/images/All/173.png" width="1200"></p><p>把时间改长后，打包成功</p><p><img alt="" height="378" src="/medias/images/All/174.png" width="556"></p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-progress报错：[Vue warn]: Invalid prop: custom validator check failed for prop “percentage“</title>
      <link href="/2024/04/23/73-el-progress-bao-cuo-bao-cuo-vue-warn-invalid-prop-custom-validator-check-failed-for-prop-percentage/"/>
      <url>/2024/04/23/73-el-progress-bao-cuo-bao-cuo-vue-warn-invalid-prop-custom-validator-check-failed-for-prop-percentage/</url>
      
        <content type="html"><![CDATA[<h2>问题背景：</h2><p>&nbsp;在vue项目中使用 Elementui 的进度条组件&nbsp;el-progress 时报错。</p><h2>报错信息：</h2><p><img alt="" height="315" src="/medias/images/All/168.png" width="1188"></p><pre><code class="language-javascript">[Vue warn]: Invalid prop: custom validator check failed for prop "percentage".found in---&gt; &lt;ElProgress&gt; at packages/progress/src/progress.vue       &lt;ElPopover&gt; at packages/popover/src/main.vue         &lt;DownLoad&gt; at src/views/myclouddisk/component/downLoad.vue           &lt;MySpace&gt; at src/views/myclouddisk/mySpace/index.vue             &lt;VabRouterView&gt; at node_modules/@z4aweb/z4aweb-frame/components/components/VabRouterView/index.vue               &lt;VabAppMain&gt; at node_modules/@z4aweb/z4aweb-frame/components/components/VabAppMain/index.vue                 &lt;VabLayoutColumn&gt; at node_modules/@z4aweb/z4aweb-frame/components/layouts/VabLayoutColumn/index.vue                   &lt;LayoutBase&gt; at node_modules/@z4aweb/z4aweb-frame/components/layouts/LayoutBase/index.vue                     &lt;App&gt; at src/App.vue                       &lt;Root&gt;</code></pre><h2>&nbsp;原因：</h2><pre><code class="language-html">&lt;el-progress :text-inside="true" :percentage="item.percentage" :color="colorObj[item.loadStatus]"&gt;&lt;/el-progress&gt;</code></pre><p>percentage 的值非法导致，percentage 只能为 0-100的数字，超过或者小于这个范围都会报错，通常percentage的值是由计算生成，我这里因为取值的undefined导致计算后的percentage值为NAN，所以报错</p><p><img alt="" height="174" src="/medias/images/All/169.png" width="1200"></p><h2>&nbsp;处理方案：</h2><p>首先确保计算时，分子和分母的取值无误，不能为undefined或null等其他的，其次添加判断，当percentage值大于或小于0-100的范围时，重置为0-100合理范围的值。</p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录CodeMirror一些常用的配置选项</title>
      <link href="/2024/04/07/72-ji-lu-codemirror-yi-xie-chang-yong-de-pei-zhi-xuan-xiang/"/>
      <url>/2024/04/07/72-ji-lu-codemirror-yi-xie-chang-yong-de-pei-zhi-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<ol><li>mode：设置编辑器的语言模式，例如JavaScript、HTML、CSS、Markdown等。</li>    <li>theme：设置编辑器的主题，例如ambiance、eclipse、monokai等。</li>    <li>lineNumbers：设置是否显示行号。</li>    <li>readOnly：设置是否只读。</li>    <li>gutters：设置编辑器的侧边栏，例如显示行号、代码折叠等。</li>    <li>matchBrackets：设置是否高亮匹配的括号。</li>    <li>autoCloseBrackets：设置是否自动闭合括号。</li>    <li>extraKeys：设置自定义快捷键。</li>    <li>lint：设置是否启用语法检查。</li>    <li>lintOptions：设置代码检查的选项，例如检查的规则、错误提示的方式等。</li>    <li>scrollbarStyle：设置滚动条的样式，例如native、overlay等。</li>    <li>indentUnit：设置缩进的单位，默认为2个空格。</li>    <li>tabSize：设置Tab键的宽度，默认为4个空格。</li>    <li>indentWithTabs：设置是否使用Tab键进行缩进，默认为false。</li>    <li>styleActiveLine：设置是否高亮当前行，默认为true。</li>    <li>lineWrapping：设置是否自动换行，默认为false。</li>    <li>foldGutter：设置是否显示代码折叠的小三角形，默认为false。</li>    <li>foldOptions：设置代码折叠的选项，例如折叠的深度、折叠的方式等。</li>    <li>showCursorWhenSelecting：设置是否在选择文本时显示光标，默认为false。</li>    <li>cursorBlinkRate：设置光标闪烁的速率，默认为530毫秒。</li>    <li>lineWiseCopyCut：设置是否按行复制、剪切文本，默认为false。</li>    <li>electricChars：设置是否在用户输入特定字符时自动缩进，默认为true。</li>    <li>scrollbarStyle：设置滚动条的样式，例如native、overlay等。</li>    <li>cursorHeight：设置光标的高度，默认为1。</li>    <li>cursorScrollMargin：设置光标距离可视区域边缘的距离，超出该距离时编辑器自动滚动，默认为0。</li>    <li>dragDrop：设置是否启用拖放功能，默认为true。</li>    <li>inputStyle：设置输入的样式，例如contenteditable、textarea等。</li>    <li>spellcheck：设置是否启用拼写检查，默认为false。</li>    <li>autofocus：设置是否自动聚焦到编辑器，默认为false。</li>    <li>lineSeparator：设置换行符的类型，例如\n、\r\n等。</li>    <li>undoDepth：设置编辑器的撤销历史记录的深度，默认为200。</li>    <li>matchTags：设置是否高亮匹配的HTML标签，默认为true。</li>    <li>autoCloseTags：设置是否自动闭合HTML标签，默认为true。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CodeMirror </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeMirror </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解事件循环</title>
      <link href="/2024/04/07/71-xiang-jie-shi-jian-xun-huan/"/>
      <url>/2024/04/07/71-xiang-jie-shi-jian-xun-huan/</url>
      
        <content type="html"><![CDATA[<h1>浏览器的进程模型</h1><h3>何为进程？</h3><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程</p><p><img alt="" height="417" src="/medias/images/All/161.png" width="580"></p><p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p><h3>何为线程 ？</h3><p>有了进程后，就可以运行程序的代码了。</p><p>运⾏代码的「⼈」称之为「线程」。</p><p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p><p><img alt="" height="330" src="/medias/images/All/162.png" width="559"></p><h1>浏览器有哪些进程和线程？&nbsp;</h1><h3>浏览器是一个多进程多线程的应用程序</h3><p>浏览器内部工作极其复杂。</p><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p><img alt="" height="380" src="/medias/images/All/163.png" width="576"></p><blockquote><p>可以在谷歌浏览器的任务管理器中，查看当前的所有进程。以及内存占用情况</p></blockquote><p><img alt="" height="1171" src="/medias/images/All/164.png" width="1200"></p><p>&nbsp;其中，最主要的进程有：</p><p>1. 浏览器进程</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</p><p>2. 网络进程</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</p><h4>3. 渲染进程（重点）</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</p><blockquote><p>将来该默认模式可能会有所改变，同域的不同标签以后可能会共享一个进程。可以参见 chrome官方说明文档</p></blockquote><h1>渲染主线程是如何工作的？</h1><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析 HTML</li>    <li>解析 CSS</li>    <li>计算样式</li>    <li>布局</li>    <li>处理图层</li>    <li>每秒把页面画60次</li>    <li>执行全局 JS 代码</li>    <li>执行事件处理函数</li>    <li>执行计时器的回调函数</li>    <li>......</li></ul><p>要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？</p><p>比如：</p><ul><li>&nbsp;我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？</li>    <li>我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？</li>    <li>浏览器进程通知我 “用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？</li>    <li>......</li></ul><p>渲染主线程想出了一个绝妙的注意来处理这个问题：排队</p><p><img alt="" height="298" src="/medias/images/All/165.png" width="560"></p><p>1. 在最开始的时候，渲染主线程会进入一个无限循环</p><p>2. 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</p><p>3. 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</p><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p><p><strong>整个过程，被称之为事件循环（消息循环）</strong></p><h1>若干解释</h1><h3>&nbsp;何为异步？</h3><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p><ul><li>计时完成后需要执行的任务 --&nbsp; <span style="color:#4da8ee;">setTimeout</span>、<span style="color:#4da8ee;">setInterval</span></li>    <li>网络通信完成后需要执行的任务 -- <span style="color:#4da8ee;">XHR</span>、<span style="color:#4da8ee;">Fetch</span></li>    <li><span style="color:#0d0016;">用户操作后需要执行的任务 --&nbsp;</span><span style="color:#4da8ee;">addEventListener</span></li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器&nbsp;「卡死」</p><p><img alt="" height="267" src="/medias/images/All/166.png" width="566"></p><p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！！&nbsp;</strong></p><p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p><p><img alt="" height="259" src="/medias/images/All/167.png" width="585"></p><p>&nbsp;使用异步的方式，<strong>渲染主线程永不阻塞</strong></p><blockquote><p>如何理解 JS 的异步？</p><p></p><p>JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>渲染主线程承担着诸多的工作，渲染页面、执行、JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p></p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p></p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote><h3>JS为何会阻碍渲染？</h3><p>先看代码</p><pre><code class="language-javascript">&lt;h1&gt;Mr.Yuan is awesome!&lt;/h1&gt;&lt;button&gt;change&lt;/button&gt;&lt;script&gt;    var h1 = document.querySelector('h1');    var btn = document.querySelector('button');    // 死循环指定的时间    function delay(duration) {        var start = Date.now();        while (Date.now() - start &lt; duration) {}    }    btn.onclick = function () {        h1.textContent = '程序猿小野！';        delay(3000);    };&lt;/script&gt;</code></pre><p>点击按钮后，会发生什么呢？</p><p><img alt="" height="460" src="/medias/images/All/168.gif" width="1200"></p><p>点击按钮之后3秒，页面才会发生变化，因为修改&nbsp;h1.textContent 的值之后，会生成一个绘制的任务在消息队列里，等待delay函数执行完成后，页面才会开始渲染绘制。</p><h3>任务有优先级吗？</h3><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的解释：</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li>    <li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行。</li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法&nbsp;</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级&nbsp;「中」</li>    <li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「⾼」</li>    <li>微队列：用户存放需要最快执行的任务，优先级&nbsp;「最⾼」</li></ul><p>添加任务到微队列的主要方式是使用 Promise、MutationObserver</p><p>列如：</p><pre><code class="language-javascript">// ⽴即把⼀个函数添加到微队列Promise.resolve().then(函数)</code></pre><p>浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑</p><hr><h4>阐述一下 JS 的事件循环</h4><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在Chrome的源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据W3C官方的解释，每个任务有不同的队列。不同任务队列有不同的优先级，再一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p><p></p><h4>JS 中的计时器能做到精确计时吗？为什么？</h4><p>不行，因为：</p><p>1. 计算机硬件没有原子钟，无法做到精确计时</p><p>2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就是携带了这些偏差</p><p>3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</p><p>4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</p><p></p><p>以上内容仅作为笔记使用，来自于渡一教育的WEB前端大师课，讲师袁进，转载请注明出处。课程链接如下，如有需要，自行观看：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz" href="https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz" title="https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz">https://fe.duyiedu.com/p/t_pc/course_pc_detail/camp_pro/course_2VKbErGXkTSzvbl9aQ9HgndEtIz</a></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IE浏览器兼容性问题——el-button点击失效</title>
      <link href="/2024/04/03/70-ie-liu-lan-qi-jian-rong-xing-wen-ti-el-button-dian-ji-shi-xiao/"/>
      <url>/2024/04/03/70-ie-liu-lan-qi-jian-rong-xing-wen-ti-el-button-dian-ji-shi-xiao/</url>
      
        <content type="html"><![CDATA[<p>el-table 中经常有这种场景：最后一列是操作，只有一个图标</p><p><img alt="" height="189" src="/medias/images/All/160.png" width="816"></p><p>&nbsp;之前的实现是直接讲点击事件绑定到了 icon 图标上，这样在谷歌、edge、火狐等是没问题的，但是在ie浏览器下，就会出现点击事件无效的情况，点击后不会触发点击事件。</p><pre><code class="language-javascript">&lt;template v-slot:operation="slotData"&gt;    &lt;el-tooltip class="item" effect="dark" content="恢复" placement="top"&gt;        &lt;el-button type="text" size="small" v-preventReClick&gt;            &lt;i class="el-icon-refresh-left" @click="recoveryFunc(slotData.data)"&gt;&lt;/i&gt;        &lt;/el-button&gt;    &lt;/el-tooltip&gt;    &lt;el-tooltip class="item" effect="dark" content="删除" placement="top"&gt;        &lt;el-button type="text" size="small" v-preventReClick&gt;            &lt;i class="el-icon-delete" @click="deletePhysicalDirFileFuncOne(slotData.data)"&gt;&lt;/i&gt;        &lt;/el-button&gt;    &lt;/el-tooltip&gt;&lt;/template&gt;</code></pre><p>解决方案：将点击事件绑定到 el-button 上就行了</p><pre><code class="language-javascript">&lt;template v-slot:operation="slotData"&gt;    &lt;el-tooltip class="item" effect="dark" content="恢复" placement="top"&gt;        &lt;el-button type="text" size="small" @click="recoveryFunc(slotData.data)" v-preventReClick&gt;            &lt;i class="el-icon-refresh-left"&gt;&lt;/i&gt;        &lt;/el-button&gt;    &lt;/el-tooltip&gt;    &lt;el-tooltip class="item" effect="dark" content="删除" placement="top"&gt;        &lt;el-button type="text" size="small" @click="deletePhysicalDirFileFuncOne(slotData.data)" v-preventReClick&gt;            &lt;i class="el-icon-delete"&gt;&lt;/i&gt;        &lt;/el-button&gt;    &lt;/el-tooltip&gt;&lt;/template&gt;</code></pre><p>如果帮助到您了，可以留下一个赞👍告诉我</p>]]></content>
      
      
      <categories>
          
          <category> IE浏览器兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
            <tag> IE浏览器兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 11 如何使用 IE 浏览器</title>
      <link href="/2024/04/03/69-windows-11-ru-he-shi-yong-ie-liu-lan-qi/"/>
      <url>/2024/04/03/69-windows-11-ru-he-shi-yong-ie-liu-lan-qi/</url>
      
        <content type="html"><![CDATA[<p>众所周知：IE 浏览器已经被微软废弃，像windows 11这种系统内置已经找不到 IE 浏览器了，这对前端工程师而言，肯定是不行的。因为项目中，经常有现场需要支持 ie 浏览器。（吐槽一下：微软都放弃了，国内的客户大佬们还没放弃，真爱啊）</p><p></p><p>吐槽归吐槽：</p><p>我们仍然可以通过&nbsp;<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="VBS" href="https://so.csdn.net/so/search?q=VBS&amp;spm=1001.2101.3001.7020" title="VBS">VBS</a>&nbsp;脚本来打开 IE 浏览器。</p><p>桌面 --&gt; 右键新建文本文档&nbsp; --&gt; 输入以下内容 --&gt; 保存后修改文件后缀名为 .vbs --&gt; 双击即可打开IE浏览器</p><pre><code class="language-bash">CreateObject("InternetExplorer.Application").Visible=true</code></pre><p><img alt="" height="241" src="/medias/images/All/159.png" width="1200"><img alt="" height="1150" src="/medias/images/All/160.gif" width="1200"></p><p></p><p>如果帮助到您了，可以留下一个赞👍告诉我</p>]]></content>
      
      
      <categories>
          
          <category> IE浏览器兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IE浏览器兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IE浏览器兼容性问题——get请求来自缓存的处理方案</title>
      <link href="/2024/04/02/68-ie-liu-lan-qi-jian-rong-xing-wen-ti-get-qing-qiu-lai-zi-huan-cun-de-chu-li-fang-an/"/>
      <url>/2024/04/02/68-ie-liu-lan-qi-jian-rong-xing-wen-ti-get-qing-qiu-lai-zi-huan-cun-de-chu-li-fang-an/</url>
      
        <content type="html"><![CDATA[<p>问题背景：在IE浏览器下，新增add接口请求成功之后，调用了get查询接口，但是查询接口返回的数据没有刚刚新增add的数据。</p><p>控制查看，发现当前查询的接口有（来自缓存）几个字</p><p><img alt="" height="334" src="/medias/images/All/155.png" width="1136"></p><p>&nbsp;解决方案：</p><p>1、改成post请求，这种需要后台接口同步修改。不建议。</p><p>2、给get请求后面加上时间戳。</p><p>单个接口修改</p><p><img alt="" height="71" src="/medias/images/All/156.png" width="589"></p><pre><code class="language-javascript">export const getSecTree = async () =&gt; {    return await http.get(`${api.SEC_TREE_LIST}?t=${new Date().getTime()}`);};</code></pre><p>统一修改，项目里使用的axios，在请求拦截器里添加</p><p><img alt="" height="296" src="/medias/images/All/157.png" width="369"></p><pre><code class="language-javascript">//创建axios实例this._instance = axios.create(this._defaultConfig);//添加请求拦截器this._instance.interceptors.request.use(config =&gt; {    // ... 其他判断    // 添加时间戳    if (config.method == 'get') {        config.params = {            ...config.params,            v: new Date().getTime()        };    }    // ...    return config;});</code></pre><p>&nbsp;处理后，再看控制台，get请求的接口已经加上了时间戳，问题解决。</p><p><img alt="" height="388" src="/medias/images/All/158.png" width="1200"></p><p></p>]]></content>
      
      
      <categories>
          
          <category> IE浏览器兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue2.0 </tag>
            
            <tag> IE浏览器兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-table 如何自定义暂无数据的样式</title>
      <link href="/2024/04/02/67-el-table-ru-he-zi-ding-yi-zan-wu-shu-ju-de-yang-shi/"/>
      <url>/2024/04/02/67-el-table-ru-he-zi-ding-yi-zan-wu-shu-ju-de-yang-shi/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;效果如图所示：</p><p><img alt="" height="518" src="/medias/images/All/153.png" width="798"></p><p>&nbsp;查看官方文档，el-table 提供了 empty-text 属性，可以直接设置文本内容，也可以通过slot = “empty”自定义设置：</p><p><img alt="" height="187" src="/medias/images/All/154.png" width="1200"></p><p>&nbsp;核心代码：</p><pre><code class="language-html">&lt;div slot="empty" class="empty"&gt;    &lt;img src="@/assets/empty_images/data_empty.png" /&gt;&lt;/div&gt;</code></pre><p>&nbsp;因为图片里已经包含了 “暂无数据” 的文本，所以不再设置。如果自定义的图片不包含文本，也可以额外设置：</p><pre><code class="language-html">&lt;div slot="empty" class="empty"&gt;    &lt;img src="@/assets/empty_images/data_empty.png" /&gt;    &lt;span class="txt"&gt;暂无数据&lt;/span&gt;&lt;/div&gt;</code></pre><p>&nbsp;完整代码：</p><pre><code class="language-html">&lt;el-table size="mini" :data="tableData" @selection-change="handleSelectionChange"&gt;    &lt;el-table-column type="selection" width="50"&gt;&lt;/el-table-column&gt;    &lt;el-table-column prop="fileTypeStr" label="文件类型"&gt;&lt;/el-table-column&gt;    &lt;el-table-column label="操作" width="120" align="center"&gt;        &lt;template slot-scope="scope"&gt;            &lt;!-- 修改 --&gt;            &lt;el-button type="text" @click.native="editHandle(scope.row)"&gt;修改&lt;/el-button&gt;            &lt;!-- 删除 --&gt;            &lt;el-button type="text" @click.native="delHandle(scope.row)"&gt; 删除&lt;/el-button&gt;        &lt;/template&gt;    &lt;/el-table-column&gt;    &lt;div slot="empty" class="empty"&gt;        &lt;img src="@/assets/empty_images/data_empty.png" style="max-width: 140px" /&gt;    &lt;/div&gt;&lt;/el-table&gt;</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 模块化</title>
      <link href="/2024/04/01/66-js-mo-kuai-hua/"/>
      <url>/2024/04/01/66-js-mo-kuai-hua/</url>
      
        <content type="html"><![CDATA[<h2>一、什么是模块化？</h2><h3>1.1 定义</h3><blockquote><ul><li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>    <li>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</li></ul></blockquote><h3>&nbsp;1.2 模块化的进化过程</h3><h5>&nbsp;1.2.1 全局function模式</h5><pre><code class="language-javascript"> * 全局函数模式: 将不同的功能封装成不同的全局函数 * 问题: Global被污染了, 很容易引起命名冲突 */function foo() {    console.log('foo()')}function bar() {    console.log('bar()')}</code></pre><blockquote><p>&nbsp;问题： 污染全局命名空间, 容易引起命名冲突/数据不安全</p></blockquote><h5>1.2.2 namespace模式&nbsp;</h5><pre><code class="language-javascript">/** * namespace模式: 简单对象封装 * 作用: 减少了全局变量 * 问题: 不安全(数据不是私有的, 外部可以直接修改) */let myModule = {  data: 'Jerry',  foo() {    console.log(`foo() ${this.data}`)  },  bar() {    console.log(`bar() ${this.data}`)  }}</code></pre><blockquote><ul><li>&nbsp;减少了Global上的变量数目</li>    <li>本质是对象，一点都不安全</li></ul></blockquote><h5>&nbsp;1.2.3&nbsp;IIFE模式</h5><pre><code class="language-javascript">/** * IIFE模式: 匿名函数自调用(闭包) * IIFE : immediately-invoked function expression(立即调用函数表达式) * 作用: 数据是私有的, 外部只能通过暴露的方法操作 * 问题: 如果当前这个模块依赖另一个模块怎么办? */(function (window) {  //数据  let data = 'Jerry'  //操作数据的函数  function foo() { //用于暴露有函数    console.log(`foo() ${data}`)  }  function bar() {//用于暴露有函数    console.log(`bar() ${data}`)    otherFun() //内部调用  }  function otherFun() { //内部私有的函数    console.log('otherFun()')  }  //暴露行为  window.myModule = {foo, bar}})(window)</code></pre><p>&nbsp;&nbsp;IIFE模式增强：引入依赖</p><pre><code class="language-javascript">(function (window, $) {  //数据  let data = 'Jerry'  //操作数据的函数  function foo() { //用于暴露有函数    console.log(`foo() ${data}`)    $('body').css('background', 'red')  }  function bar() {//用于暴露有函数    console.log(`bar() ${data}`)    otherFun() //内部调用  }  function otherFun() { //内部私有的函数    console.log('otherFun()')  }  //暴露行为  window.myModule = {foo, bar}})(window, jQuery)</code></pre><blockquote><ul><li>IIFE : 立即调用函数表达式---&gt;匿名函数自调用</li>    <li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li>    <li>引入依赖: 通过函数形参来引入依赖模块&nbsp;</li></ul></blockquote><h3>1.3 模块化的好处</h3><blockquote><ul><li>避免命名冲突（减少命名空间污染）</li>    <li>更好的分离，按需加载</li>    <li>更高复用性</li>    <li>高可维护性</li></ul></blockquote><pre><code class="language-javascript">&lt;body&gt;&lt;!--  1. 一个页面需要引入多个js文件  2. 问题:    1). 请求过多    2). 依赖模糊    3). 难以维护  3. 这些问题可以通过现代模块化编码和项目构建来解决--&gt;&lt;script type="text/javascript" src="module1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="module2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="module4.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="module3.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../04_IIFE模式增强/jquery-1.10.1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../04_IIFE模式增强/test4.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;  module.foo()&lt;/script&gt;&lt;/body&gt;</code></pre><h2>&nbsp;二、模块化规范</h2><h3>2.1&nbsp;&nbsp;CommonJS</h3><blockquote><p><span style="color:#ff9900;">Node.js</span>：&nbsp; &nbsp; &nbsp;服务器端</p><p><span style="color:#ff9900;">Browserify </span>:&nbsp; 浏览器端 &nbsp; &nbsp;也称为js的打包工具(CommonJs 浏览器端打包工具&nbsp;)</p></blockquote><pre><code class="language-javascript">// 基本语法:      // 定义暴露模块 : exports        exports.xxx = value        module.exports = value      // 引入模块 : require        var module = require('模块名/模块相对路径')</code></pre><blockquote><p>&nbsp;引入模块发生在什么时候?</p><ul><li>Node : 运行时, 动态同步引入</li>    <li>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了),&nbsp; 运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</li></ul></blockquote><h4>2.1.1 CommonJS-Node</h4><p>代码示例：</p><p>module1.js&nbsp; &nbsp;使用module.exports = value向外暴露一个对象</p><pre><code class="language-javascript">/** * 使用module.exports = value向外暴露一个对象 */"use strict"module.exports = {  foo() {    console.log('moudle1 foo()')  }}</code></pre><p>&nbsp;module2.js&nbsp; &nbsp; &nbsp;使用module.exports = value向外暴露一个对象</p><pre><code class="language-javascript">/** * 使用module.exports = value向外暴露一个函数 */module.exports = function () {  console.log('module2()')}</code></pre><p>&nbsp;module3.js&nbsp; &nbsp; &nbsp; 使用exports.xxx = value向外暴露多个对象</p><pre><code class="language-javascript">/** * 使用exports.xxx = value向外暴露多个对象 */"use strict"exports.foo = function () {  console.log('module3 foo()')}exports.bar = function () {  console.log('module3 bar()')}</code></pre><p>&nbsp;使用时，用 require() 语法导入</p><pre><code class="language-javascript">/**  1. 定义暴露模块:    module.exports = value;    exports.xxx = value;  2. 引入模块:    var module = require(模块名或模块路径); */"use strict"//引用模块let module1 = require('./modules/module1')let module2 = require('./modules/module2')let module3 = require('./modules/module3')let uniq = require('uniq')let fs = require('fs')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3]))fs.readFile('app.js', function (error, data) {  console.log(data.toString())})</code></pre><h4>2.1.2&nbsp;CommonJS-Browserify&nbsp;</h4><blockquote><p>&nbsp;下载 browserify</p><p>&nbsp; * 全局: npm install browserify -g</p><p>&nbsp; * 局部: npm install browserify --save-dev</p></blockquote><blockquote><p>打包处理js:</p><p>browserify js/src/app.js -o js/dist/bundle.js</p></blockquote><blockquote><p>页面使用引入:</p><p>&nbsp; &lt;script type="text/javascript" src="js/dist/bundle.js"&gt;&lt;/script&gt;</p></blockquote><h3>2.2 AMD - RequireJS</h3><blockquote><p>说明： 专门用于浏览器端，模块的加载是异步的&nbsp; &nbsp; &nbsp;<a data-link-desc="Houses the Asynchronous Module Definition API. Contribute to amdjs/amdjs-api development by creating an account on GitHub." data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="AMD · amdjs/amdjs-api Wiki · GitHub" href="https://github.com/amdjs/amdjs-api/wiki/AMD" title="AMD · amdjs/amdjs-api Wiki · GitHub">AMD · amdjs/amdjs-api Wiki · GitHub</a>&nbsp;</p></blockquote><p>基本语法：</p><p>定义暴露模块：</p><pre><code class="language-javascript">// 定义没有依赖的模块define(function () {  let msg = 'atguigu.com'      function getMsg() {    return msg.toUpperCase()  }      return {getMsg}})// 定义有依赖的模块define(['dataService', 'jquery'], function (dataService, $) {  let name = 'Tom2'      function showMsg() {    $('body').css('background', 'gray')    alert(dataService.getMsg() + ', ' + name)  }      return {showMsg}})</code></pre><p>引入使用模块：</p><pre><code class="language-javascript">//引入使用模块requirejs( ['alerter'], function(alerter) {  alerter.showMsg()})</code></pre><p>举例说明：alerter.js 依赖 dataService.js 和 jquery模块，可以在alerter.js中这样写：</p><pre><code class="language-javascript">/* 定义有依赖的模块 */define(['dataService', 'jquery'], function (dataService, $) {  let name = 'Tom2'  function showMsg() {    $('body').css('background', 'gray')    alert(dataService.getMsg() + ', ' + name)  }  return {showMsg}})</code></pre><p>&nbsp;在 main.js 中引入依赖</p><pre><code class="language-javascript">(function () {  //配置  require.config({    //基本路径    baseUrl: 'js/',    //映射: 模块标识名: 路径    paths: {      //自定义模块      'alerter': 'modules/alerter',      'dataService': 'modules/dataService',      //库模块      'jquery': 'libs/jquery-1.10.1',      'angular': 'libs/angular'          },    //配置不兼容AMD的模块    shim: {      angular: {        exports: 'angular'      }    }  })  //引入模块使用  require(['alerter', 'angular'], function (alerter, angular) {    alerter.showMsg()    console.log(angular);  })})()</code></pre><p>在html页面中引入即可：</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Modular Demo 2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script type="text/javascript" src="js/libs/require.js" data-main="js/main.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>关于 require.js 的详细用法可以参考：</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="Javascript模块化编程（三）：require.js的用法 - 阮一峰的网络日志" href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" title="Javascript模块化编程（三）：require.js的用法 - 阮一峰的网络日志">Javascript模块化编程（三）：require.js的用法 - 阮一峰的网络日志</a></p><h3>2.3 CMD - SeaJS&nbsp;</h3><p>首先需要引入 sea.js的库</p><pre><code class="language-javascript">&lt;script type="text/javascript" src="js/libs/sea.js"&gt;&lt;/script&gt;</code></pre><h4>定义导出模块&nbsp;&nbsp;define()&nbsp;&nbsp;exports&nbsp;&nbsp;module.exports</h4><p>module1.js</p><pre><code class="language-javascript">define(function (require, exports, module) {  //内部变量数据  var data = 'atguigu.com'  //内部函数  function show() {    console.log('module1 show() ' + data)  }  //向外暴露  exports.show = show})</code></pre><p>&nbsp;module2.js</p><pre><code class="language-javascript">define(function (require, exports, module) {  module.exports = {    msg: 'I Will Back'  }})</code></pre><p>module3.js</p><pre><code class="language-javascript">define(function (require, exports, module) {  const API_KEY = 'abc123'  exports.API_KEY = API_KEY})</code></pre><h4>引入依赖模块&nbsp; &nbsp;require()</h4><p>module4.js</p><pre><code class="language-javascript">define(function (require, exports, module) {  //引入依赖模块(同步)  var module2 = require('./module2')  function show() {    console.log('module4 show() ' + module2.msg)  }  exports.show = show  //引入依赖模块(异步)  require.async('./module3', function (m3) {    console.log('异步引入依赖模块3  ' + m3.API_KEY)  })})</code></pre><p>&nbsp;main.js</p><pre><code class="language-javascript">define(function (require) {  var m1 = require('./module1')  var m4 = require('./module4')  m1.show()  m4.show()})</code></pre><h4>&nbsp;使用模块&nbsp; seajs.use()</h4><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!--使用seajs:  1. 引入sea.js库  2. 如何定义导出模块 : define()   exports   module.exports  3. 引入依赖模块:   require()  4. 如何使用模块:   seajs.use()--&gt;    &lt;script type="text/javascript" src="js/libs/sea.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript"&gt;      seajs.use("./js/modules/main");    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3>&nbsp;2.4 ES6 模块化</h3><p>依赖模块需要编译打包处理，使用Babel将ES6编译为ES5代码</p><p>export：导出模块，引入模块：import</p><p>1. 定义package.json&nbsp;</p><p>2. 安装依赖包</p><pre><code class="language-javascript">安装babel-cli, babel-preset-es2015和browserify npm install babel-cli browserify -g  npm install babel-preset-es2015 --save-dev  presets 预设(将es6转换成es5的所有插件打包)</code></pre><p>3.&nbsp;定义.babelrc文件</p><pre><code class="language-javascript">{   "presets": ["es2015"]}</code></pre><p>4. 编码</p><p>&nbsp;module1.js 分别暴露</p><pre><code class="language-javascript">define(function (require, exports, module) {  //内部变量数据  var data = 'atguigu.com'  //内部函数  function show() {    console.log('module1 show() ' + data)  }  //向外暴露  exports.show = show})</code></pre><p>&nbsp;module2.js &nbsp;统一暴露</p><pre><code class="language-javascript">let data = 'module2 data'function fun1() {  console.log('module2 fun1() ' + data);}function fun2() {  console.log('module2 fun2() ' + data);}export {fun1, fun2}</code></pre><p>module3.js&nbsp; export default</p><pre><code class="language-javascript">export default {  name: 'Tom',  setName: function (name) {    this.name = name  }}</code></pre><p>app.js 引入模块 import</p><pre><code class="language-javascript">import {foo, bar} from './module1'import {DATA_ARR} from './module1'import {fun1, fun2} from './module2'import person from './module3'import $ from 'jquery'$('body').css('background', 'red')foo()bar()console.log(DATA_ARR);fun1()fun2()person.setName('JACK')console.log(person.name);</code></pre><p>5. 编译</p><p>&nbsp; * 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib</p><p>&nbsp; * 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js</p><p>6. 页面中测试引入</p><pre><code class="language-javascript">&lt;script type="text/javascript" src="js/lib/bundle.js"&gt;&lt;/script&gt;</code></pre><p>7. 引入第三方模块(jQuery)</p><p>&nbsp; 1). 下载jQuery模块:</p><p>&nbsp; &nbsp; &nbsp;npm install jquery@1 --save</p><p>&nbsp; 2). 在app.js中引入并使用</p><pre><code class="language-javascript"> import $ from 'jquery'&nbsp;$('body').css('background', 'red')</code></pre><p></p><p>&nbsp; &nbsp;&nbsp;</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理Jenkins打包npm install没有拉取到最新依赖的问题</title>
      <link href="/2024/04/01/65-ru-he-chu-li-jenkins-da-bao-npm-install-mei-you-la-qu-dao-zui-xin-yi-lai-de-wen-ti/"/>
      <url>/2024/04/01/65-ru-he-chu-li-jenkins-da-bao-npm-install-mei-you-la-qu-dao-zui-xin-yi-lai-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>问题背景：</p><p>我们项目中有私有依赖包 frame，是私有服务器上通过 npm 去管理。frame包 publish 之后，通过Jenkins打包时，npm install 一直没有拉取最新的代码。</p><p></p><p>思考：通过在本地直接替换 node_modules 里的 frame 包，npm run build 再部署是没有问题的。那么可能就是Jenkins打包的时候，有缓存导致的。</p><p></p><p>查看原有的Jenkins构建命令如下：</p><p><img alt="" height="781" src="/medias/images/All/151.png" width="1200"></p><pre><code class="language-bash">cd web/npm cache clean --forcenpm config set registry https://registry.npmmirror.comnpm inpm run build</code></pre><p>&nbsp;修改之后如下：</p><pre><code class="language-bash">cd web/directory="node_modules"if [ -d "$directory" ]; then    rm -r "$directory"    echo "Directory $directory deleted"else    echo "Directory $directory does not exist"finpm cache clean --forcenpm config set registry https://registry.npmmirror.comnpm inpm run build</code></pre><p>&nbsp;主要是添加判断，如果Jenkins前端项目的工作空间中存在&nbsp;node_modules 文件夹，则把node_modules 文件夹及其子文件夹都删除。然后在重新 npm install。</p><p>修改后，可以拉取到最新代码的依赖包。问题解决。</p><p></p><p>Jenkins也支持清理工作空间，可以打包前，手动清理一下工作空间</p><p><img alt="" height="608" src="/medias/images/All/152.png" width="528"></p><p></p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-form 的表单校验，如何验证某一项或者多项；validateField 的使用</title>
      <link href="/2024/03/18/64-el-form-de-biao-dan-xiao-yan-ru-he-yan-zheng-mou-yi-xiang-huo-zhe-duo-xiang-validatefield-de-shi-yong/"/>
      <url>/2024/03/18/64-el-form-de-biao-dan-xiao-yan-ru-he-yan-zheng-mou-yi-xiang-huo-zhe-duo-xiang-validatefield-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>通常对form表单的校验都是整体校验：</p><pre><code class="language-javascript">this.$refs.form.validate( valid =&gt; {    if (valid) {        // 校验通过，业务逻辑代码...    }});</code></pre><p>如果需要对表单里的特定一项或几项进行校验，应该如何实现？&nbsp;</p><p>业务场景：下图点探测按钮时，只需要校验前四项，后面的表单项不需要校验</p><p><img alt="" height="547" src="/medias/images/All/149.png" width="902"></p><p>Elementui 官网文档截图：</p><p><img alt="" height="774" src="/medias/images/All/150.png" width="1200"></p><blockquote><p>validateField 这个方法接受两个参数，第一参数为数组或者字符串，第二个参数为回调函数&nbsp;</p></blockquote><pre><code class="language-javascript">// 点击探测，请求接口detectionFunc() {    let hasError = false;    this.$refs.ruleForm.validateField(['ip', 'port', 'user', 'pwd'], err =&gt; {        if (err) {            hasError = true;            return;        }    });    if (!hasError) {        // 不存在校验不通过的项，请求探测接口...    }}</code></pre><p>&nbsp;如果要校验某一项，第一个参数传字符串就可以了。</p><blockquote><p>注意事项：校验多项时，第一个参数传数组，回调函数会触发多次</p></blockquote><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过点击按钮实现查看全屏和退出全屏的效果</title>
      <link href="/2024/03/18/63-tong-guo-dian-ji-an-niu-shi-xian-cha-kan-quan-ping-he-tui-chu-quan-ping-de-xiao-guo/"/>
      <url>/2024/03/18/63-tong-guo-dian-ji-an-niu-shi-xian-cha-kan-quan-ping-he-tui-chu-quan-ping-de-xiao-guo/</url>
      
        <content type="html"><![CDATA[<p>动态效果如图： 可以通过点击按钮，或者esc键实现全屏和退出全屏的效果</p><p><img alt="" height="1108" src="/medias/images/All/149.gif" width="1200"></p><p>&nbsp;实现代码：</p><pre><code class="language-javascript">&lt;template&gt;    &lt;div class="hello"&gt;        &lt;el-button @click="fullScreen()" v-if="!isFullscreen"&gt;查看全屏&lt;/el-button&gt;        &lt;el-button @click="fullScreen()" v-else&gt;退出全屏&lt;/el-button&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'HelloWorld',    created() {        document.addEventListener('fullscreenchange', () =&gt; {            this.$nextTick(() =&gt; {                // 这里对全屏后样式进行操作                this.isFullscreen = !this.isFullscreen;            });        });    },    data() {        return {            isFullscreen: false        };    },    methods: {        fullScreen() {            /*判断是否全屏*/            let isFullscreen =                document.fullScreenElement || //W3C                document.msFullscreenElement || //IE                document.mozFullScreenElement || //火狐                document.webkitFullscreenElement || //谷歌                false;            if (!isFullscreen) {                let el = document.documentElement;                if (el.requestFullscreen) {                    el.requestFullscreen();                } else if (el.mozRequestFullScreen) {                    el.mozRequestFullScreen();                } else if (el.webkitRequestFullscreen) {                    el.webkitRequestFullscreen();                } else if (el.msRequestFullscreen) {                    el.msRequestFullscreen();                }                console.log('切换到了全屏');            } else {                if (document.exitFullscreen) {                    document.exitFullscreen();                } else if (document.msExitFullscreen) {                    document.msExitFullscreen();                } else if (document.mozCancelFullScreen) {                    document.mozCancelFullScreen();                } else if (document.webkitCancelFullScreen) {                    document.webkitCancelFullScreen();                }                console.log('退出了全屏');            }        }    }};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-table 的选择框如何根据条件设置某项不可选中</title>
      <link href="/2024/03/13/62-el-table-de-xuan-ze-kuang-ru-he-gen-ju-tiao-jian-she-zhi-mou-xiang-bu-ke-xuan-zhong/"/>
      <url>/2024/03/13/62-el-table-de-xuan-ze-kuang-ru-he-gen-ju-tiao-jian-she-zhi-mou-xiang-bu-ke-xuan-zhong/</url>
      
        <content type="html"><![CDATA[<p>效果如图：实现某条数据不可选，其他数据可选&nbsp;</p><p><img alt="" height="588" src="/medias/images/All/148.png" width="1200"></p><blockquote><p>核心代码：&nbsp;&lt;el-table-column type="selection" width="55" :selectable="selectable"&gt;&lt;/el-table-column&gt;&nbsp; 在选择框的列上加上&nbsp;<span style="color:#fe2c24;">:selectable="selectable"&nbsp;</span><span style="color:#0d0016;">，selectable是一个函数，返回值为false的时候，表格列禁止选中</span></p></blockquote><pre><code class="language-javascript">&lt;template&gt;    &lt;div class="hello"&gt;        &lt;el-table ref="multipleTable" :data="tableData" tooltip-effect="dark" style="width: 100%" @selection-change="handleSelectionChange"&gt;            &lt;el-table-column type="selection" width="55" :selectable="selectable"&gt;&lt;/el-table-column&gt;            &lt;el-table-column label="日期" width="120"&gt;                &lt;template slot-scope="scope"&gt;{{ scope.row.date }}&lt;/template&gt;            &lt;/el-table-column&gt;            &lt;el-table-column prop="name" label="姓名" width="120"&gt;&lt;/el-table-column&gt;            &lt;el-table-column prop="address" label="地址" show-overflow-tooltip&gt;&lt;/el-table-column&gt;        &lt;/el-table&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'HelloWorld',    data() {        return {            tableData: [                {                    date: '2016-05-03',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                },                {                    date: '2016-05-02',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                },                {                    date: '2016-05-04',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                },                {                    date: '2016-05-01',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                },                {                    date: '2016-05-08',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                },                {                    date: '2016-05-06',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                },                {                    date: '2016-05-07',                    name: '王小虎',                    address: '上海市普陀区金沙江路 1518 弄'                }            ]        };    },    methods: {        selectable(row, index) {            // 这里可以根据具体业务逻辑判断，returnfalse就是不可选择，row为表格行数据            // 设置第四行为不可选中            if (index == 3) {                return false;            } else {                return true;            }        }    }};&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI Message 消息提示，多个显示被覆盖的问题</title>
      <link href="/2024/03/13/61-elementui-message-xiao-xi-ti-shi-duo-ge-xian-shi-bei-fu-gai-de-wen-ti/"/>
      <url>/2024/03/13/61-elementui-message-xiao-xi-ti-shi-duo-ge-xian-shi-bei-fu-gai-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>现象截图：</p><p><img alt="" height="398" src="/medias/images/All/146.png" width="959"></p><p>代码：主要是在this.$message 方法外层加上&nbsp;setTimeout 方法</p><pre><code class="language-javascript">&lt;script&gt;export default {  name: "HelloWorld",  props: {    msg: String,  },  methods: {    showMessage() {      for (let i = 0; i &lt; 10; i++) {        setTimeout(() =&gt; {          this.$message({showClose: true, message: "删除成功", type: "success" });        }, 0);      }    },  },};&lt;/script&gt;</code></pre><p>问题解决：</p><p><img alt="" height="1037" src="/medias/images/All/147.png" width="1200"></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在vue中使用golden-layout</title>
      <link href="/2024/02/04/60-ru-he-zai-vue-zhong-shi-yong-golden-layout/"/>
      <url>/2024/02/04/60-ru-he-zai-vue-zhong-shi-yong-golden-layout/</url>
      
        <content type="html"><![CDATA[<p>在Vue中使用golden-layout，需要先安装golden-layout和vue-golden-layout这两个库。你可以使用npm或者yarn进行安装，例如：</p><pre><code class="language-javascript">npm install golden-layout vue-golden-layout --save或者yarn add golden-layout vue-golden-layout</code></pre><p>安装完成后，你需要在Vue的入口文件中引入这两个库，并注册vue-golden-layout组件，例如：</p><pre><code class="language-javascript">import Vue from 'vue'import GoldenLayout from 'golden-layout'import VueGoldenLayout from 'vue-golden-layout'Vue.use(VueGoldenLayout, { GoldenLayout })</code></pre><p>然后，在你的Vue组件中就可以使用vue-golden-layout组件了，例如：</p><pre><code class="language-javascript">&lt;template&gt;&nbsp; &lt;vue-golden-layout :config="config" :components="components" /&gt;&lt;/template&gt;&lt;script&gt;export default {&nbsp; data() {&nbsp; &nbsp; return {&nbsp; &nbsp; &nbsp; config: {&nbsp; &nbsp; &nbsp; &nbsp; content: [{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type: 'row',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; content: [{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type: 'component',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentName: 'myComponent',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentState: { label: 'A' }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }, {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type: 'column',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; content: [{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type: 'component',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentName: 'myComponent',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentState: { label: 'B' }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }, {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type: 'component',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentName: 'myComponent',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; componentState: { label: 'C' }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }]&nbsp; &nbsp; &nbsp; &nbsp; }]&nbsp; &nbsp; &nbsp; },&nbsp; &nbsp; &nbsp; components: {&nbsp; &nbsp; &nbsp; &nbsp; myComponent: {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; template: '&lt;div&gt;{{label}}&lt;/div&gt;',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; props: ['label']&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }&nbsp; }}&lt;/script&gt;</code></pre><p>在上面的代码中，我们使用了vue-golden-layout组件，并传入了两个props：config和components。config用于设置golden-layout的配置项，components用于注册golden-layout中的组件。在这个例子中，我们注册了一个名为myComponent的组件，并在golden-layout中使用了这个组件。</p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> golden-layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器控制台报错：Uncaught DOMException: Failed to read the ‘localStorage‘ property from ‘Window‘：Access is d</title>
      <link href="/2024/02/04/59-liu-lan-qi-kong-zhi-tai-bao-cuo-uncaught-domexception-failed-to-read-the-localstorage-property-from-window-access-is-d/"/>
      <url>/2024/02/04/59-liu-lan-qi-kong-zhi-tai-bao-cuo-uncaught-domexception-failed-to-read-the-localstorage-property-from-window-access-is-d/</url>
      
        <content type="html"><![CDATA[<p>具体问题场景如下：</p><p>使用无痕浏览器访问，控制台报错，如下图：</p><p><span style="color:#fe2c24;">Uncaught DOMException: Failed to read the 'localStorage' property from 'Window'：Access is denied for this document.</span></p><p><img alt="" height="255" src="/medias/images/All/142.png" width="1200"></p><p><img alt="" height="1200" src="/medias/images/All/143.png" width="1200">&nbsp;浏览器默认是选择第二项：在无痕模式下阻止第三方Cookie，所以才会出现问题<img alt="" height="1200" src="/medias/images/All/144.png" width="1200"></p><p>不同浏览器的设置选项不同：主要的思路就是将浏览器的Cookie设置成允许第三方Cookie</p><p><img alt="" height="425" src="/medias/images/All/145.png" width="1200"></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 包管理工具</title>
      <link href="/2024/02/04/58-node.js-bao-guan-li-gong-ju/"/>
      <url>/2024/02/04/58-node.js-bao-guan-li-gong-ju/</url>
      
        <content type="html"><![CDATA[<h2>一、概念介绍</h2><hr><h3>1.1 包是什么</h3><p>『包』英文单词是 <span style="color:#ff9900;">package </span>，代表了一组特定功能的源码集合</p><h3>1.2 包管理工具</h3><p>管理『包』的应用软件，可以对「包」进行 <span style="color:#ff9900;">下载安装</span> ， <span style="color:#ff9900;">更新 </span>， <span style="color:#ff9900;">删除 </span>， <span style="color:#ff9900;">上传</span> 等操作。</p><p>借助包管理工具，可以快速开发项目，提升开发效率</p><p>包管理工具是一个通用的概念，很多编程语言都有包管理工具，所以 <span style="color:#ff9900;">掌握好包管理工具非常重要</span></p><h3>&nbsp;1.3 常用的包管理工具</h3><p>下面列举了前端常用的包管理工具</p><ul><li><span style="color:#ff9900;">npm</span></li>    <li>yarn</li>    <li>cnpm</li></ul><h2>&nbsp;二、npm</h2><hr><p>npm 全称 <span style="color:#ff9900;">Node Package Manager </span>，翻译为中文意思是『Node 的包管理工具』</p><p>npm 是 node.js 官方内置的包管理工具，是 <span style="color:#ff9900;">必须要掌握住的工具</span></p><h3>2.1 npm 的安装&nbsp;</h3><p>node.js 在安装时会 <span style="color:#ff9900;">自动安装 npm</span> ，所以如果你已经安装了 node.js，可以直接使用 npm</p><p>可以通过 npm -v 查看版本号测试，如果显示版本号说明安装成功，反之安装失败</p><p><img alt="" height="232" src="/medias/images/All/136.png" width="621"></p><blockquote><p>&nbsp;查看版本时可能与上图版本号不一样，不过不影响正常使用</p></blockquote><h3>2.2 npm 基本使用</h3><h6>2.2.1 初始化</h6><p>创建一个空目录，然后以此目录作为工作目录 <span style="color:#ff9900;">启动命令行工具</span> ，执行 <span style="color:#ff9900;">npm init</span></p><p><img alt="" height="328" src="/medias/images/All/137.png" width="673"></p><p><span style="color:#ff9900;">npm init </span>命令的作用是将文件夹初始化为一个『包』， <span style="color:#ff9900;">交互式创建 package.json 文件</span></p><p><span style="color:#ff9900;">package.json</span> 是包的配置文件，每个包都必须要有 <span style="color:#ff9900;">package.json</span></p><p><span style="color:#ff9900;">package.json</span> 内容示例：</p><pre><code class="language-javascript">{  "name": "test",  "version": "1.0.0",  "description": "",  "main": "index.js",  "scripts": {    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"  },  "author": "",  "license": "ISC"}</code></pre><p>&nbsp;属性翻译</p><pre><code class="language-javascript">{"name": "test",      #包的名字"version": "1.0.0",  #包的版本"description": "",   #包的描述"main": "index.js",  #包的入口文件"scripts": {         #脚本配置"test": "echo \"Error: no test specified\" &amp;&amp; exit 1"},"author": "",        #作者"license": "ISC"     #开源证书}</code></pre><blockquote><p>初始化的过程中还有一些注意事项：</p><p>&nbsp;1. package name ( <span style="color:#ff9900;">包名</span> ) 不能使用中文、大写，默认值是 <span style="color:#ff9900;">文件夹的名称</span> ，所以文件夹名称也不 能使用中文和大写</p><p>&nbsp;2. version ( <span style="color:#ff9900;">版本号</span> )要求 <span style="color:#ff9900;">x.x.x</span> 的形式定义， <span style="color:#ff9900;">x </span>必须是数字，默认值是 <span style="color:#ff9900;">1.0.0</span></p><p>&nbsp;3. ISC 证书与 MIT 证书功能上是相同的，关于开源证书扩展阅读http://www.ruanyifeng.com/bl og/2011/05/how_to_choose_free_software_licenses.html</p><p>&nbsp;4. <span style="color:#ff9900;">package.json</span> 可以手动创建与修改</p><p>&nbsp;5. 使用 <span style="color:#ff9900;">npm init -y</span> 或者 <span style="color:#ff9900;">npm init --yes</span> 极速创建 <span style="color:#ff9900;">package.json</span></p></blockquote><h6>&nbsp;2.2.2 搜索包</h6><p>搜索包的方式有两种:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 命令行 『npm s/search 关键字』</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<span style="color:#ff9900;"> 网站搜索</span> 网址是 <span style="color:#ff9900;">https://www.npmjs.com/</span></p><h6>&nbsp;2.2.3 下载安装包</h6><p>我们可以通过 npm install 和 npm i 命令安装包</p><pre><code class="language-javascript"># 格式npm install &lt;包名&gt;npm i &lt;包名&gt;# 示例npm install uniqnpm i uniq</code></pre><p>&nbsp;运行之后文件夹下会增加两个资源</p><ul><li><span style="color:#ff9900;">node_modules</span> 文件夹 存放下载的包</li>    <li><span style="color:#ff9900;">package-lock.json 包的锁文件</span> ，用来锁定包的版本</li></ul><blockquote><p>安装 uniq 之后， uniq 就是当前这个包的一个 <span style="color:#ff9900;">依赖包</span> ，有时会简称为 <span style="color:#ff9900;">依赖</span></p><p>比如我们创建一个包名字为 A，A 中安装了包名字是 B，我们就说 <span style="color:#ff9900;">B 是 A 的一个依赖包</span> ，也会说 <span style="color:#ff9900;">A 依赖 B</span></p></blockquote><h6>&nbsp;2.2.4 require 导入 npm 包基本流程</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 在当前文件夹下 node_modules 中寻找同名的文件夹</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 在上级目录中下的 node_modules 中寻找同名的文件夹，直至找到磁盘根目录</p><h3>&nbsp;2.3 生产环境与开发环境</h3><p>开发环境是程序员 <span style="color:#ff9900;">专门用来写代码</span> 的环境，一般是指程序员的电脑，开发环境的项目一般 <span style="color:#ff9900;">只能程序员自己访问</span></p><p>生产环境是项目 <span style="color:#ff9900;">代码正式运行</span> 的环境，一般是指正式的服务器电脑，生产环境的项目一般 <span style="color:#ff9900;">每个客户都可以访问</span></p><h3>&nbsp;2.4 生产依赖与开发依赖</h3><p>我们可以在安装时设置选项来区分 <span style="color:#ff9900;">依赖的类型</span> ，目前分为两类：</p><table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td>类型</td>            <td>命令</td>            <td>补充</td>        </tr><tr><td>生产依赖</td>            <td>            <p>npm i -S uniq</p>            <p>npm i --save uniq</p>            </td>            <td>            <p>S 等效于 --save， <span style="color:#ff9900;">-S 是默认选项</span></p>            <p>包信息保存在 package.json 中 <span style="color:#ff9900;">dependencies </span>属性</p>            </td>        </tr><tr><td>开发依赖</td>            <td>            <p>npm i -D less</p>            <p>npm i --save-dev less</p>            </td>            <td>            <p>-D 等效于 --save-dev</p>            <p>包信息保存在 package.json 中 <span style="color:#ff9900;">devDependencies </span>属性</p>            </td>        </tr></tbody></table><blockquote><p>举个例子方便大家理解，比如说做蛋炒饭需要 <span style="color:#ff9900;">大米 ， 油 ， 葱 ， 鸡蛋 ， 锅 ， 煤气 ， 铲子</span> 等</p><p>其中 <span style="color:#ff9900;">锅 ， 煤气 ， 铲子</span> 属于开发依赖，只在制作阶段使用</p><p>而 <span style="color:#ff9900;">大米 ， 油 ， 葱 ， 鸡蛋</span> 属于生产依赖，在制作与最终食用都会用到</p><p>所以 <span style="color:#ff9900;">开发依赖</span> 是只在开发阶段使用的依赖包，而 <span style="color:#ff9900;">生产依赖</span> 是开发阶段和最终上线运行阶段都用到 的依赖包</p></blockquote><h3>&nbsp;2.5 全局安装</h3><p>我们可以执行安装选项 -g 进行全局安装</p><pre><code class="language-javascript">npm i -g nodemon</code></pre><p>&nbsp;全局安装完成之后就可以在命令行的任何位置运行 nodemon 命令</p><p>该命令的作用是 <span style="color:#ff9900;">自动重启 node 应用程序</span></p><blockquote><p>说明：</p><ul><li>全局安装的命令不受工作目录位置影响</li>    <li>可以通过 <span style="color:#ff9900;">npm root -g</span> 可以查看全局安装包的位置</li>    <li><span style="color:#ff9900;">不是所有的包都适合全局安装</span> ， 只有全局类的工具才适合，可以通过 <span style="color:#ff9900;">查看包的官方文档来确定安装方式 </span>，这里先不必太纠结</li></ul></blockquote><h6>&nbsp;2.5.1 修改 windows 执行策略</h6><p>&nbsp;<img alt="" height="663" src="/medias/images/All/138.png" width="952"></p><p><img alt="" height="408" src="/medias/images/All/139.png" width="1002"></p><h6>2.5.2 环境变量 Path&nbsp;</h6><p>Path 是操作系统的一个环境变量，可以设置一些文件夹的路径，在当前工作目录下找不到可执行文件 时，就会在环境变量 Path 的目录中挨个的查找，如果找到则执行，如果没有找到就会报错</p><p><img alt="" height="462" src="/medias/images/All/140.png" width="969"></p><blockquote><p>&nbsp;补充说明：</p><ul><li>如果希望某个程序在任何工作目录下都能正常运行，就应该将该程序的所在目录配置到环境 变量 Path 中</li>    <li>windows 下查找命令的所在位置    <ul><li><span style="color:#ff9900;">cmd 命令行</span> 中执行 <span style="color:#ff9900;">where nodemon</span></li>        <li><span style="color:#ff9900;">powershell命令行</span> 执行 <span style="color:#ff9900;">get-command nodemon</span></li>    </ul></li></ul></blockquote><h3>&nbsp;2.6 安装包依赖</h3><p>在项目协作中有一个常用的命令就是 <span style="color:#ff9900;">npm i </span>，通过该命令可以依据 <span style="color:#ff9900;">package.json</span> 和 <span style="color:#ff9900;">packagelock.json</span> 的依赖声明安装项目依赖</p><pre><code class="language-javascript">npm inpm install</code></pre><blockquote><p>&nbsp;node_modules 文件夹大多数情况都不会存入版本库</p></blockquote><h3>&nbsp;2.7 安装指定版本的包</h3><p>项目中可能会遇到版本不匹配的情况，有时就需要安装指定版本的包，可以使用下面的命令的</p><pre><code class="language-javascript">## 格式npm i &lt;包名@版本号&gt;## 示例npm i jquery@1.11.2</code></pre><h3>&nbsp;2.8 删除依赖</h3><p>项目中可能需要删除某些不需要的包，可以使用下面的命令</p><pre><code class="language-javascript">## 局部删除npm remove uniqnpm r uniq## 全局删除npm remove -g nodemon</code></pre><h3>&nbsp;2.9 配置命令别名</h3><p>通过配置命令别名可以更简单的执行命令</p><p>配置 <span style="color:#ff9900;">package.json</span> 中的 <span style="color:#ff9900;">scripts </span>属性</p><pre><code class="language-javascript">{    "scripts": {        "server": "node server.js",        "start": "node index.js",    },}</code></pre><p>&nbsp;配置完成之后，可以使用别名执行命令</p><pre><code class="language-javascript">npm run servernpm run start</code></pre><p>&nbsp;不过 <span style="color:#ff9900;">start </span>别名比较特别，使用时可以省略 <span style="color:#ff9900;">run</span></p><pre><code class="language-javascript">npm start</code></pre><blockquote><p>&nbsp;补充说明：</p><ul><li><span style="color:#ff9900;">npm start</span> 是项目中常用的一个命令，一般用来启动项目</li>    <li><span style="color:#ff9900;">npm run</span> 有自动向上级目录查找的特性，跟 <span style="color:#ff9900;">require</span> 函数也一样</li>    <li>对于陌生的项目，我们可以通过查看 <span style="color:#ff9900;">scripts</span> 属性来参考项目的一些操作</li></ul></blockquote><h2>&nbsp;三、cnpm</h2><hr><h3>3.1 介绍</h3><p>cnpm 是一个淘宝构建的<span style="color:#ff9900;"> npmjs.com</span> 的完整镜像，也称为『淘宝镜像』，网址<span style="color:#1c7331;">https://npmmirror.com/</span></p><p>cnpm 服务部署在国内 <span style="color:#ff9900;">阿里云服务器上</span> ， 可以提高包的下载速度</p><p>官方也提供了一个全局工具包 <span style="color:#ff9900;">cnpm </span>，操作命令与 npm 大体相同</p><h3>3.2 安装</h3><p>我们可以通过 npm 来安装 cnpm 工具</p><pre><code class="language-javascript">npm install -g cnpm --registry=https://registry.npmmirror.com</code></pre><h3>&nbsp;3.3 操作命令</h3><table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td>功能</td>            <td>命令</td>        </tr><tr><td>初始化</td>            <td>cnpm init / cnpm init</td>        </tr><tr><td>安装包</td>            <td>            <p>cnpm i uniq</p>            <p>cnpm i -S uniq</p>            <p>cnpm i -D uniq</p>            <p>cnpm i -g nodemon</p>            </td>        </tr><tr><td>安装项目依赖</td>            <td>cnpm i</td>        </tr><tr><td>删除</td>            <td>cnpm r uniq</td>        </tr></tbody></table><h3>3.4 npm 配置淘宝镜像</h3><p>用 npm 也可以使用淘宝镜像，配置的方式有两种</p><ul><li>&nbsp; 直接配置</li>    <li>&nbsp; 工具配置</li></ul><h6>&nbsp;3.4.1 直接配置</h6><p>执行如下命令即可完成配置：</p><pre><code class="language-javascript">npm config set registry http://registry.npm.taobao.org/npm config set registry https://registry.npmmirror.com/</code></pre><h6>&nbsp;3.4.2 工具配置</h6><p>使用 <span style="color:#ff9900;">nrm </span>配置 npm 的镜像地址 <span style="color:#ff9900;">npm registry manager</span></p><p>1. 安装 nrm</p><pre><code class="language-javascript">npm i -g nrm</code></pre><p>&nbsp;2. 修改镜像</p><pre><code class="language-javascript">nrm use taobao</code></pre><p>&nbsp;3. 检查是否配置成功（选做）</p><pre><code class="language-javascript">npm config list</code></pre><p>检查 registry 地址是否为 https://registry.npmmirror.com/ , 如果 <span style="color:#ff9900;">是 </span>则表明成功</p><blockquote><p>&nbsp;补充说明：</p><ol><li><span style="color:#ff9900;">建议使用第二种方式</span> 进行镜像配置，因为后续修改起来会比较方便</li>    <li>虽然 cnpm 可以提高速度，但是 npm 也可以通过淘宝镜像进行加速，所以<span style="color:#ff9900;"> npm 的使用率还是高于 cnpm</span></li></ol></blockquote><h2>&nbsp;四、yarn</h2><hr><p>&nbsp;<img alt="" height="548" src="/medias/images/All/141.png" width="920"></p><h3>&nbsp;4.1 yarn 介绍</h3><p>&nbsp;yarn 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具，官方网址：https://yarnpkg.com/</p><h3>&nbsp;4.2 yarn 特点</h3><p>yarn 官方宣称的一些特点</p><blockquote><ul><li>速度超快：yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大 化资源利用率，因此安装速度更快</li>    <li>超级安全：在执行代码之前，yarn 会通过算法校验每个安装包的完整性</li>    <li>超级可靠：使用详细、简洁的锁文件格式和明确的安装算法，yarn 能够保证在不同系统上无差异的 工作</li></ul></blockquote><h3>&nbsp;4.3 yarn 安装</h3><p>&nbsp;我们可以使用 npm 安装 yarn</p><pre><code class="language-javascript">npm i -g yarn</code></pre><h3>&nbsp;4.4 yarn 常用命令</h3><table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td>功能</td>            <td>命令</td>        </tr><tr><td>初始化</td>            <td>yarn init / yarn init -y</td>        </tr><tr><td>安装包</td>            <td>            <p>yarn add uniq 生产依赖</p>            <p>yarn add less --dev 开发依赖</p>            <p>yarn global add nodemon 全局安装</p>            </td>        </tr><tr><td>删除包</td>            <td>            <p>yarn remove uniq 删除项目依赖包</p>            <p>yarn global remove nodemon 全局删除包</p>            </td>        </tr><tr><td>安装项目依赖</td>            <td>yarn</td>        </tr><tr><td>运行命令别名</td>            <td>yarn # 不需要添加 <span style="color:#ff9900;">run</span></td>        </tr></tbody></table><h3>4.5 yarn 配置淘宝镜像</h3><p>可以通过如下命令配置淘宝镜像</p><pre><code class="language-javascript">yarn config set registry http://registry.npm.taobao.org/yarn config set registry https://registry.npmmirror.com/</code></pre><p>&nbsp;可以通过<span style="color:#ff9900;"> yarn config list</span> 查看 yarn 的配置项</p><h3>4.6 npm 和 yarn 选择</h3><p>大家可以根据不同的场景进行选择</p><p>1. 个人项目</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是个人项目， <span style="color:#ff9900;">哪个工具都可以</span> ，可以根据自己的喜好来选择</p><p>2. 公司项目</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是公司要根据项目代码来选择，可以 <span style="color:#ff9900;">通过锁文件判断</span> 项目的包管理工具</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;npm 的锁文件为 <span style="color:#ff9900;">package-lock.json</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yarn 的锁文件为 <span style="color:#ff9900;">yarn.lock</span></p><blockquote><p>包管理工具 不要混着用，<span style="color:#ff9900;">切记，切记，切记</span></p></blockquote><h2>五、管理发布包</h2><hr><h3>5.1 创建与发布</h3><p>我们可以将自己开发的工具包发布到 npm 服务上，方便自己和其他开发者使用，操作步骤如下：</p><blockquote><p>1. 创建文件夹，并创建文件 index.js， 在文件中声明函数，使用 module.exports 暴露</p><p>2. npm 初始化工具包，package.json 填写包的信息 (包的名字是唯一的)</p><p>3. 注册账号 https://www.npmjs.com/signup</p><p>4. 激活账号 （ <span style="color:#ff9900;">一定要激活账号</span> ）</p><p>5. 修改为官方的官方镜像 (命令行中运行 <span style="color:#ff9900;">nrm use npm</span> )</p><p>6. 命令行下 <span style="color:#ff9900;">npm login</span> 填写相关用户信息</p><p>7. 命令行下 <span style="color:#ff9900;">npm publish</span> 提交包&nbsp;</p></blockquote><h3>&nbsp;5.2 更新包</h3><p>后续可以对自己发布的包进行更新，操作步骤如下</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 更新包中的代码</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 测试代码是否可用</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 修改 <span style="color:#ff9900;">package.json</span> 中的版本号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 发布更新&nbsp;<span style="color:#ff9900;">npm publish</span></p><h3>5.3 删除包</h3><p>执行如下命令删除包</p><pre><code class="language-javascript">npm unpublish --force</code></pre><blockquote><p>删除包需要满足一定的条件，https://docs.npmjs.com/policies/unpublish</p><ul><li>你是包的作者</li>    <li>发布小于 24 小时</li>    <li>大于 24 小时后，没有其他包依赖，并且每周小于 300 下载量，并且只有一个维护者</li></ul></blockquote><h2>&nbsp;六、扩展内容</h2><hr><p>在很多语言中都有包管理工具，比如：</p><table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td>语言</td>            <td>包管理工具</td>        </tr><tr><td>PHP</td>            <td>composer</td>        </tr><tr><td>Python</td>            <td>pip</td>        </tr><tr><td>Java</td>            <td>maven</td>        </tr><tr><td>Go</td>            <td>go mod</td>        </tr><tr><td>JavaScript</td>            <td>npm/yarn/cnpm/other</td>        </tr><tr><td>Ruby</td>            <td>rubyGems</td>        </tr></tbody></table><p>除了编程语言领域有包管理工具之外，操作系统层面也存在包管理工具，不过这个包指的是『 <span style="color:#ff9900;">软件包 </span>』</p><table border="1" cellpadding="1" cellspacing="1" style="width:650px;"><tbody><tr><td>操作系统</td>            <td>包管理工具</td>            <td>网址</td>        </tr><tr><td>Centos</td>            <td>yum</td>            <td><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://packages.debian.org/stable/" href="https://packages.debian.org/stable/" title="https://packages.debian.org/stable/">https://packages.debian.org/stable/</a></td>        </tr><tr><td>Ubuntu</td>            <td>apt</td>            <td><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://packages.ubuntu.com/" href="https://packages.ubuntu.com/" title="https://packages.ubuntu.com/">https://packages.ubuntu.com/</a></td>        </tr><tr><td>MacOS</td>            <td>homebrew</td>            <td><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://brew.sh/" href="https://brew.sh/" title="https://brew.sh/">https://brew.sh/</a></td>        </tr><tr><td>Windows</td>            <td>chocolatey</td>            <td><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://chocolatey.org/" href="https://chocolatey.org/" title="https://chocolatey.org/">https://chocolatey.org/</a></td>        </tr></tbody></table><p></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm install一直报错 failed, reason: certificate has expired</title>
      <link href="/2024/02/03/57-npm-install-yi-zhi-bao-cuo-failed-reason-certificate-has-expired/"/>
      <url>/2024/02/03/57-npm-install-yi-zhi-bao-cuo-failed-reason-certificate-has-expired/</url>
      
        <content type="html"><![CDATA[<p><img alt="" height="447" src="/medias/images/All/135.png" width="1200"></p><p>&nbsp;刚开始我以为是taobao镜像源的问题，所以我把npm的地址切换成了 https://resgistry.npmjs.org/ ，发现还是不行。</p><p>问题解决：</p><blockquote><p>npm config set strict-ssl false</p></blockquote><p>&nbsp;执行上面命令之后，npm install 成功</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 如何判断输入框的内容是正则表达式</title>
      <link href="/2024/02/03/56-javascript-ru-he-pan-duan-shu-ru-kuang-de-nei-rong-shi-zheng-ze-biao-da-shi-bu-shi-zheng-ze-biao-da-shi-de-hua-dan-chu-ti-shi/"/>
      <url>/2024/02/03/56-javascript-ru-he-pan-duan-shu-ru-kuang-de-nei-rong-shi-zheng-ze-biao-da-shi-bu-shi-zheng-ze-biao-da-shi-de-hua-dan-chu-ti-shi/</url>
      
        <content type="html"><![CDATA[<p>在 vue 中实现，ul 框架是elementui，this.content 是文本框的输入&nbsp;</p><pre><code class="language-javascript">    let isValidRegex = true;    try {        isValidRegex = eval(this.content) instanceof RegExp;    } catch (error) {        console.log('异常', error);        isValidRegex = false;    }    if (!isValidRegex) {        this.$message({            message: '请输入正确格式的正则表达式',            type: 'warning',            showClose: true        });        return false;    }</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ElementUI </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 如何修改仓库地址</title>
      <link href="/2024/02/02/55-git-ru-he-xiu-gai-cang-ku-di-zhi/"/>
      <url>/2024/02/02/55-git-ru-he-xiu-gai-cang-ku-di-zhi/</url>
      
        <content type="html"><![CDATA[<p>问题背景：组内更换大部门之后，代码仓的地址也迁移了，所以原来的git仓库地址失效了。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然重新建一个新的文件夹，再把每个项目都git clone一遍也可以。但是有点繁琐，而且有的项目本地还有已经开发一半的代码，这样就不方便了。所以介绍以下三种方法，任选一种就行：</p></blockquote><h3>方法一：删除本地仓库关联的无效远程地址，再添加新的远程仓库地址</h3><p>在项目目录下的终端执行如下命令：</p><pre><code class="language-javascript">git remote -v         // 查看当前项目对应的git远程仓库地址git remote rm origin  // 删除关联的远程仓库地址git remote -v         // 查看是否删除成功，如果没有任何返回结果，表示删除成功git remote add origin "新的代码仓git地址"    // 添加新的git远程仓库地址git remote -v         // 再次查看，控制台会输出上一步添加的git地址</code></pre><h3>&nbsp;方法二：直接修改本地仓库关联的git远程仓库地址</h3><p>在项目目录下的终端执行如下命令：</p><pre><code class="language-javascript">git remote                  // 查看远程仓库名称：origingit remote get-url origin   // 查看远程仓库地址git remote set-url origin "新的git远程仓库地址"</code></pre><p>在Git中，<span style="color:#fe2c24;">origin </span>是默认的远程仓库的名称。当您克隆了一个远程仓库时，Git会自动创建一个名为 <span style="color:#fe2c24;">origin </span>的远程仓库，并将其指向您克隆的远程仓库。</p><h3>方法三：通过开发工具修改（这里用vscode举例）</h3><p>通常vscode打开一个项目后，默认不会显示 .git 隐藏文件夹的。所以需要做一下配置修改。如下图</p><p style="text-align:center;"><img alt="" src="/medias/images/All/131.jpeg"></p><p><img alt="" height="293" src="/medias/images/All/132.png" width="1200"></p><p><img alt="" src="/medias/images/All/133.jpeg"></p><p>将 settings.json 中&nbsp;"**/.git" 项设置为 false，没有&nbsp;files.exclude 的话需要手动添加</p><pre><code class="language-javascript">{    "files.exclude": {        "**/.git": false,        "**/.svn": true,        "**/.hg": true,        "**/CVS": true,        "**/.DS_Store": true,        "**/Thumbs.db": true    }}</code></pre><p>&nbsp;设置为false之后，就会在项目的根目录显示 .git 文件夹，打开找到config文件，直接修改url就行<img alt="" height="375" src="/medias/images/All/134.png" width="884"></p><p></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm安装报错，出现.staging</title>
      <link href="/2024/02/02/54-npm-an-zhuang-bao-cuo-chu-xian.staging/"/>
      <url>/2024/02/02/54-npm-an-zhuang-bao-cuo-chu-xian.staging/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;问题场景：同事发了一个本地的安装包，拿到了没仔细看，直接npm install，没有发现根目录下的package-lock.json。然后就发现安装一直不成功，还会卡主。并且在node_modules文件夹下还会出现.staging文件夹，正常情况是不会出现这个的。</p><p><img alt="" height="975" src="/medias/images/All/130.png" width="1200"></p><p>解决：</p><p>是因为 <span style="color:#fe2c24;">根目录下有package-lock.json</span>&nbsp;&nbsp;导致的。删除&nbsp;package-lock.json 文件，重新npm install即可。</p><p>另外可以<span style="color:#0d0016;">使用</span><span style="color:#fe2c24;">&nbsp;npm cache clean -f</span>&nbsp; 清除缓存</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化：Vue项目打包后app.xxx.js 和 chunk-vendors.xxx.js 文件太大，导致页面加载时间太长</title>
      <link href="/2024/02/01/53-qian-duan-xing-neng-you-hua-vue-xiang-mu-da-bao-hou-app.xxx.js-he-chunk-vendors.xxx.js-wen-jian-tai-da-dao-zhi-ye-mian-jia-zai-shi-jian-tai-chang/"/>
      <url>/2024/02/01/53-qian-duan-xing-neng-you-hua-vue-xiang-mu-da-bao-hou-app.xxx.js-he-chunk-vendors.xxx.js-wen-jian-tai-da-dao-zhi-ye-mian-jia-zai-shi-jian-tai-chang/</url>
      
        <content type="html"><![CDATA[<p>问题场景，如下图，环境上的 app.js 和chunk-vendors.js 两个文件大小，高达3.4M 和 2M ，加载所耗费的时间也很长。</p><p><img alt="" height="479" src="/medias/images/All/126.png" width="1200"></p><p>下面说一下如何解决：</p><p>1、首先需要安装插件 compression-webpack-plugin，我这里用的是6.1.1的版本</p><pre><code class="language-javascript">npm i compression-webpack-plugin@6.1.1</code></pre><p>2、npm安装包成功后需要修改 vue.config.js 中的配置，这里只展示此次优化相关的部分</p><pre><code class="language-javascript">const CompressionWebpackPlugin = require("compression-webpack-plugin");chainWebpack: (config) =&gt; {    config.when(process.env.NODE_ENV === "development", (config) =&gt; {      config.devtool("source-map");    });    config.when(process.env.NODE_ENV === "production", (config) =&gt; {      config.performance.set("hints", false);      config.devtool("none");      config.plugin("compression").use(CompressionWebpackPlugin, [        {          filename: "[path][base].gz[query]",          algorithm: "gzip",          test: /\.(js|css)$/,          threshold: 8192,          minRatio: 0.8,          deleteOriginalAssets: false,        },      ]);    });  },</code></pre><p>3、 修改后，先本地 npm run build 打包，打包成功后，看下包里的js文件中是否包含 .gz 结尾的文件，如果包含就可以把包部署到相关环境上</p><p><img alt="" height="298" src="/medias/images/All/127.png" width="1116"></p><p>4、（最重要）需要修改nginx的配置文件，nginx.conf&nbsp;&nbsp;在http{}里打开gzip开关，并添加配置</p><pre><code class="language-javascript">http {    #开启gzip压缩    gzip on;    #设置gzip压缩级别，2级是性价比最高的    gzip_comp_level 2;    #设置动态gzip压缩的文件类型    gzip_types text/plain text/css text/javascript application/javascript;    #http的协议版本    gzip_http_version 1.0;    #IE版本1-6不支持gzip压缩，关闭    gzip_disable 'MSIE[1-6].';}</code></pre><p>5、修改nginx配置之后，需要重启nginx生效，然后去页面清空浏览器环缓存后查看，app.js 和chunk-vendors.js 两个文件变成了 884kB 和642 kB，大小和加载时间都有明显的下降</p><p><img alt="" height="174" src="/medias/images/All/128.png" width="1200"></p><p><img alt="" height="507" src="/medias/images/All/129.png" width="1045"></p><p></p><p></p><p>&nbsp;如果帮助到你了，希望留下一个赞👍吧，那是我继续前进的动力</p><p></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 前框框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决页面水印导致子节点鼠标事件失效的问题</title>
      <link href="/2024/02/01/52-pointer-events-none-jie-jue-ye-mian-shui-yin-dao-zhi-zi-jie-dian-shu-biao-shi-jian-shi-xiao-de-wen-ti/"/>
      <url>/2024/02/01/52-pointer-events-none-jie-jue-ye-mian-shui-yin-dao-zhi-zi-jie-dian-shu-biao-shi-jian-shi-xiao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>背景：实现水印功能之后，由于水印是一个遮罩层，导致z-index元素比较低的子元素，鼠标移入事件、点击事件都失效了。</p><p>解决方案：给添加水印样式的元素，添加css样式：pointer-events: none;。子元素添加css样式：pointer-events: auto;之后，问题解决。</p><pre><code class="language-html">#display {    pointer-events: none;}</code></pre><p><img alt="" height="123" src="/medias/images/All/125.png" width="415"></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出JavaScript中的Object.assign()方法</title>
      <link href="/2024/02/01/51-shen-ru-qian-chu-javascript-zhong-de-object.assign-fang-fa/"/>
      <url>/2024/02/01/51-shen-ru-qian-chu-javascript-zhong-de-object.assign-fang-fa/</url>
      
        <content type="html"><![CDATA[<h3>Object.assign()介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.assign()方法用于将一个或多个源对象的可枚举属性复制到目标对象中，并返回目标对象。它基于浅复制原则，只复制对象自身的属性，不复制继承自原型链上的属性。如果目标对象已经存在相同属性，则源对象的属性将覆盖目标对象的属性。</p><h3>语法</h3><blockquote><p><strong>Object.assign(target, ...sources)</strong></p><ul><li><span style="color:#a5a5a5;">`target`：目标对象，要将属性复制到的对象。</span></li></ul><ul><li><span style="color:#a5a5a5;">`sources`：一个或多个源对象，从中复制属性的对象。</span></li></ul></blockquote><h3>情况一：如果后面对象的属性，比如source中存在属性b，而目标对象（第一个参数）中也存在属性b，则source里的属性b值，会覆盖前面的属性b值</h3><blockquote><p>// 复制对象，存在相同key，则后面覆盖前面的<br>const target = { a: 1, b: 2 };<br>const source = { b: 4, c: 5 };<br>const result = Object.assign(target, source);<br>console.log(result); // { a: 1, b: 4, c: 5 }</p></blockquote><h3>情况二：Object.assign() 会改变第一个对象的值，后面对象的值不会改变</h3><blockquote><p>// 会改变第一个对象的值，后面的对象值不会变，遇到相同key，后面的值会覆盖前面的<br>const target1 = { a: 1, b: 2 };<br>const source1 = { b: 4, c: 5, d: 6};<br>Object.assign(target1, source1);<br>console.log(target1); // { a: 1, b: 4, c: 5, d: 6 }<br>console.log(source1); // { b: 4, c: 5, d: 6 }</p></blockquote><h3>情况三：如果想合并几个对象生成新的对象，并对原来的对象内容无影响，可以将Object.assign()的第一个参数设为空对象</h3><blockquote><p>// 合并对象<br>const obj1 = { a: 1, b: 2 };<br>const obj2 = { b: 4, c: 5 };<br>const obj3 = { d: 6 };<br>const merged = Object.assign({}, obj1, obj2, obj3);<br>console.log(merged); // { a: 1, b: 4, c: 5, d: 6 }</p></blockquote><h3>所有代码：</h3><pre><code class="language-javascript">// 复制对象const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const result = Object.assign(target, source);console.log(result); // { a: 1, b: 4, c: 5 }// 会改变第一个对象的值，后面的对象值不会变，遇到相同key，后面的值会覆盖前面的const target1 = { a: 1, b: 2 };const source1 = { b: 4, c: 5, d: 6};Object.assign(target1, source1);console.log(target1); // { a: 1, b: 4, c: 5, d: 6 }console.log(source1); // { b: 4, c: 5, d: 6 }// 合并对象const obj1 = { a: 1, b: 2 };const obj2 = { b: 4, c: 5 };const obj3 = { d: 6 };const merged = Object.assign({}, obj1, obj2, obj3);console.log(merged); // { a: 1, b: 4, c: 5, d: 6 }</code></pre><h3>&nbsp;注意事项</h3><blockquote><ul><li>Object.assign()方法不会拷贝对象的不可枚举属性、原型链属性以及方法。</li></ul><ul><li>当源对象含有getter时，会触发getter的执行。</li>    <li>    <p>Object.assign()是浅复制，所以在处理嵌套对象时需要小心。</p>    </li></ul></blockquote><p>&nbsp;Object.assign()方法是一个非常有用的工具，可以用于对象属性的复制和合并。它可以帮助我们轻松地操作对象，处理属性赋值和合并等任务。</p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-input 显示最大长度和已输入内容长度</title>
      <link href="/2024/01/30/50-el-input-xian-shi-zui-da-chang-du-he-yi-shu-ru-nei-rong-chang-du/"/>
      <url>/2024/01/30/50-el-input-xian-shi-zui-da-chang-du-he-yi-shu-ru-nei-rong-chang-du/</url>
      
        <content type="html"><![CDATA[<p>效果如下图</p><p>多行文本框：</p><p><img alt="" height="277" src="/medias/images/All/123.png" width="748"></p><p>单行文本框：</p><p><img alt="" height="140" src="/medias/images/All/124.png" width="484"></p><p>&nbsp;需要设置&nbsp;<code>maxlength</code>&nbsp; 和 &nbsp;<code>show-word-limit</code>&nbsp;两个属性，在使用&nbsp;<code>maxlength</code>&nbsp;属性限制最大输入长度的同时，可通过设置&nbsp;<code>show-word-limit</code>&nbsp;属性来展示字数统计。</p><pre><code class="language-javascript">&lt;el-input    type="textarea"    :show-word-limit="true"    :maxlength="500"    v-model="ruleForm.wangsiUrl"    placeholder="请输入内容"    size="small"    clearable&gt;&lt;/el-input&gt;</code></pre><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-select选择之后值不显示在文本框的问题解决</title>
      <link href="/2024/01/30/49-el-select-xuan-ze-zhi-hou-zhi-bu-xian-shi-zai-wen-ben-kuang-de-wen-ti-jie-jue/"/>
      <url>/2024/01/30/49-el-select-xuan-ze-zhi-hou-zhi-bu-xian-shi-zai-wen-ben-kuang-de-wen-ti-jie-jue/</url>
      
        <content type="html"><![CDATA[<p>问题场景如下图：</p><p>在el-collapse-item中使用子组件，子组件里是el-form-item代码。el-select在for循环中，可以有多个。</p><p><img alt="" height="160" src="/medias/images/All/120.gif" width="596"></p><p>查了一下博客，有的说这种场景需要给el-select添加@change事件，加上 this.$forceUpdate()&nbsp;强制刷新即可</p><pre><code class="language-javascript">Change(){    this.$forceUpdate(); }</code></pre><p>也有说使用this.$set去设置，但都不适用我的场景，试了没效果。</p><p>根因分析：padding 值太大了，导致文本被挤掉隐藏了。<img alt="" height="700" src="/medias/images/All/121.png" width="713"></p><p>处理：将el-input__inner的padding设置小点之后，问题修复。</p><p><img alt="" height="122" src="/medias/images/All/122.png" width="298"></p><pre><code class="language-javascript">.filePartCom{  .el-select .el-input__inner{    padding-right: 15px !important;  }}</code></pre><p><img alt="" height="158" src="/medias/images/All/123.gif" width="628"></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElementUI </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs -- 模块化</title>
      <link href="/2024/01/30/48-node.js-mo-kuai-hua/"/>
      <url>/2024/01/30/48-node.js-mo-kuai-hua/</url>
      
        <content type="html"><![CDATA[<h2>一、介绍</h2><h3>1.1 什么是模块化与模块 ?</h3><p>将一个复杂的程序文件依据一定规则（规范）拆分成多个文件的过程称之为 <span style="color:#ff9900;">模块化</span></p><p>其中拆分出的 <span style="color:#ff9900;">每个文件就是一个模块</span> ，模块的内部数据是私有的，不过模块可以暴露内部数据以便其他 模块使用</p><h3>1.2 什么是模块化项目 ?</h3><p>编码时是按照模块一个一个编码的， 整个项目就是一个模块化的项目</p><h3>1.3 模块化好处</h3><blockquote><ol><li>防止命名冲突</li>    <li>高复用性</li>    <li>高维护性</li></ol></blockquote><h2>&nbsp;二、模块暴露数据</h2><h3>&nbsp;2.1 模块初体验</h3><p>可以通过下面的操作步骤，快速体验模块化</p><p>1. 创建 <span style="color:#ff9900;">me.js</span></p><pre><code class="language-javascript">//声明函数function tiemo(){    console.log('贴膜....');}//暴露数据module.exports = tiemo;</code></pre><p>&nbsp;2. 创建 <span style="color:#ff9900;">index.js</span></p><pre><code class="language-javascript">//导入模块const tiemo = require('./me.js');//调用函数tiemo();</code></pre><h3>&nbsp;2.2 暴露数据</h3><p>模块暴露数据的方式有两种：</p><ol><li>module.exports = value</li>    <li>exports.name = value</li></ol><blockquote><p>&nbsp;使用时有几点注意：</p><ul><li>&nbsp;module.exports 可以暴露 <span style="color:#ff9900;">任意</span> 数据</li>    <li>&nbsp;不能使用 <span style="color:#ff9900;">exports = value</span> 的形式暴露数据，模块内部 module 与 exports 的隐式关系 <span style="color:#ff9900;">exports = module.exports = {} </span>，require 返回的是目标模块中 <span style="color:#ff9900;">module.exports</span> 的值</li></ul></blockquote><p>&nbsp;<img alt="" height="272" src="/medias/images/All/118.png" width="784"></p><h2>&nbsp;三、导入（引入）模块</h2><p>在模块中使用 require 传入文件路径即可引入文件</p><pre><code class="language-javascript">const test = require('./me.js');</code></pre><p>&nbsp;require 使用的一些注意事项：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 对于自己创建的模块，导入时路径建议写 <span style="color:#ff9900;">相对路径</span> ，且不能省略 <span style="color:#ff9900;">./</span> 和 <span style="color:#ff9900;">../</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. <span style="color:#ff9900;">js </span>和 <span style="color:#ff9900;">json </span>文件导入时可以不用写后缀，c/c++编写的 <span style="color:#ff9900;">node </span>扩展文件也可以不写后缀，但是一 般用不到</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 如果导入其他类型的文件，会以 <span style="color:#ff9900;">js </span>文件进行处理</p><p>&nbsp; &nbsp; &nbsp;&nbsp;4. 如果导入的路径是个文件夹，则会 <span style="color:#ff9900;">首先 </span>检测该文件夹下<span style="color:#ff9900;"> package.json</span> 文件中 <span style="color:#ff9900;">main </span>属性对应 的文件，如果存在则导入，反之如果文件不存在会报错。</p><p>如果 main 属性不存在，或者 package.json 不存在，则会尝试导入文件夹下的 <span style="color:#ff9900;">index.js</span> 和 <span style="color:#ff9900;">index.json</span> ，如果还是没找到，就会报错</p><p>&nbsp; &nbsp; &nbsp; 5. 导入 node.js 内置模块时，直接 require 模块的名字即可，无需加 <span style="color:#ff9900;">./ </span>和 <span style="color:#ff9900;">../</span></p><h2>四、导入模块的基本流程</h2><p>&nbsp;这里我们介绍一下 <span style="color:#ff9900;">require </span>导入 <span style="color:#ff9900;">自定义模块</span> 的基本流程</p><p>&nbsp;1. 将相对路径转为绝对路径，定位目标文件</p><p>&nbsp;2. 缓存检测</p><p>&nbsp;3. 读取目标文件代码</p><p>&nbsp;4. 包裹为一个函数并执行（自执行函数）。通过 <span style="color:#ff9900;">arguments.callee.toString() </span>查看自执行函数</p><p>&nbsp;5. 缓存模块的值</p><p>&nbsp;6. 返回 <span style="color:#ff9900;">module.exports</span> 的值</p><p><img alt="" height="782" src="/medias/images/All/119.png" width="548"></p><h2>&nbsp;五、CommonJS 规范</h2><p>&nbsp;<span style="color:#ff9900;">module.exports</span> 、 exports 以及 <span style="color:#ff9900;">require </span>这些都是 <span style="color:#ff9900;">CommonJS </span>模块化规范中的内容。 而 Node.js 是实现了 CommonJS 模块化规范，二者关系有点像 JavaScript 与 ECMAScrip</p><p></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs -- http模块</title>
      <link href="/2024/01/26/47-nodejs-http-xie-yi/"/>
      <url>/2024/01/26/47-nodejs-http-xie-yi/</url>
      
        <content type="html"><![CDATA[<h3>一、概念</h3><p>HTTP（hypertext transport protocol）协议；中文叫<strong>超文本传输协议</strong></p><p>是一种基于TCP/IP的应用层通信协议</p><p>这个协议详细规定了 <span style="color:#ff9900;">浏览器</span> 和万维网 <span style="color:#ff9900;">服务器</span> 之间互相通信的规则。</p><p>协议中主要规定了两个方面的内容：</p><blockquote><ul><li>客户端：用来向服务器发送数据，可以被称之为<strong>请求报文</strong></li>    <li>服务端：向客户端返回数据，可以被称之为<strong>响应报文</strong></li></ul></blockquote><p>报文：可以简单理解为就是一堆字符串</p><h3>&nbsp;二、请求报文的组成</h3><blockquote><ul><li>请求行</li>    <li>请求头</li>    <li>空行</li>    <li>请求体</li></ul></blockquote><p>&nbsp;示例图：<img alt="" height="1015" src="/medias/images/All/112.png" width="1200"></p><h3>&nbsp;三、HTTP 的请求行</h3><blockquote><ul><li>&nbsp;请求方法（get、post、put、delete等）</li>    <li>&nbsp;请求 URL（统一资源定位器）http://www.baidu.com:80/index.htmla=100&amp;b=200#logo</li></ul><p>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; http：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 协议（https、ftp、ssh等）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;www.baidu.com&nbsp; &nbsp; 域名</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;80&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;端口号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/index.html&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 路径</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=100&amp;b=200&nbsp; &nbsp; &nbsp; &nbsp;查询字符串</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#logo&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;哈希（锚点链接）</p><ul><li>HTTP协议版本号</li></ul></blockquote><h3>&nbsp;四、HTTP 请求头</h3><p>格式：『头名：头值』</p><p>常见的请求头有：</p><p><img alt="" height="673" src="/medias/images/All/113.png" width="941"></p><h3>&nbsp;五、HTTP 的请求体</h3><p>请求体内容的格式是非常灵活的，</p><p>（可以是空）==&gt; GET请求，</p><p>（也可以是字符串，还可以是JSON）===&gt; POST请求</p><p>例如：</p><ul><li>字符串：keywords=手机&amp;price=2000</li>    <li>JSON：{"keywords":"手机","price":2000}</li></ul><h3>&nbsp;六、响应报文的组成</h3><ul><li>响应行</li></ul><blockquote><p>HTTP/1.1 200 OK&nbsp;</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP/1.1：HTTP协议版本号</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;200：响应状态码 404 Not Found 500 Internal Server Error</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 还有一些状态码，参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK：响应状态描述</p><blockquote><p>响应状态码和响应字符串关系是一一对应的。</p></blockquote><ul><li>&nbsp;响应头</li></ul><blockquote><p>&nbsp;Cache-Control:缓存控制 private 私有的，只允许客户端缓存数据</p><p>&nbsp;Connection 链接设置</p><p>&nbsp;Content-Type:text/html;charset=utf-8 设置响应体的数据类型以及字符集,响应体为html，字&nbsp; &nbsp; &nbsp; &nbsp; 符集 utf-8</p><p>&nbsp;Content-Length:响应体的长度，单位为字节</p></blockquote><ul><li>&nbsp;空行</li>    <li>&nbsp;响应体</li></ul><p>响应体内容的类型是非常灵活的，常见的类型有 HTML、CSS、JS、图片、JSON</p><h3>七、获取HTTP请求报文</h3><p>想要获取请求的数据，需要通过 <span style="color:#ff9900;">request </span>对象</p><p><img alt="" height="470" src="/medias/images/All/114.png" width="941"></p><blockquote><p>&nbsp;注意事项：</p><p>1. request.url 只能获取路径以及查询字符串，无法获取 URL 中的域名以及协议的内容</p><p>2. request.headers 将请求信息转化成一个对象，并将属性名都转化成了『小写』</p><p>3. 路径：如果访问网站的时候，只填写了 IP 地址或者是域名信息，此时请求的路径为『 / 』</p><p>4. 关于 favicon.ico：这个请求是属于浏览器自动发送的请求</p></blockquote><h3>&nbsp;八、设置HTTP响应报文</h3><p><img alt="" height="324" src="/medias/images/All/115.png" width="920"></p><pre><code class="language-javascript">write 和 end 的两种使用情况：//1. write 和 end 的结合使用 响应体相对分散response.write('xx');response.write('xx');response.write('xx');response.end(); //每一个请求，在处理的时候必须要执行 end 方法的//2. 单独使用 end 方法 响应体相对集中response.end('xxx');</code></pre><h3>&nbsp;九、静态资源服务</h3><p>静态资源是指 <span style="color:#ff9900;">内容长时间不发生改变的资源 </span>，例如图片，视频，CSS 文件，JS文件，HTML文件，字体文 件等</p><p>动态资源是指 <span style="color:#ff9900;">内容经常更新的资源</span> ，例如百度首页，网易首页，京东搜索列表页面等</p><h4>9.1 网站根目录或静态资源目录</h4><p>HTTP 服务在哪个文件夹中寻找静态资源，那个文件夹就是 静态资源目录 ，也称之为 网站根目录</p><h4>9.2&nbsp;网页中的 URL</h4><p>网页中的 URL 主要分为两大类：相对路径与绝对路径</p><h5>9.2.1 绝对路径</h5><p>绝对路径可靠性强，而且相对容易理解，在项目中运用较多</p><p><img alt="" height="286" src="/medias/images/All/116.png" width="912"></p><h5>9.2.2 相对路径</h5><p><img alt="" height="428" src="/medias/images/All/117.png" width="945"></p><h5>9.2.3&nbsp;&nbsp;网页中使用 URL 的场景小结</h5><p>&nbsp;包括但不限于如下场景：</p><blockquote><ul><li>a 标签 href</li>    <li>link 标签 href</li>    <li>script 标签 src</li>    <li>img 标签 src</li>    <li>video audio 标签 src</li>    <li>form 中的 action</li>    <li>AJAX 请求中的 URL</li></ul></blockquote><h4>9.3 设置资源类型（mime类型）</h4><p>媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、 文件或字节流的性质和格式。</p><blockquote><p>mime 类型结构： [type]/[subType]&nbsp; &nbsp;例如： text/html text/css image/jpeg image/png application/json</p></blockquote><p>&nbsp;HTTP 服务可以设置响应头 Content-Type 来表明响应体的 MIME 类型，浏览器会根据该类型决定如何处理 资源</p><p>下面是常见文件对应的 mime 类型：</p><pre><code class="language-javascript">html: 'text/html',css: 'text/css',js: 'text/javascript',png: 'image/png',jpg: 'image/jpeg',gif: 'image/gif',mp4: 'video/mp4',mp3: 'audio/mpeg',json: 'application/json'</code></pre><blockquote><p>对于未知的资源类型，可以选择 <span style="color:#ff9900;">application/octet-stream</span> 类型，浏览器在遇到该类型的响应 时，会对响应体内容进行独立存储，也就是我们常见的 <span style="color:#ff9900;">下载</span> 效果&nbsp;</p></blockquote><pre><code class="language-javascript">require('http').createServer((request,response)=&gt;{    //获取请求的方法已经路径    let {url,method} = request;    //文件夹路径    let rootDir = __dirname + '/public';    //拼接文件路径    let filePath = rootDir + url;    //读取文件内容    fs.readFile(filePath,(err,data)=&gt;{        //判断        if(err){            //如果出现错误，响应404状态码            response.statusCode = 404;            response.end('&lt;h1&gt;404 Not Found&lt;/h1&gt;');        }else{            //响应文件内容            response.end(data);        }    })}).listen(80,()=&gt;{    console.log('80端口正在启动中....');})</code></pre><h4>&nbsp;9.4 GET 和 POST 请求场景小结</h4><p>GET 请求的情况：</p><blockquote><ul><li>在地址栏直接输入 url 访问</li>    <li>点击 a 链接</li>    <li>link 标签引入 css</li>    <li>script 标签引入 js</li>    <li>img 标签引入图片</li>    <li>form 标签中的 method 为 get （不区分大小写）</li>    <li>ajax 中的 get 请求</li></ul></blockquote><p>POST 请求的情况：</p><blockquote><ul><li>&nbsp;form 标签中的 method 为 post（不区分大小写）</li>    <li>AJAX 的 post 请求</li></ul></blockquote><p>GET和POST请求的区别：</p><p>GET 和 POST 是 HTTP 协议请求的两种方式。</p><blockquote><ul><li>GET 主要用来获取数据，POST 主要用来提交数据</li>    <li>GET 带参数请求是将参数缀到 URL 之后，在地址栏中输入 url 访问网站就是 GET 请求， POST 带参数请求是将参数放到请求体中</li>    <li>POST 请求相对 GET 安全一些，因为在浏览器中参数会暴露在地址栏</li>    <li>GET 请求大小有限制，一般为 2K，而 POST 请求则没有大小限制</li></ul></blockquote><p></p><p></p><p></p><p></p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs -- path 模块</title>
      <link href="/2024/01/26/46-nodejs-path-mo-kuai/"/>
      <url>/2024/01/26/46-nodejs-path-mo-kuai/</url>
      
        <content type="html"><![CDATA[<p>path 模块提供了<span style="color:#ff9900;"> 操作路径</span> 的功能，我们将介绍如下几个较为常用的几个 API：</p><table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td>API</td>            <td>说明</td>        </tr><tr><td>path.resolve</td>            <td>拼接规范的绝对路径 <span style="color:#ff9900;">常用</span></td>        </tr><tr><td>path.sep</td>            <td>获取操作系统的路径分隔符</td>        </tr><tr><td>path.parse</td>            <td>解析路径并返回对象</td>        </tr><tr><td>path.basename</td>            <td>获取路径的基础名称</td>        </tr><tr><td>path.dirname</td>            <td>获取路径的目录名</td>        </tr><tr><td>path.extname</td>            <td>获取路径的扩展名</td>        </tr></tbody></table><p>代码示例：</p><pre><code class="language-javascript">//导入 fsconst fs = require('fs');const path = require('path');//写入文件fs.writeFileSync(__dirname + '/index.html', 'love');console.log(__dirname + '/index.html'); // d:\Learning\nodejs\代码\03_path模块\代码/index.html//resolve  解决console.log(path.resolve(__dirname, './index.html')); // d:\Learning\nodejs\代码\03_path模块\代码\index.htmlconsole.log(path.resolve(__dirname, 'index.html')); // d:\Learning\nodejs\代码\03_path模块\代码\index.htmlconsole.log(path.resolve(__dirname, '/index.html', './test')); // d:\index.html\test// sep 分隔符console.log(path.sep); // windows  \   Linux  /// parse 方法  __dirname  '全局变量'console.log(__filename); // 文件的绝对路径 d:\Learning\nodejs\代码\03_path模块\代码\path.jslet str = 'D:\\nodeJS\\13-path\\代码\\path.js';console.log(path.parse(str));//   {//     root: 'D:\\',//     dir: 'D:\\nodeJS\\13-path\\代码',//     base: 'path.js',//     ext: '.js',//     name: 'path'//   }// basenameconsole.log(path.basename(str)); // path.js// dirnameconsole.log(path.dirname(str)); // D:\nodeJS\13-path\代码// extnameconsole.log(path.extname(str)); // .js</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs -- fs 模块</title>
      <link href="/2024/01/24/45-nodejs-fs-mo-kuai/"/>
      <url>/2024/01/24/45-nodejs-fs-mo-kuai/</url>
      
        <content type="html"><![CDATA[<blockquote><div><span style="color:#34495e;">fs </span><span style="color:#34495e;">全称为 </span><span style="color:#e96900;">file system </span><span style="color:#34495e;">，称之为 </span><span style="color:#e96900;">文件系统 </span><span style="color:#34495e;">，是 </span><span style="color:#34495e;">Node.js </span><span style="color:#34495e;">中的 </span><span style="color:#e96900;">内置模块 </span><span style="color:#34495e;">，可以对计算机中的磁盘进行操作。 </span></div></blockquote><p><img alt="" height="321" src="/medias/images/All/110.png" width="866"></p><blockquote><p><span style="color:#34495e;">本章节会介绍如下几个操作：</span></p><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 文件写入 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 文件读取 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 文件移动与重命名 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 文件删除 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 文件夹操作 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 查看资源状态 </span></div></blockquote><p>&nbsp;<span style="color:#34495e;">文件写入就是将 </span><span style="color:#e96900;">数据 </span><span style="color:#34495e;">保存到 </span><span style="color:#e96900;">文件 </span><span style="color:#34495e;">中，我们可以使用如下几个方法来实现该效果</span></p><p><img alt="" height="348" src="/medias/images/All/111.png" width="1162"></p><h3>1、writeFile 异步写入</h3><p>语法：<span style="color:#e96900;">fs.writeFile(file, data[, options], callback) </span></p><div><span style="color:#34495e;">参数说明：</span></div><div><ul><li><span style="color:#34495e;">file </span><span style="color:#34495e;">文件名 </span></li>    <li><span style="color:#34495e;">data </span><span style="color:#34495e;">待写入的数据 </span></li>    <li><span style="color:#34495e;">options </span><span style="color:#34495e;">选项设置 </span><span style="color:#e96900;">（可选） </span></li>    <li><span style="color:#34495e;">callback </span><span style="color:#34495e;">写入回调 </span></li></ul></div><div><span style="color:#34495e;">返回值： </span><span style="color:#e96900;">undefined </span></div><div></div><div><div><span style="color:#34495e;">代码示例：</span></div><div></div><div><pre><code class="language-javascript">/** * 需求: * 新建一个文件, 座右铭.txt,  写入内容, 三人行, 则必有我师焉 */<p>//1. 导入 fs 模块<br>const fs = require(‘fs’);</p><p>//2. 写入文件<br>fs.writeFile(‘./座右铭.txt’, ‘三人行, 则必有我师焉’, err =&gt; {<br>  // err 写入失败: 错误对象  写入成功: null<br>  if(err){<br>    console.log(‘写入失败’);<br>    return;<br>  }<br>  console.log(‘写入成功’);<br>});</p><p>console.log(1 + 1);</p><p>//同步写入<br>fs.writeFileSync(‘./data.txt’, ‘test’);</p></code><p><code class="language-javascript">console.log(1 + 1);</code></p></pre><p></p><h3>2、appendFile追加写入</h3></div></div><pre><code class="language-javascript">//1. 引入 fs 模块const fs = require('fs');// 2. 调用 appendFilefs.appendFile('./座右铭.txt', ',择其善者而从之, 择期不善者而改之', err =&gt; {  //判断  if(err){    console.log('写入失败~~');    return;  }  console.log('追加写入成功');});fs.appendFileSync('./座右铭.txt', '\r\n温故而知新, 可以为师矣')//writeFile 实现追加写入fs.writeFile('./座右铭.txt', 'love love love',{flag: 'a'}, err =&gt; {  if(err) {    console.log('写入失败~');    return ;  }  console.log('写入成功');});</code></pre><h3>3、流式写入</h3><pre><code class="language-javascript">/** * 观书有感.txt *///1. 导入 fs const fs = require('fs');//2. 创建写入流对象 const ws = fs.createWriteStream('./观书有感.txt');//3. writews.write('半亩方塘一鉴开\r\n');ws.write('天光云影共徘徊\r\n');ws.write('问渠那得清如许\r\n');ws.write('为有源头活水来\r\n');//4. 关闭通道// ws.close();</code></pre><h3>4、文件读取</h3><pre><code class="language-javascript">//1. 引入 fs 模块const fs = require('fs');//2. 异步读取fs.readFile('./观书有感.txt', (err, data) =&gt; {  if(err) {    console.log('读取失败~~');    return;  }  console.log(data.toString());});//3. 同步读取let data = fs.readFileSync('./观书有感.txt');console.log(data.toString());</code></pre><h3>5、流式读取</h3><pre><code class="language-javascript">//1. 引入 fs 模块const fs = require('fs');//2. 创建读取流对象const rs = fs.createReadStream('../资料/笑看风云.mp4');//3. 绑定 data 事件   chunk 块儿  大块儿rs.on('data', chunk =&gt; {  console.log(chunk.length); // 65536 字节 =&gt; 64KB  // console.log(chunk.toString()); // 65536 字节 =&gt; 64KB});//4. end  可选事件rs.on('end', () =&gt; {  console.log('读取完成');});</code></pre><h3>6、练习-文件复制</h3><pre><code class="language-javascript">/** * 需求: *   复制『资料』文件夹下的『笑看风云.mp4』 */const fs = require('fs');const process = require('process');//方式一 readFile//读取文件内容// let data = fs.readFileSync('../资料/笑看风云.mp4');// //写入文件// fs.writeFileSync('../资料/笑看风云-2.mp4', data);// console.log(process.memoryUsage()); // rss    110710784 字节   105MB//方式二 流式操作//创建读取流对象const rs = fs.createReadStream('../资料/笑看风云.mp4');//创建写入流对象const ws = fs.createWriteStream('../资料/笑看风云-3.mp4');//绑定 data 事件// rs.on('data', chunk =&gt; {//   ws.write(chunk);// });// rs.on('end', () =&gt; {//   console.log(process.memoryUsage());  // 43106304   =&gt;  41M// })rs.pipe(ws);</code></pre><h3>&nbsp;7、文件重命名与移动</h3><pre><code class="language-javascript">//1. 导入 fs 模块const fs = require('fs');//2. 调用 rename 方法fs.rename('./座右铭.txt', './论语.txt', err =&gt; {  if(err) {    console.log('操作失败~');    return;  }  console.log('操作成功');});//文件的移动fs.rename('./data.txt', '../资料/data.txt', err =&gt; {  if(err) {    console.log('操作失败~');    return;  }  console.log('操作成功');})</code></pre><h3>8、删除文件</h3><pre><code class="language-javascript">//1. 导入 fs 模块const fs = require('fs');//2. 调用 unlink 方法    unlinkSyncfs.unlink('./观书有感.txt', err =&gt; {  if(err) {    console.log('删除失败~');    return;  }  console.log('删除成功');});// 调用 rm 方法  14.4   rmSyncfs.rm('./论语.txt', err =&gt; {  if (err) {    console.log('删除失败~');    return;  }  console.log('删除成功');})</code></pre><h3>9、文件夹操作</h3><pre><code class="language-javascript">//1. 导入 fs 模块const fs = require('fs');//2. 创建文件夹  mk  make 制作  dir directory 文件夹fs.mkdir('./html', err =&gt; {  if(err) {    console.log('创建失败~');    return;  }  console.log('创建成功');});//2-2 递归创建fs.mkdir('./a/b/c', {recursive: true},err =&gt; {  if(err) {    console.log('创建失败~');    return;  }  console.log('创建成功');});//2-3 读取文件夹   read 读取  dir  directory 文件夹fs.readdir('../资料', (err, data) =&gt; {  if(err){    console.log('读取失败');    return;  }  console.log(data);});fs.readdir('./', (err, data) =&gt; {  if(err){    console.log('读取失败');    return;  }  console.log(data);});//2-4 删除文件夹  rm  remove 移除fs.rmdir('./html', err =&gt; {  if(err){    console.log('删除失败');    return;  }  console.log('删除成功');});//递归删除    不推荐使用fs.rmdir('./a', {recursive: true},err =&gt; {  if(err){    console.log(err);    return;  }  console.log('删除成功');});//建议使用fs.rm('./a', {recursive: true},err =&gt; {  if(err){    console.log(err);    return;  }  console.log('删除成功');});</code></pre><h3>&nbsp;10、查看资源信息</h3><pre><code class="language-javascript">//1. 导入 fs 模块const fs = require('fs');//2. stat 方法  status 缩写 状态fs.stat('../资料/笑看风云.mp4', (err, data) =&gt; {  if(err){    console.log('操作失败');    return;  }  // console.log(data);  // isFile   console.log(data.isFile());  // isDirectory  console.log(data.isDirectory());});</code></pre><h3>&nbsp;11、两种路径</h3><pre><code class="language-javascript">//1. 导入 fs 模块const fs = require('fs');//相对路径// fs.writeFileSync('./index.html', 'love');// fs.writeFileSync('index.html', 'love');// fs.writeFileSync('../index.html', 'love');//绝对路径// fs.writeFileSync('D:/index.html', 'love');fs.writeFileSync('/index.html', 'love');</code></pre><h3>12、相对路径的Bug</h3><p>会根据终端运行node命令的路径位置不断变化</p><pre><code class="language-javascript">// const fs = require('fs');// 相对路径参照物: 命令行的工作目录// fs.writeFileSync('./index.html', 'love');//绝对路径 '全局变量' 保存的是: 所在文件的所在目录的绝对路径// console.log(__dirname);fs.writeFileSync(__dirname + '/index.html', 'love');</code></pre><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制台报错：Error in render: TypeError: Cannot read properties of null (reading &#39;protocol&#39;)</title>
      <link href="/2024/01/23/44-kong-zhi-tai-bao-cuo-error-in-render-typeerror-cannot-read-properties-of-null-reading-protocol/"/>
      <url>/2024/01/23/44-kong-zhi-tai-bao-cuo-error-in-render-typeerror-cannot-read-properties-of-null-reading-protocol/</url>
      
        <content type="html"><![CDATA[<h3>问题：</h3><p><img alt="" height="451" src="/medias/images/All/109.png" width="1065"></p><h3>场景：</h3><p>在实际项目开发中，有时会在vue模版中的html标签上，使用 v-if 条件判断节点是否展示。有时候通常习惯于直接根据对象某个key的属性值判断。</p><p>如下图demo写法：app.vue是父组件，HelloWorld.vue是子组件，属性绑定传递了一个infoObj对象</p><pre><code class="language-javascript">&lt;template&gt;  &lt;div id="app"&gt;    &lt;h1&gt;这是用vue-cli创建的Vue2项目&lt;/h1&gt;    &lt;img alt="Vue logo" src="./assets/logo.png" /&gt;    &lt;HelloWorld :infoObj="infoObj" /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from "./components/HelloWorld.vue";export default {  name: "App",  components: {    HelloWorld,  },  data() {    return {      infoObj: null,    };  },  created() {    setTimeout(() =&gt; {      this.infoObj = {        protocol: "ssh",      };    }, 1000);  },};&lt;/script&gt;</code></pre><p>在子组件上，通过infoObj的protocol这个key的值判断元素dom是否应该展示。</p><pre><code class="language-javascript">&lt;template&gt;  &lt;div class="hello"&gt;    &lt;h1 v-if="infoObj.protocol == 'ssh'"&gt;测试&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "HelloWorld",  props: {    infoObj: {      type: Object,      default: () =&gt; {},    },  },};&lt;/script&gt;</code></pre><h3>解决方案：</h3><p>如果在父组件app.vue中的infoObj 初始值为null，那么控制台一定会报错：TypeError: Cannot read properties of null (reading 'protocol')，如果 infoObj 初始值为{}，就不会报错。</p><p>通常情况下vue里的infoObj 应该是接口请求回来的值，注意赋值是null和undefined的情况：</p><pre><code class="language-javascript">export default {  name: "App",  components: {    HelloWorld,  },  data() {    return {      infoObj: {},    };  },  created() {    setTimeout(() =&gt; {      this.infoObj = undefined || {}    }, 1000);  },};&lt;/script&gt;</code></pre><p>这样就可以控制节点的显示与隐藏，控制台不会报错了。</p><p></p><p>当然更多的时候，前端的数据是通过接口获取的，为了防止后台接口的数据有null或者undefined的情况，可以在赋值时通过 || {}这种方式赋默认值，也可以通过watch 对 infoObj 监听，判断&nbsp;protocol 的值，赋值给一个 新的data数据：&nbsp;flag。再通过flag去控制元素显示与隐藏，也是可以的。可以根据实际情况灵活使用，规避控制台报错的情况出现。</p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2中的事件修饰符</title>
      <link href="/2024/01/23/43-vue2-zhong-de-shi-jian-xiu-shi-fu/"/>
      <url>/2024/01/23/43-vue2-zhong-de-shi-jian-xiu-shi-fu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Vue2中，事件修饰符是一种用于在DOM事件处理中进行特定操作的特殊标记。Vue2提供了一些内置的事件修饰符来简化事件处理逻辑。以下是Vue2中常用的事件修饰符：</p></blockquote><blockquote><ul><li>.prevent：阻止默认事件（常用）；</li>    <li>.stop：阻止事件冒泡（常用）；</li>    <li>.once：事件只触发一次（常用）；</li>    <li>.capture：使用事件的捕获模式；</li>    <li>.self：只有event.target是当前操作的元素时才触发事件；</li>    <li>.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</li></ul></blockquote><h3>&nbsp;示例代码：</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;title&gt;事件修饰符&lt;/title&gt;    &lt;!-- 引入Vue --&gt;    &lt;script type="text/javascript" src="../js/vue.js"&gt;&lt;/script&gt;    &lt;style&gt;      * {        margin-top: 20px;      }      .demo1 {        height: 50px;        background-color: skyblue;      }      .box1 {        padding: 5px;        background-color: skyblue;      }      .box2 {        padding: 5px;        background-color: orange;      }      .list {        width: 200px;        height: 200px;        background-color: peru;        overflow: auto;      }      li {        height: 100px;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!--         Vue中的事件修饰符：            1.prevent：阻止默认事件（常用）；            2.stop：阻止事件冒泡（常用）；            3.once：事件只触发一次（常用）；            4.capture：使用事件的捕获模式；            5.self：只有event.target是当前操作的元素时才触发事件；            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；        --&gt;    &lt;!-- 准备好一个容器--&gt;    &lt;div id="root"&gt;      &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt;      &lt;!-- 阻止默认事件（常用） --&gt;      &lt;a href="http://www.baidu.com" @click.prevent="showInfo"&gt;点我提示信息&lt;/a&gt;      &lt;!-- 阻止事件冒泡（常用）如果不加.stop，就是默认事件冒泡，先触发内存元素身上的点击事件，再触发外层元素身上的点击事件 --&gt;      &lt;div class="demo1" @click="showParentInfo"&gt;        &lt;button @click.stop="showInfo"&gt;点我提示信息&lt;/button&gt;        &lt;!-- 修饰符可以连续写 --&gt;        &lt;!-- &lt;a href="http://www.baidu.com" @click.prevent.stop="showInfo"&gt;点我提示信息&lt;/a&gt; --&gt;      &lt;/div&gt;      &lt;!-- 事件只触发一次（常用） --&gt;      &lt;button @click.once="showInfo"&gt;点我提示信息&lt;/button&gt;      &lt;!-- 使用事件的捕获模式，先触发外层元素身上的点击事件，再触发内层元素身上的点击事件 --&gt;      &lt;div class="box1" @click.capture="showMsg(1)"&gt;        div1        &lt;div class="box2" @click="showMsg(2)"&gt;div2&lt;/div&gt;      &lt;/div&gt;      &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt;      &lt;div class="demo1" @click.self="showParentInfo"&gt;        &lt;button @click="showInfo"&gt;点我提示信息&lt;/button&gt;      &lt;/div&gt;      &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； .passive 不常用 不加.passive，会先触发demo事件，滚动条的滚动有延迟。加了之后，滚动条立即滚动 --&gt;      &lt;ul @wheel.passive="demo" class="list"&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;        &lt;li&gt;4&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;  &lt;script type="text/javascript"&gt;    Vue.config.productionTip = false; //阻止 vue 在启动时生成生产提示。    new Vue({      el: "#root",      data: {        name: "CSDN",      },      methods: {        showInfo(e) {          alert("同学你好！");          console.log(e.target);        },        showParentInfo(e) {          alert("我是父元素");          console.log(e.target);        },        showMsg(msg) {          console.log(msg);        },        demo() {          for (let i = 0; i &lt; 100000; i++) {            console.log("#");          }          console.log("累坏了");        },      },    });  &lt;/script&gt;&lt;/html&gt;</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作报错：ECDSA host key for xx.xx.xxx.xxx has changed and you have requested strict checking</title>
      <link href="/2024/01/22/42-linux-cao-zuo-bao-cuo-ecdsa-host-key-for-xx.xx.xxx.xxx-has-changed-and-you-have-requested-strict-checking/"/>
      <url>/2024/01/22/42-linux-cao-zuo-bao-cuo-ecdsa-host-key-for-xx.xx.xxx.xxx-has-changed-and-you-have-requested-strict-checking/</url>
      
        <content type="html"><![CDATA[<p>问题场景：</p><p>服务器（假设ip地址是：10.10.100.225）磁盘坏了，重开了一个新的虚拟机之后，从另一个服务器（假如ip地址是：10.10.100.123）复制文件到变更后的服务器（225）时报错。如下图：</p><blockquote><p>ECDSA host key for xx.xx.xxx.xxx(ip地址)&nbsp;has changed and you have requested strict checking.</p><p></p><p>Host key verification failed.</p></blockquote><p><img alt="" height="358" src="/medias/images/All/105.png" width="1200"></p><p></p><p>&nbsp;解决：</p><p>先找到123服务器上的known_hosts文件</p><blockquote><p>vi /root/.ssh/known_hosts</p></blockquote><p>&nbsp;输入/225，可以找到对应的记录，假设是63，按两次dd键，可以删除这条记录，</p><p><img alt="" height="233" src="/medias/images/All/106.png" width="669"></p><p>然后输入&nbsp; &nbsp;:wq!&nbsp; 保存之后&nbsp;</p><p>&nbsp;<img alt="" height="197" src="/medias/images/All/107.png" width="663"></p><p>&nbsp;重新执行复制文件的命令，就会问你：</p><p>Are you sure you want to continue connecting:&nbsp;</p><p>输入yes之后，命令执行成功。</p><p><img alt="" height="230" src="/medias/images/All/108.png" width="996"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvm use切换node版本时乱码报错: exit status 1</title>
      <link href="/2024/01/22/41-nvm-use-qie-huan-node-ban-ben-shi-luan-ma-bao-cuo-exit-status-1/"/>
      <url>/2024/01/22/41-nvm-use-qie-huan-node-ban-ben-shi-luan-ma-bao-cuo-exit-status-1/</url>
      
        <content type="html"><![CDATA[<p>场景：我是直接在vscode中的终端使用nvm use 版本号，然后报错，设置无效。如下图：</p><p><img alt="" height="157" src="/medias/images/All/102.png" width="598"></p><p>&nbsp;解决：需要用管理员身份运行命令提示符，然后再执行nvm use <img alt="" height="727" src="/medias/images/All/103.png" width="794"></p><p>&nbsp;切换成功：</p><p>&nbsp;<img alt="" height="371" src="/medias/images/All/104.png" width="578"></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux环境下从一个服务器复制文件到另一个服务器</title>
      <link href="/2023/12/22/40-linux-huan-jing-xia-cong-yi-ge-fu-wu-qi-fu-zhi-wen-jian-dao-ling-yi-ge-fu-wu-qi/"/>
      <url>/2023/12/22/40-linux-huan-jing-xia-cong-yi-ge-fu-wu-qi-fu-zhi-wen-jian-dao-ling-yi-ge-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<p>在Linux中使用scp命令可以将文件或目录从一台服务器复制到另外一台服务器。</p><blockquote><p># 从源服务器复制文件到目标服务器<br>scp /path/to/source_file username@destination:/path/to/destination_directory</p><p><br># 从源服务器复制目录及其内容到目标服务器<br>scp -r /path/to/source_directory username@destination:/path/to/destination_directory&nbsp;</p></blockquote><blockquote><p>注意事项：</p><ul><li>    <p><code>/path/to/source_file</code>为要复制的文件路径；</p>    </li>    <li>    <p><code>username</code>为目标服务器上的有效用户名；</p>    </li>    <li>    <p><code>destination</code>为目标服务器的IP地址或主机名；</p>    </li>    <li>    <p><code>/path/to/destination_directory</code>为目标服务器上存放复制文件的目录路径。</p>    </li></ul><p></p></blockquote><pre><code class="language-cpp">scp /home/jenkins/config/workspace/20231128145025.tar.gz root@10.10.111.111:/home/</code></pre><p>注意此命令是在源服务器下执行，上面代码的意思是，将当前登录的服务器的/home/jenkins/config/workspace目录下的20231128145025.tar.gz压缩包文件复制到10.10.111.111服务器的root用户下的/home路径</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域的多种方案详解</title>
      <link href="/2023/12/07/39-kua-yu-de-duo-chong-fang-an-xiang-jie/"/>
      <url>/2023/12/07/39-kua-yu-de-duo-chong-fang-an-xiang-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器的同源策略是为了保护用户的安全，限制了跨域请求。同源策略要求请求的域名、协议和端口必须完全一致，只要有一个不同就会被认为是跨域请求。</p></blockquote><p>本文列举了一些处理跨域请求的解决方案：</p><blockquote><ul><li>&nbsp;JSONP</li>    <li>CORS跨域资源共享</li>    <li>http&nbsp; proxy</li>    <li>nginx反向代理</li>    <li>webSocket 协议跨域</li>    <li>postMessage</li>    <li>document.domain + iframe</li>    <li>window.name + iframe</li>    <li>location.hash + iframe</li></ul></blockquote><h1>1. JSONP</h1><p>先说缺点，JSONP只能处理get请求。</p><p>script、iframe、img、link 等src属性，不存在跨域请求的限制。利用这个特性可以实现跨域请求</p><p><img alt="" height="850" src="/medias/images/All/88.png" width="1200"></p><p>首先在服务器端用node+express模拟一个接口</p><pre><code class="language-javascript">let express = require("express");let app = express();app.listen(8001, (_) =&gt; {  console.log("服务器已启动!");});app.get("/list", (req, res) =&gt; {    // let { callback = Function.prototype } = req.query;  let callback = req.query.callback;  let data = {    code: 200,    messsage: "程序猿小野",  };  res.send(`${callback}(${JSON.stringify(data)})`);});</code></pre><p>1）使用jquery的ajax实现（axios的jsonp方法也可以）</p><pre><code class="language-javascript">$.ajax({    url: "http://127.0.0.1:8001/list",    method: "get",    dataType: "jsonp", // =&gt; 执行的JSONP的请求，不加这一行会报跨域错误，has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.    success: (res) =&gt; {    console.log(res);    },});</code></pre><p>web本地启动的服务器地址是：http://127.0.0.1:5501，服务器的地址是：http://127.0.0.1:8001/</p><p>不加dataType:"jsonp"时会报下面的跨域错误</p><p><img alt="" height="187" src="/medias/images/All/89.png" width="1200"></p><p>2）利用 script标签的src属性</p><pre><code class="language-javascript">function handleResponse(data) {    console.log("接收到的数据：", data);}let scriptEle = document.createElement("script");scriptEle.src = `http://127.0.0.1:8001/list?callback=handleResponse`;document.head.appendChild(scriptEle);</code></pre><p>成功接收到数据：&nbsp;</p><p><img alt="" height="250" src="/medias/images/All/90.png" width="867"></p><p></p><hr><h1>2. CORS跨域资源共享（必须掌握）</h1><pre><code class="language-javascript">&lt;script&gt;    axios    .get("http://127.0.0.1:8001/list")    .then((res) =&gt; {        console.log(res.data);    })    .catch((err) =&gt; {        console.error(err);    });&lt;/script&gt;</code></pre><p><img alt="" height="591" src="/medias/images/All/91.png" width="1200"></p><pre><code class="language-javascript">let express = require("express");let app = express();app.listen(8001, (_) =&gt; {  console.log("服务器已启动!");});app.use((req, res, next) =&gt; {  res.header("Access-Control-Allow-Origin", "http://127.0.0.1:5501");//   res.header("Access-Control-Allow-Origin", "*");//   res.header("Access-Control-Allow-Credentials", "true"); // 后端允许发送Cookie  next();});app.get("/list", (req, res) =&gt; {  let data = {    code: 200,    messsage: "程序猿小野",  };  res.send(`${JSON.stringify(data)}`);});</code></pre><p><img alt="" height="460" src="/medias/images/All/92.png" width="1082"></p><hr><h1>3.&nbsp;http&nbsp; proxy&nbsp;（必须掌握）</h1><p>这种情况是目前开发时，前端调试接口解决跨域问题，最常见的处理方法。一般通过webpack webpack-dev-server实现。用vue-cli创建的项目可以在vue.config.js中配置。</p><p>index.js</p><pre><code class="language-javascript">import axios from "axios";// axios.get("http://127.0.0.1:8001/user/list").then((res) =&gt; {axios.get("/user/list").then((res) =&gt; {  console.log(res);});</code></pre><p>&nbsp;没有配置proxy代理时，请求报错：</p><p><img alt="" height="833" src="/medias/images/All/93.png" width="1200"></p><p>vue.config.js配置示例：</p><pre><code class="language-javascript">devServer: {    open: true,    port: 10003,    headers: {      "Access-Control-Allow-Origin": "*",    },    proxy: {      "/": {        target: "http://127.0.0.1:8001/",        secure: false,        changeOrigin: true,      },    },  },</code></pre><p>&nbsp;webpack.config.js 配置示例：</p><pre><code class="language-javascript">let path = require("path");let HtmlWebpackPlugin = require("html-webpack-plugin");module.exports = {  mode: "production",  entry: "./src/index.js",  output: {    filename: "bundle.min.js",    path: path.resolve(__dirname, "build")  },  devServer: {    port: 3000,    progress: true,    contentBase: "./build",    proxy: {      "/": {        target: "http://127.0.0.1:8001",        changeOrigin: true      },    },  },  plugins: [    new HtmlWebpackPlugin({      template: "./src/index.html",      filename: "index.html",    })  ],};</code></pre><p></p><p>配置后请求成功：</p><p><img alt="" height="836" src="/medias/images/All/94.png" width="1200"></p><p></p><hr><h1>4.&nbsp;nginx反向代理（必须掌握）</h1><p>nginx 相关的内容比较多，有时间可以另开一个帖子去说。这里举一个我在实际开发过程中遇到的场景。我们的页面调其他前端模块的服务跨域了，在开发中没有，为什么上线后会出现呢。主要是因为开发时前端的服务都在同一个服务器上，不会产生跨域情况。上线部署在不同的服务器，这时候就出现了如下错误：</p><p><img alt="" height="66" src="/medias/images/All/95.png" width="1200"></p><p>修改ngnix的相关配置，实际ip地址和对应的服务名已处理。修改后跨域问题解决：</p><pre><code class="language-javascript">upstream testxxx {    server 127.0.0.1:3000 weight=1;    server 127.0.0.2:4000 weight=1;}location /fuwuming{    proxy_set_header Host $host:$server_port;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header REMOTE-HOST $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_pass http://testxxx/fuwuming;}</code></pre><p>查看结果：&nbsp;</p><p><img alt="" height="544" src="/medias/images/All/96.png" width="1200"></p><hr><h1>5. webSocket 协议跨域（必须掌握）</h1><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>原生WebSocket API使用起来不太方便，下面案例借助了socket.io.js的库，，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。&nbsp;</p><p>前端代码：</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      user input：&lt;input type="text" /&gt;&lt;button id="button"&gt;发送&lt;/button&gt;    &lt;/div&gt;    &lt;script src="./socket.io-4.7.2.js"&gt;&lt;/script&gt;    &lt;script&gt;      var socket = io("http://127.0.0.1:3000");      // 与服务器连接成功      socket.on("connect", () =&gt; {        console.log("socket链接成功！" + socket.id);      });      // 接收服务器发送的消息      socket.on("sendToClient", (message) =&gt; {        console.log(message);      });      let sendToServerFunc = function () {        let inputVal = document.getElementsByTagName("input")[0].value;        // 向服务器发送消息        socket.emit("sendToServer", {          message: `我是客户端: ${inputVal}`,        });      };      document.getElementsByTagName("input")[0].onblur = sendToServerFunc;      document.getElementById("button").onclick = sendToServerFunc;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>node服务器代码：</p><pre><code class="language-javascript">// 导入express模块const express = require('express')// 引入http创建服务器实例的方法const {createServer} = require('http')const {Server} = require('socket.io')// 创建express的服务器实例const app = express()// 创建http服务器实例const httpServer = createServer(app)// 创建socket.io的实例const io = new Server(httpServer,{  // 处理cors,解决跨域问题  cors:{    // origin: "http://127.0.0.1:5500",//需要跨域资源共享的地址    origin: "http://127.0.0.1:5501",//需要跨域资源共享的地址    allowedHeaders: ["my-custom-header"],    credentials: true  }})// 监听客户端连接，回调函数会传递本次连接的socketio.on('connection',(socket) =&gt; {  console.log(socket.id)  // 监听到客户端发送的消息  socket.on('sendToServer',(message) =&gt; {    console.log(message)    // 向客户端发送消息    socket.emit('sendToClient',{      message:'你好我是服务端，让我们来聊天呀'    })  })} ) // 调用listen方法，指定端口号并启动web服务器httpServer.listen(3000,() =&gt;{  console.log('server is running at http://127.0.0.1:3000')})</code></pre><p>效果如下：</p><p><img alt="" height="437" src="/medias/images/All/97.png" width="898">&nbsp;<img alt="" height="113" src="/medias/images/All/98.png" width="466"></p><hr><h1>6. postMessage</h1><p>MDN关于postMessage的介绍：</p><p>&nbsp;<img alt="" height="1140" src="/medias/images/All/99.png" width="1200"></p><p>&nbsp;测试案列：</p><p>先用node启动两个服务器，不同端口，模拟跨域场景。</p><blockquote><p>&nbsp;node serverA.js&nbsp; &nbsp; &nbsp;node serverB.js</p></blockquote><pre><code class="language-javascript">let express = require("express");let app = express();app.listen(1001, (_) =&gt; {  console.log("服务器A已启动!");});app.use(express.static("./"));</code></pre><pre><code class="language-javascript">let express = require("express");let app = express();app.listen(1002, (_) =&gt; {  console.log("服务器B已启动!");});app.use(express.static("./"));</code></pre><p>A.html&nbsp;</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;A 页面&lt;/h1&gt;    &lt;iframe id="iframe" src="http://127.0.0.1:1002/B.html" frameborder="0" style="display: none;"&gt;&lt;/iframe&gt;    &lt;script&gt;        iframe.onload = function () {            iframe.contentWindow.postMessage('这是A页面传过来的数据AAA', '*');        }        // 监听B页面传递的消息        window.onmessage = function(res){            console.log(res);        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>B.html&nbsp;</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;B 页面&lt;/h1&gt;    &lt;script&gt;      // 监听A页面传递的消息      window.onmessage = function (res) {        console.log(res);        res.source.postMessage("这是B页面传过来的数据BBB", res.origin);      };    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p><span style="color:#fe2c24;">下面几种方案只做了解，实际上几乎用不到。</span>&nbsp;</p><h1>7. document.domain + iframe （只做了解）</h1><p>此方案只能实现：同一个主域，不同子域之间的操作</p><p>比如：http://www.domain.com/a.html&nbsp; 和&nbsp;&nbsp;http://child.domain.com/b.html&nbsp; 属于同一个主域</p><pre><code class="language-javascript">&lt;iframe id="iframe" src="http://child.domain.com/b.html"&gt;&lt;/iframe&gt;&lt;script&gt;    document.domain = 'domain.com';    var user = 'admin';&lt;/script&gt;</code></pre><pre><code class="language-javascript">&lt;script&gt;    document.domain = 'domain.com';    // 获取父窗口中变量    console.log(window.parent.user);&lt;/script&gt;</code></pre><h1>8.&nbsp;window.name + iframe（只做了解）</h1><p>三个页面：A.html地址为：http://127.0.0.1:1001/A.html</p><p>B.html地址为：http://127.0.0.1:002/B.html</p><p>Proxy.html地址为：http://127.0.0.1:1002/proxy.html</p><p>可以看出B页面和Proxy页面同源，A想访问B的数据就跨域了</p><p>B.html的代码，可以看到B.html的window对象上有一个name属性</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;        // 服务器端需要返回给A的信息都在window.name中存储      window.name = "这是B页面的数据";    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;iframe      id="iframe"      src="http://127.0.0.1:1002/B.html"      frameborder="0"      style="display: none"    &gt;&lt;/iframe&gt;    &lt;script&gt;      iframe.onload = function () {        // 直接读不允许；        console.log(iframe.contentWindow.name);      };    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>直接读不允许，控制报跨域错误&nbsp;</p><p><img alt="" height="552" src="/medias/images/All/100.png" width="1200"></p><p>&nbsp;将iframe的src属性修改成和B.html同域的Proxy.html地址</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;iframe      id="iframe"      src="http://127.0.0.1:1002/B.html"      frameborder="0"      style="display: none"    &gt;&lt;/iframe&gt;    &lt;script&gt;      let count = 0;      iframe.onload = function () {        // 直接读不允许；        // console.log(iframe.contentWindow.name);        // 需要我们先把地址重新指向到同源中，才可以        // iframe.src = 'http://127.0.0.1:1001/proxy.html';        // 只要proxy.html中的window没有name属性，那么这里就会取到B.html中window.name        // console.log(iframe.contentWindow.name);        if (count === 0) {          iframe.src = "http://127.0.0.1:1001/proxy.html";          count++;          return;        }        console.log(iframe.contentWindow.name);      };    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在A.html中成功读取到B.html的数据&nbsp;</p><p><img alt="" height="470" src="/medias/images/All/101.png" width="1200"></p><h1>9. location.hash + iframe（只做了解）</h1><p>A和C同源，A和B非同源</p><p>A.html</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;iframe      id="iframe"      src="http://127.0.0.1:1002/B.html"      frameborder="0"      style="display: none"    &gt;&lt;/iframe&gt;    &lt;script&gt;      let iframe = document.getElementById("iframe");      iframe.onload = function () {        iframe.src = "http://127.0.0.1:1002/B.html#msg=hello";      };      // 开放给同域C.html的回调方法      function func(res) {        console.log(res);      }    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>B.html</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;iframe      id="iframe"      src="http://127.0.0.1:1001/C.html"      frameborder="0"      style="display: none"    &gt;&lt;/iframe&gt;    &lt;script&gt;      let iframe = document.getElementById("iframe");      // 监听A传来的HASH值改变，再传给C.html      window.onhashchange = function () {        iframe.src = "http://127.0.0.1:1001/C.html" + location.hash;      };    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>&nbsp;C.html</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      // 监听B传来的Hash值      window.onhashchange = function () {        // 再通过操作同域A的js回调，将结果传回        window.parent.parent.func(location.hash);      };    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><hr><p>如果还有其他方案，欢迎留言补充。</p><p>总结一下：2、3、4、5 我个人觉得是必须要掌握的，因为我在实际的项目开发中都使用过。&nbsp;</p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSONP </tag>
            
            <tag> CORS </tag>
            
            <tag> proxy </tag>
            
            <tag> Nginx </tag>
            
            <tag> webSocket </tag>
            
            <tag> postMessage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window环境下使用nginx部署多个项目（详细）</title>
      <link href="/2023/12/07/38-window-huan-jing-xia-shi-yong-nginx-bu-shu-duo-ge-xiang-mu-xiang-xi/"/>
      <url>/2023/12/07/38-window-huan-jing-xia-shi-yong-nginx-bu-shu-duo-ge-xiang-mu-xiang-xi/</url>
      
        <content type="html"><![CDATA[<p>在官网下载相应版本的nginx安装包，链接如下：<br><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="nginx: download" href="https://nginx.org/en/download.html" title="nginx: download">nginx: download</a></p><p><img alt="" height="1200" src="/medias/images/All/70.png" width="1200"></p><p>下载压缩包之后找一个目录解压就行了，我这里放在&nbsp;D:\Program Files (x86) 目录下。</p><p>&nbsp;<img alt="" height="384" src="/medias/images/All/71.png" width="657"></p><p>&nbsp;可以直接双击nginx.exe 本地启动nginx服务器。但是更推荐使用命令行：在这个目录下cmd打开黑窗口：D:\Program Files (x86)\nginx-1.24.0。下面是三个常用的命令</p><blockquote><ul><li>start nginx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 启动nginx服务器</li>    <li>nginx -s stop&nbsp; &nbsp; &nbsp; &nbsp; 停止nginx服务器</li>    <li>nginx -s reload&nbsp; &nbsp; &nbsp;重启nginx服务器，修改nginx.conf配置文件后，需要重启生效</li></ul></blockquote><p><img alt="" height="305" src="/medias/images/All/72.png" width="769"></p><p></p><p>&nbsp;启动成功后，在浏览器输入：localhost，也可以输入本机的ip，就会出现如下页面：</p><p><img alt="" height="453" src="/medias/images/All/73.png" width="1200"></p><p>&nbsp;能出现上面的页面主要是因为，nginx.conf中的这一段配置：</p><pre><code>server {    listen       80;    server_name  localhost;    location / {        root   html;        index  index.html index.htm;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }}</code></pre><p>&nbsp;root 设置的是实际访问的路径，比如html，就是访问当前的html目录<img alt="" height="209" src="/medias/images/All/74.png" width="832"></p><p><img alt="" height="302" src="/medias/images/All/75.png" width="1086"></p><p>所以要想在nginx配置多个项目，就是要在nginx.conf中配置多个server，监听不同的端口号，设置root指向不同的路径就行了。</p><p>我一个用了三个测试的前端项目，分别是：vue-cli创建的vue2和vue3项目，还有vite创建的react项目。</p><p>在html中新建三个文件夹，名字可以随便取，我这里分别叫vue2-init、vue3-init、vite-react-init。这三个文件夹下放的是对应相应npm run build之后生成的dist文件夹</p><p><img alt="" height="345" src="/medias/images/All/76.png" width="903"></p><p><img alt="" height="235" src="/medias/images/All/77.png" width="746">&nbsp;然后修改nginx.conf的配置文件，复制一个新的server，listen的端口号和root的路径。nginx -s reload 重启nginx服务器。</p><p><img alt="" height="725" src="/medias/images/All/78.png" width="1136">&nbsp;在浏览器中可以访问：</p><p><img alt="" height="1192" src="/medias/images/All/79.png" width="1200"></p><p><img alt="" height="1198" src="/medias/images/All/80.png" width="1200"></p><p>&nbsp;除了localhost，也可以是用本机ip+端口访问：<img alt="" height="1145" src="/medias/images/All/81.png" width="1200"></p><p>&nbsp;这样就在本地部署了几个不同的前端项目。</p><p>此外，说一下配置nginx.conf 时的注意事项：</p><p>1、我以为端口号是随便写的，第一次上来就写了一个6666，结果一直如下界面。<img alt="" height="672" src="/medias/images/All/82.png" width="1200"></p><p>2、root 的配置，初始的root是 html，以及在linux下的root配置一般都是如下这种</p><pre><code>location / {    root         /home/tools/nginx/html/web;    index        index.html;}</code></pre><p>在window环境下，root要指定路径：D:/Program Files (x86)/nginx-1.24.0/html/vue2-init/dist</p><p>如果路径中有空格，需要使用双引号。还要注意斜杠的方向。我直接复制本机文件资源管理器的路径，会报错。</p><p>&nbsp;<img alt="" height="274" src="/medias/images/All/83.png" width="847"></p><p>&nbsp;<img alt="" height="528" src="/medias/images/All/84.jpeg" width="1200"></p><p>&nbsp;3、此外再说一个，使用nginx配置，本地链接直接访问百度网站的案例</p><p>新增一个location，路径是/bd，重启后，访问：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="http://localhost:3002/bd" href="http://localhost:3002/bd" title="http://localhost:3002/bd">http://localhost:3002/bd</a></p><p><img alt="" height="343" src="/medias/images/All/85.png" width="858"></p><p>显示的就是百度的网站&nbsp;</p><p><img alt="" height="769" src="/medias/images/All/86.png" width="1200"></p><p>&nbsp;<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="http://localhost:3002/bd?&amp;wd=%E8%B7%AF%E8%99%BD%E8%BF%9C%E8%A1%8C%E5%88%99%E5%B0%86%E8%87%B3%EF%BC%8C%E4%BA%8B%E8%99%BD%E9%9A%BE%E5%81%9A%E5%88%99%E5%BF%85%E6%88%90" href="http://localhost:3002/bd?&amp;wd=%E8%B7%AF%E8%99%BD%E8%BF%9C%E8%A1%8C%E5%88%99%E5%B0%86%E8%87%B3%EF%BC%8C%E4%BA%8B%E8%99%BD%E9%9A%BE%E5%81%9A%E5%88%99%E5%BF%85%E6%88%90" title="http://localhost:3002/bd?&amp;wd=%E8%B7%AF%E8%99%BD%E8%BF%9C%E8%A1%8C%E5%88%99%E5%B0%86%E8%87%B3%EF%BC%8C%E4%BA%8B%E8%99%BD%E9%9A%BE%E5%81%9A%E5%88%99%E5%BF%85%E6%88%90">http://localhost:3002/bd?&amp;wd=%E8%B7%AF%E8%99%BD%E8%BF%9C%E8%A1%8C%E5%88%99%E5%B0%86%E8%87%B3%EF%BC%8C%E4%BA%8B%E8%99%BD%E9%9A%BE%E5%81%9A%E5%88%99%E5%BF%85%E6%88%90</a></p><p><img alt="" height="1146" src="/medias/images/All/87.png" width="1200"></p><p>当前端出现跨域时，用nginx修改proxy_pass，是解决前端跨域特别好用的方案。</p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Object.defineProperty()方法</title>
      <link href="/2023/11/29/37-xiang-jie-object.defineproperty-fang-fa/"/>
      <url>/2023/11/29/37-xiang-jie-object.defineproperty-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty是一个用于定义或修改对象属性的方法。它提供了一种更底层和灵活的方式来定义属性，可以设置属性的配置（如可枚举性、可配置性、可写性等），并且可以定义属性的getter和setter函数。</p><p>语法：</p><pre><code class="language-javascript">Object.defineProperty(obj, prop, descriptor)</code></pre><blockquote><p>&nbsp;参数说明：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `obj`：要定义属性的对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `prop`：要定义或修改的属性名称。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `descriptor`：一个描述符对象，用于定义或修改属性的特性。它有以下可选的键值：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `value`：属性的值，默认为`undefined`。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `writable`：属性的可写性。默认为`false`，即该属性为只读属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `enumerable`：属性的可枚举性。默认为`false`，即该属性不可枚举。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `configurable`：属性的可配置性。默认为`false`，即该属性不可被删除。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `get`：获取属性值的函数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- `set`：设置属性值的函数。</p></blockquote><p>直接看代码：</p><p>没有设置writable、enumerable、configurable属性，默认都为false，age属性不可枚举，不可修改，不可删除。</p><pre><code class="language-javascript">  let person = {    name: "张三",    sex: "男",  };  Object.defineProperty(person, 'age', {      value: 18,  })  console.log(person); // {name: '张三', sex: '男', age: 18}  for (p in person) { // 这里由于Object.defineProperty中没有设置enumerable:true，所以age属性不会参与枚举遍历      console.log(p);      // name      // sex  }  person.age = 19;     // 这里由于Object.defineProperty中没有设置writable:true，所以修改不会生效  console.log(person); // {name: '张三', sex: '男', age: 18}  delete person.age;   // 这里由于Object.defineProperty中没有设置configurable:true，所以删除不会生效  console.log(person); // {name: '张三', sex: '男', age: 18}</code></pre><p>此时修改是person对象上的age值是无效的，值实际上没有更新&nbsp;&nbsp;</p><p><img alt="" height="297" src="/medias/images/All/67.png" width="727"></p><p>设置了writable、enumerable、configurable属性的值为true之后，age属性可以被枚举，可以被修改，可以被删除。&nbsp;</p><pre><code class="language-javascript">  let person = {    name: "张三",    sex: "男",  };  Object.defineProperty(person, "age", {    value: 18,    enumerable: true, //控制属性是否可以枚举，默认值是false    writable: true, //控制属性是否可以被修改，默认值是false    configurable: true, //控制属性是否可以被删除，默认值是false  });  console.log(person); // {name: '张三', sex: '男', age: 18}  for (p in person) {    // 这里由于Object.defineProperty中设置了enumerable:true，所以age属性参与了枚举遍历    console.log(p);    // name    // sex    // age  }  person.age = 19; // 这里由于Object.defineProperty中设置了writable:true，所以修改生效了  console.log(person); // {name: '张三', sex: '男', age: 19}  delete person.age; // 这里由于Object.defineProperty中设置了configurable:true，所以删除生效了  console.log(person); // {name: '张三', sex: '男'}</code></pre><p>&nbsp;Object.defineProperty &nbsp;还可以设置getter和setter方法</p><pre><code class="language-javascript">let number = 18;let person = {    name: "张三",    sex: "男",};// 此外 Object.defineProperty  还可以设置getter和setter方法Object.defineProperty(person, "age", {  // value:18,  // enumerable:true, //控制属性是否可以枚举，默认值是false  // writable:true, //控制属性是否可以被修改，默认值是false  // configurable:true, //控制属性是否可以被删除，默认值是false  //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值  get() {    console.log("有人读取age属性了");    return number;  },  //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值  set(value) {    console.log("有人修改了age属性，且值是", value);    number = value;  },});console.log('person', person);console.log('number', number);</code></pre><p><img alt="" height="430" src="/medias/images/All/68.png" width="628"></p><p>注意事项：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty() 设置了getter和setter方法之后，就不能再设置value属性，否则控制台报错：Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;</p><p><img alt="" height="73" src="/medias/images/All/69.png" width="1200"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端开发好用的网站记录</title>
      <link href="/2023/11/25/36-qian-duan-kai-fa-hao-yong-de-wang-zhan-ji-lu/"/>
      <url>/2023/11/25/36-qian-duan-kai-fa-hao-yong-de-wang-zhan-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>由于国内访问不了谷歌商店，所以当我们想不翻墙就可以安装一些谷歌插件时，可以借助第三方网站，下面是我常用的两个谷歌浏览器插件网站</p><p>1. 极简插件</p><p><a data-link-desc="极简插件是一个优质Chrome插件扩展收录下载网站，收录热门好用的Chrome插件扩展，国内最方便的插件下载网站。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="极简插件_Chrome扩展插件商店_优质crx应用下载" href="https://chrome.zzzmh.cn/#/index" title="极简插件_Chrome扩展插件商店_优质crx应用下载">极简插件_Chrome扩展插件商店_优质crx应用下载</a></p><p>2. 收藏猫插件</p><p><a data-link-desc="收藏猫插件是一个Chrome插件收录及下载的网站,收录Chrome插件,国内最好用的插件下载网站" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="收藏猫插件-Chrome插件商店,谷歌浏览器插件,谷歌应用商店插件推荐及下载" href="https://chrome.pictureknow.com/" title="收藏猫插件-Chrome插件商店,谷歌浏览器插件,谷歌应用商店插件推荐及下载">收藏猫插件-Chrome插件商店,谷歌浏览器插件,谷歌应用商店插件推荐及下载</a></p><hr><p>3. 开源库的下载，如果你想下载一些常用的js库文件，BootCDN提供了很多可以快速下载的资源</p><p><a data-link-desc="Bootstrap 中文网开源项目免费 CDN 加速服务 - 我们致力于为 Bootstrap、jQuery、Angular、Vue.js 一样优秀的开源项目提供稳定、快速、免费的 CDN 加速服务。BootCDN 是运营时间最长、用户量最大、最早同时支持 HTTPS（SSL）和 HTTP/2.0 协议的中立免费 CDN 。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务" href="https://www.bootcdn.cn/" title="BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务">BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务</a></p><p><img alt="" height="1200" src="/medias/images/All/62.png" width="1200"></p><hr><p>除了BootCDN还有下面这个：</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://cdnjs.com/libraries" href="https://cdnjs.com/libraries" title="https://cdnjs.com/libraries">https://cdnjs.com/libraries</a></p><p><img alt="" height="1200" src="/medias/images/All/63.png" width="1200"></p><p>4. web前端导航，一些博客以及技术文档链接合集</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="Web前端导航" href="http://www.alloyteam.com/nav/" title="Web前端导航">Web前端导航</a></p><hr><p>&nbsp;5. 前端在学习或者测试的时候总会遇到需要请求后台接口数据的场景，下面收集了一些免费的api，调用可以返回数据。</p><p>首先是github提供的，第一个是github的api合集，第二个是查询github用户的接口</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://api.github.com/" href="https://api.github.com/" title="https://api.github.com/">https://api.github.com/</a></p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://api.github.com/search/users?q=test" href="https://api.github.com/search/users?q=test" title="https://api.github.com/search/users?q=test">https://api.github.com/search/users?q=test</a></p><p>&nbsp;Free Dictionary API 提供了各种单词的查询和释义</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="Free Dictionary API" href="https://dictionaryapi.dev/" title="Free Dictionary API">Free Dictionary API</a></p><p>&nbsp;Dog API是随机返回一张狗狗照片URL和状态的接口</p><p><a data-link-desc="Dog API - The internet's biggest collection of open source dog pictures. Fetching you over 20,000 dog images accessible by over 120 breeds." data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="Dog API" href="https://dog.ceo/dog-api/" title="Dog API">Dog API</a></p><p><img alt="" height="749" src="/medias/images/All/64.png" width="1200"></p><p></p><p>下面这个接口访问会随机返回一句话&nbsp;</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://api.uixsj.cn/hitokoto/get?type=social" href="https://api.uixsj.cn/hitokoto/get?type=social" title="https://api.uixsj.cn/hitokoto/get?type=social">https://api.uixsj.cn/hitokoto/get?type=social</a>&nbsp;&nbsp;</p><p><img alt="" height="222" src="/medias/images/All/65.png" width="753"></p><p>&nbsp;除此之外，前端也可以使用nodejs在本地启动一个服务器，模拟一个接口，供调试学习使用。</p><hr><p>6. 若依管理系统：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="RuoYi 若依官方网站 |后台管理系统|权限管理系统|快速开发框架|企业管理系统|开源框架|微服务框架|前后端分离框架|开源后台系统|RuoYi|RuoYi-Vue|RuoYi-Cloud|RuoYi框架|RuoYi开源|RuoYi视频|若依视频|RuoYi开发文档|若依开发文档|Java开源框架|Java|SpringBoot|SrpingBoot2.0|SrpingCloud|Alibaba|MyBatis|Shiro|OAuth2.0|Thymeleaf|BootStrap|Vue|Element-UI||www.ruoyi.vip" href="https://ruoyi.vip/" title="RuoYi 若依官方网站 |后台管理系统|权限管理系统|快速开发框架|企业管理系统|开源框架|微服务框架|前后端分离框架|开源后台系统|RuoYi|RuoYi-Vue|RuoYi-Cloud|RuoYi框架|RuoYi开源|RuoYi视频|若依视频|RuoYi开发文档|若依开发文档|Java开源框架|Java|SpringBoot|SrpingBoot2.0|SrpingCloud|Alibaba|MyBatis|Shiro|OAuth2.0|Thymeleaf|BootStrap|Vue|Element-UI||www.ruoyi.vip">RuoYi 若依官方网站 |后台管理系统|权限管理系统|快速开发框架|企业管理系统|开源框架|微服务框架|前后端分离框架|开源后台系统|RuoYi|RuoYi-Vue|RuoYi-Cloud|RuoYi框架|RuoYi开源|RuoYi视频|若依视频|RuoYi开发文档|若依开发文档|Java开源框架|Java|SpringBoot|SrpingBoot2.0|SrpingCloud|Alibaba|MyBatis|Shiro|OAuth2.0|Thymeleaf|BootStrap|Vue|Element-UI||www.ruoyi.vip</a></p><hr><p>7. 谷歌浏览器历史版本下载 （需要翻墙）</p><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="Chromium History Versions Download ↓" href="https://vikyd.github.io/download-chromium-history-version/#/" title="Chromium History Versions Download ↓">Chromium History Versions Download ↓</a></p><blockquote><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://vikyd.github.io/download-chromium-history-version/#/" href="https://vikyd.github.io/download-chromium-history-version/#/" title="https://vikyd.github.io/download-chromium-history-version/#/">https://vikyd.github.io/download-chromium-history-version/#/</a></p></blockquote><p>&nbsp;<img alt="" height="915" src="/medias/images/All/66.png" width="749"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句练习题（持续更新~）</title>
      <link href="/2023/11/24/35-mysql-yu-ju-lian-xi-ti-chi-xu-geng-xin/"/>
      <url>/2023/11/24/35-mysql-yu-ju-lian-xi-ti-chi-xu-geng-xin/</url>
      
        <content type="html"><![CDATA[<h1>表名和字段</h1><blockquote><p>–1.学生表</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Student(s_id,s_name,s_birth,s_sex) --学生编号,学生姓名, 出生年月,学生性别</p><p>–2.课程表</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Course(c_id,c_name,t_id) – --课程编号, 课程名称, 教师编号</p><p>–3.教师表</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Teacher(t_id,t_name) --教师编号,教师姓名</p><p>–4.成绩表</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Score(s_id,c_id,s_score) --学生编号,课程编号,分数</p></blockquote><h1>&nbsp;建表并插入数据</h1><pre><code class="language-sql">##  建表-- 学生表CREATE TABLE `Student`(    `s_id`    VARCHAR(20),    `s_name`  VARCHAR(20) NOT NULL DEFAULT '',    `s_birth` VARCHAR(20) NOT NULL DEFAULT '',    `s_sex`   VARCHAR(10) NOT NULL DEFAULT '',    PRIMARY KEY (`s_id`));-- 课程表CREATE TABLE `Course`(    `c_id`   VARCHAR(20),    `c_name` VARCHAR(20) NOT NULL DEFAULT '',    `t_id`   VARCHAR(20) NOT NULL,    PRIMARY KEY (`c_id`));-- 教师表CREATE TABLE `Teacher`(    `t_id`   VARCHAR(20),    `t_name` VARCHAR(20) NOT NULL DEFAULT '',    PRIMARY KEY (`t_id`));-- 成绩表CREATE TABLE `Score`(    `s_id`    VARCHAR(20),    `c_id`    VARCHAR(20),    `s_score` INT(3),    PRIMARY KEY (`s_id`, `c_id`));-- 插入学生表测试数据insert into Studentvalues ('01', '赵雷', '1990-01-01', '男');insert into Studentvalues ('02', '钱电', '1990-12-21', '男');insert into Studentvalues ('03', '孙风', '1990-05-20', '男');insert into Studentvalues ('04', '李云', '1990-08-06', '男');insert into Studentvalues ('05', '周梅', '1991-12-01', '女');insert into Studentvalues ('06', '吴兰', '1992-03-01', '女');insert into Studentvalues ('07', '郑竹', '1989-07-01', '女');insert into Studentvalues ('08', '王菊', '1990-01-20', '女');-- 插入课程表测试数据insert into Coursevalues ('01', '语文', '02');insert into Coursevalues ('02', '数学', '01');insert into Coursevalues ('03', '英语', '03');-- 插入教师表测试数据insert into Teachervalues ('01', '张三');insert into Teachervalues ('02', '李四');insert into Teachervalues ('03', '王五');-- 插入成绩表测试数据insert into Scorevalues ('01', '01', 80);insert into Scorevalues ('01', '02', 90);insert into Scorevalues ('01', '03', 99);insert into Scorevalues ('02', '01', 70);insert into Scorevalues ('02', '02', 60);insert into Scorevalues ('02', '03', 80);insert into Scorevalues ('03', '01', 80);insert into Scorevalues ('03', '02', 80);insert into Scorevalues ('03', '03', 80);insert into Scorevalues ('04', '01', 50);insert into Scorevalues ('04', '02', 30);insert into Scorevalues ('04', '03', 20);insert into Scorevalues ('05', '01', 76);insert into Scorevalues ('05', '02', 87);insert into Scorevalues ('06', '01', 31);insert into Scorevalues ('06', '03', 34);insert into Scorevalues ('07', '02', 89);insert into Scorevalues ('07', '03', 98);</code></pre><h1>练习题和SQL</h1><pre><code class="language-sql">##练习题和sql语句-- 1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数select stu.*, sc1.s_score 01_score, sc2.s_score 02_scorefrom student stu,     score sc1,     score sc2where stu.s_id = sc1.s_id  and stu.s_id = sc2.s_id  and sc1.c_id = '01'  and sc2.c_id = '02'  and sc1.s_score &gt; sc2.s_score;# 也可以用这种select a.*, b.s_score as 01_score, c.s_score as 02_scorefrom student a         join score b on a.s_id = b.s_id and b.c_id = '01'         left join score c on a.s_id = c.s_id and c.c_id = '02'where b.s_score &gt; c.s_score;-- 2、查询"01"课程比"02"课程成绩低的学生的信息及课程分数select a.*, b.s_score 01_score, c.s_score 02_scorefrom student a         join score b on a.s_id = b.s_id and b.c_id = '01'         left join score c on c.s_id = a.s_id and c.c_id = '02'where b.s_score &lt; c.s_score;# 也可以这种select a.*, b.s_score 01_score, c.s_score c_scorefrom student a,     score b,     score cwhere a.s_id = b.s_id  and a.s_id = c.s_id  and b.c_id = '01'  and c.c_id = '02'  and b.s_score &lt; c.s_score;-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩select a.s_id, a.s_name, avg(b.s_score)from student a         left join score b on a.s_id = b.s_idgroup by a.s_id, a.s_namehaving avg(b.s_score) &gt; 60;-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩-- (包括有成绩的和无成绩的)# 这一句只能查出成绩表中有成绩的学生的数据# select a.s_id, a.s_name, avg(b.s_score)# from student a#          left join score b on a.s_id = b.s_id# group by a.s_id# having avg(b.s_score) &lt; 60;# 用 union# UNION运算符用于组合两个或更多SELECT语句的结果集。# UNION中的每个SELECT语句必须具有相同的列数#select a.s_id, a.s_name, avg(b.s_score)from student a         left join score b on a.s_id = b.s_idgroup by a.s_idhaving avg(b.s_score) &lt; 60unionselect a.s_id, a.s_name, 0from student awhere a.s_id not in (select distinct s_id from score);-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩select a.s_id, a.s_name, count(b.s_id) sum_course, sum(b.s_score)from student a         left join score b on a.s_id = b.s_idgroup by a.s_id;-- 6、查询"李"姓老师的数量select count(*)from teacher twhere t.t_name like '李%';-- 7、查询学过"张三"老师授课的同学的信息-- 先查出姓名为“张三”的老师的t_id  01-- 再查出t_id为01的课程c_id-- 再判断score表 c_idselect a.*from student a         left join questions.score b on a.s_id = b.s_idwhere b.c_id in (select c_id from course where t_id = (select t_id from teacher where t_name = '张三'));-- 用这种好像也可以查出来select a.*from student a         left join questions.score b on a.s_id = b.s_idwhere b.c_id = (select c_id from course where t_id = (select t_id from teacher where t_name = '张三'));-- 用这种好像也可以查出来select a.*from student a         left join questions.score b on a.s_id = b.s_id         left join questions.course c on b.c_id = c.c_id         left join questions.teacher t on c.t_id = t.t_idwhere t_name = '张三';-- 8、查询没学过"张三"老师授课的同学的信息-- 先查出姓名为“张三”的老师的t_id  01-- 再查出t_id为01的课程c_id-- 再判断score表 c_idselect *from student cwhere c.s_id not in (select a.s_id                     from student a                              join score b on a.s_id = b.s_id                     where b.c_id in (select a.c_id                                      from course a                                               join teacher b on a.t_id = b.t_id                                      where t_name = '张三'));-- 可以这么写select c.*from student cwhere c.s_id not in (select a.s_id                     from student a                              left join questions.score b on a.s_id = b.s_id                     where b.c_id =                           (select c_id from course where t_id = (select t_id from teacher where t_name = '张三')));-- 9、查询学过编号为"01"并且也学过编号为"02"的课程的同学的信息select a.*from student a,     score b,     score cwhere a.s_id = b.s_id  and a.s_id = c.s_id  and b.c_id = '01'  and c.c_id = '02';-- 也可以这么写select a.*from student a         left join score b on a.s_id = b.s_id         left join score s on a.s_id = s.s_idwhere b.c_id = '01' &amp;&amp; s.c_id = '02';-- 10、查询学过编号为"01"但是没有学过编号为"02"的课程的同学的信息-- 自己想的逻辑，多此一举了，条件里不需要连接查询，-- select * from student a, score b where a.s_id = b.s_id and b.c_id = '01' ;-- select * from student a, score b where a.s_id = b.s_id and b.c_id = '02';-- select c.* from student c where c.s_id not in (select a.s_id from student a, score b where a.s_id = b.s_id and b.c_id = '02') and c.s_id in (select a.s_id from student a, score b where a.s_id = b.s_id and b.c_id = '01') ;-- 直接查score表查出满足条件的s_id即可select a.*from student awhere a.s_id in (select s_id from score where c_id = '01')  and a.s_id not in (select s_id from score where c_id = '02');-- 11、查询没有学全所有课程的同学的信息-- 查出所有课程数：select count(*) from course;-- 根据s_id分组查出课程数量小于全部课程数量的学生select a.*from student a         left join score b on a.s_id = b.s_idgroup by a.s_idhaving count(b.c_id) &lt; (select count(*) from course);-- 也可以这么写，查出学所有课程学生的s_id，判断不在里面的select *from studentwhere s_id not in (select s_id from score t1 group by s_id having count(*) = (select count(distinct c_id) from course));-- 12、查询至少有一门课与学号为"01"的同学所学相同的同学的信息-- 查询学号为01的同学信息：select * from student a left join score b on a.s_id = b.s_id where a.s_id = '01';select distinct c.*from student c         left join score d on c.s_id = d.s_idwhere d.c_id in (select b.c_id                 from student a                          left join score b on a.s_id = b.s_id                 where a.s_id = '01')  and d.s_id != '01';-- 也可以这么写select *from studentwhere s_id in (select distinct a.s_id from score a where a.c_id in (select a.c_id from score a where a.s_id = '01'))  and s_id != '01';-- 13、查询和"01"号的同学学习的课程完全相同的其他同学的信息SELECT *FROM StudentWHERE s_id IN (SELECT s_id               FROM Score               GROUP BY s_id               HAVING COUNT(s_id) = (                   #下面的语句是找到'01'同学学习的课程数                   SELECT COUNT(c_id)                   FROM Score                   WHERE s_id = '01'))  AND s_id NOT IN (    #下面的语句是找到学过‘01’同学没学过的课程，有哪些同学。并排除他们    SELECT s_id    FROM Score    WHERE c_id IN (        #下面的语句是找到‘01’同学没学过的课程        SELECT DISTINCT c_id        FROM Score        WHERE c_id NOT IN (            #下面的语句是找出‘01’同学学习的课程            SELECT c_id            FROM Score            WHERE s_id = '01'))    GROUP BY s_id) #下面的条件是排除01同学  AND s_id NOT IN ('01');-- 也可以这样SELECT t3.*FROM (SELECT s_id,             group_concat(c_id ORDER BY c_id) group1      FROM score      WHERE s_id &gt; '01'      GROUP BY s_id) t1         INNER JOIN (SELECT group_concat(c_id ORDER BY c_id) group2                     FROM score                     WHERE s_id = '01'                     GROUP BY s_id) t2 ON t1.group1 = t2.group2         INNER JOIN student t3 ON t1.s_id = t3.s_id;-- 14、查询没学过"张三"老师讲授的任一门课程的学生姓名-- 先查张三老师的t_id,在course表的c_id-- select t_id from teacher where t_name = '张三';-- select c_id from course where t_id = '01';-- select s_id from score where c_id = '02';select s_namefrom studentwhere s_id not in (select s_id                   from score                   where c_id =                         (select c_id from course where t_id = (select t_id from teacher where t_name = '张三')));-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩-- 查询有两门或两门以上不及格的s_id: select s_id from score where s_score &lt; 60 GROUP BY s_id having count(*) &gt;= 2;select a.s_id, a.s_name, AVG(b.s_score)from student a         left join score b on a.s_id = b.s_idwhere a.s_id in (select s_id from score where s_score &lt; 60 GROUP BY s_id having count(*) &gt;= 2)GROUP BY a.s_id;</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础（七）事务</title>
      <link href="/2023/11/24/34-mysql-ji-chu-qi-shi-wu/"/>
      <url>/2023/11/24/34-mysql-ji-chu-qi-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1>1、事务简介&nbsp;</h1><p><img alt="" height="305" src="/medias/images/All/53.png" width="614"><img alt="" height="771" src="/medias/images/All/54.png" width="621"></p><blockquote><div><span style="color:#777777;">注意： 默认</span><span style="color:#777777;">MySQL</span><span style="color:#777777;">的事务是自动提交的，也就是说，当执行完一条</span><span style="color:#777777;">DML</span><span style="color:#777777;">语句时，</span><span style="color:#777777;">MySQL</span><span style="color:#777777;">会立即隐式的提交事务。 </span></div></blockquote><h1>2、事务操作</h1><h3>2.1&nbsp;<span style="color:#34495e;"><strong>未控制事务 </strong></span></h3><p>数据准备：</p><pre><code class="language-sql">-- 事务操作drop table if exists account;create table account(    id    int primary key AUTO_INCREMENT comment 'ID',    name  varchar(10) comment '姓名',    money double(10, 2) comment '余额') comment '账户表';insert into account(name, money)VALUES ('张三', 2000),       ('李四', 2000);</code></pre><p><span style="color:#34495e;">1). </span><span style="color:#34495e;">测试正常情况 </span>&nbsp;</p><pre><code class="language-sql">-- 转账操作（张三给李四转账1000）-- 正常场景-- 1. 查询张三账户余额select * from account where name='张三';-- 2. 将张三账户余额-1000update account set money = money-1000 where name = '张三';-- 3. 将李四账户余额+1000update account set money = money +1000 where name = '李四';</code></pre><p>&nbsp;<img alt="" height="175" src="/medias/images/All/55.png" width="400"></p><p><span style="color:#34495e;">2). </span><span style="color:#34495e;">测试异常情况 </span>&nbsp;</p><pre><code class="language-sql">-- 异常场景-- 1. 查询张三账户余额select * from account where name='张三';-- 2. 将张三账户余额-1000update account set money = money-1000 where name = '张三';程序执行报错-- 3. 将李四账户余额+1000update account set money = money +1000 where name = '李四';</code></pre><p><img alt="" height="197" src="/medias/images/All/56.png" width="608"></p><h3>2.2&nbsp;<span style="color:#34495e;"><strong>控制事务一</strong></span></h3><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">查看</span><span style="color:#34495e;">/</span><span style="color:#34495e;">设置事务提交方式</span></div><div></div><blockquote><div><div><span style="color:#770088;">SELECT </span><span style="color:#34495e;">@@autocommit ; </span></div><div></div><div><span style="color:#770088;">SET </span><span style="color:#34495e;">@@autocommit = </span><span style="color:#116644;">0 </span><span style="color:#34495e;">; </span></div></div></blockquote><p><span style="color:#34495e;">2). </span><span style="color:#34495e;">提交事务</span></p><blockquote><p><span style="color:#34495e;">COMMIT;</span></p></blockquote><p>&nbsp;<span style="color:#34495e;">3). </span><span style="color:#34495e;">回滚事务 </span></p><blockquote><p><span style="color:#34495e;">ROLLBACK; </span>&nbsp;</p></blockquote><blockquote><p>&nbsp;<span style="color:#777777;">注意：上述的这种方式，我们是修改了事务的自动提交行为, </span><span style="color:#777777;">把默认的自动提交修改为了手动提 交, </span><span style="color:#777777;">此时我们执行的</span><span style="color:#777777;">DML</span><span style="color:#777777;">语句都不会提交</span><span style="color:#777777;">, </span><span style="color:#777777;">需要手动的执行</span><span style="color:#777777;">commit</span><span style="color:#777777;">进行提交。</span></p></blockquote><h3>&nbsp;2.3 控制事务二</h3><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">开启事务</span></div><div></div><blockquote><div><div><span style="color:#34495e;">START TRANSACTION </span><span style="color:#34495e;">或 </span><span style="color:#770088;">BEGIN </span><span style="color:#34495e;">; </span></div></div></blockquote><p>&nbsp;<span style="color:#34495e;">2). </span><span style="color:#34495e;">提交事务 </span></p><blockquote><div><span style="color:#34495e;">COMMIT; </span></div></blockquote><p>&nbsp;<span style="color:#34495e;">3). </span><span style="color:#34495e;">回滚事务 </span></p><blockquote><div><span style="color:#34495e;">ROLLBACK;</span></div></blockquote><pre><code class="language-sql">-- 控制事务二-- 开启事务set @@autocommit = 1;select @@autocommit;START TRANSACTION; -- 或 BEGIN ;-- 1. 查询张三账户余额select * from account where name='张三';-- 2. 将张三账户余额-1000update account set money = money-1000 where name = '张三';程序执行报错-- 3. 将李四账户余额+1000update account set money = money +1000 where name = '李四';-- 提交事务commit;-- 回滚事务rollback;</code></pre><h1>3、事务四大特性&nbsp;</h1><ul><li><span style="color:#34495e;">原子性（</span><span style="color:#34495e;">Atomicity</span><span style="color:#34495e;">）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </span></li>    <li><span style="color:#34495e;">一致性（</span><span style="color:#34495e;">Consistency</span><span style="color:#34495e;">）：事务完成时，必须使所有的数据都保持一致状态。 </span></li>    <li><span style="color:#34495e;">隔离性（</span><span style="color:#34495e;">Isolation</span><span style="color:#34495e;">）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 </span></li>    <li><span style="color:#34495e;">环境下运行。 </span></li>    <li><span style="color:#34495e;">持久性（</span><span style="color:#34495e;">Durability</span><span style="color:#34495e;">）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 </span></li></ul><div><span style="color:#34495e;">上述就是事务的四大特性，简称</span><span style="color:#34495e;">ACID</span><span style="color:#34495e;">。</span></div><div></div><div><img alt="" height="411" src="/medias/images/All/57.png" width="522"></div><h1>&nbsp;4、并发事务问题</h1><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">赃读：一个事务读到另外一个事务还没有提交的数据。 </span></div><div></div><div><img alt="" height="213" src="/medias/images/All/58.png" width="605"></div><p>&nbsp;<span style="color:#34495e;">2). </span><span style="color:#34495e;">不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</span></p><p><img alt="" height="203" src="/medias/images/All/59.png" width="615"></p><div><span style="color:#34495e;">3). </span><span style="color:#34495e;">幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 "</span><span style="color:#34495e;">幻影</span><span style="color:#34495e;">"</span><span style="color:#34495e;">。</span></div><div></div><div><img alt="" height="139" src="/medias/images/All/60.png" width="601"></div><p></p><h1>&nbsp;5、事务隔离级别</h1><p><img alt="" height="286" src="/medias/images/All/61.png" width="630"></p><p><span style="color:#34495e;">1). </span><span style="color:#34495e;">查看事务隔离级别 </span></p><blockquote><p>&nbsp;<span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">@@TRANSACTION_ISOLATION;</span></p></blockquote><p>&nbsp;<span style="color:#34495e;">2). </span><span style="color:#34495e;">设置事务隔离级别 </span></p><blockquote><div><span style="color:#770088;">SET </span><span style="color:#34495e;">[ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED</span></div><div></div><div><span style="color:#34495e;">| READ COMMITTED | REPEATABLE READ | SERIALIZABLE } </span></div></blockquote><blockquote><p>&nbsp;<span style="color:#777777;">注意：事务隔离级别越高，数据越安全，但是性能越低。 </span></p></blockquote><pre><code class="language-sql">-- 查看事务的隔离级别 select @@transaction_isolation;-- 设置事务的隔离级别-- SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }-- 注意：事务隔离级别越高，数据越安全，但是性能越低。set session transaction isolation level read uncommitted ;</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础（六）多表查询</title>
      <link href="/2023/11/23/33-mysql-ji-chu-liu-duo-biao-cha-xun/"/>
      <url>/2023/11/23/33-mysql-ji-chu-liu-duo-biao-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>版权申明：本文用于个人学习记录，学习课程为黑马程序员的mysql教程。如需获取官方的学习视频和文档资料，请至黑马程序员官方获取。下面附上教学视频的链接地址，向提供免费教学视频的老师致敬，学如逆水行舟，不进则退，共勉</p><p><a data-link-desc="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括共计195条视频，包括：01.MySQL课程介绍、02. 基础-课程内容&amp;数据库相关概念、03. 基础-概述-MySQL安装及启动等，UP主更多精彩视频，请关注UP账号。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db5d28283daae15e6008d16a1b91c557" title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili</a></p><h1>1、多表关系&nbsp;</h1><div><span style="color:#34495e;">项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</span></div><div><ul><li><span style="color:#34495e;">一对多</span><span style="color:#34495e;">(</span><span style="color:#34495e;">多对一</span><span style="color:#34495e;">) </span></li>    <li><span style="color:#34495e;">多对多 </span></li>    <li><span style="color:#34495e;">一对一</span></li></ul></div><h3>1.1 一对多&nbsp;</h3><ul><li><span style="color:#34495e;">案例</span><span style="color:#34495e;">: </span><span style="color:#34495e;">部门 与 员工的关系 </span></li>    <li><span style="color:#34495e;">关系</span><span style="color:#34495e;">: </span><span style="color:#34495e;">一个部门对应多个员工，一个员工对应一个部门 </span></li>    <li><span style="color:#34495e;">实现</span><span style="color:#34495e;">: </span><span style="color:#34495e;">在多的一方建立外键，指向一的一方的主键</span></li></ul><p><img alt="" height="375" src="/medias/images/All/43.png" width="1110"></p><h3>&nbsp;1.2 多对多</h3><ul><li><span style="color:#34495e;">案例</span><span style="color:#34495e;">: </span><span style="color:#34495e;">学生 与 课程的关系 </span></li>    <li><span style="color:#34495e;">关系</span><span style="color:#34495e;">: </span><span style="color:#34495e;">一个学生可以选修多门课程，一门课程也可以供多个学生选择 </span></li>    <li><span style="color:#34495e;">实现</span><span style="color:#34495e;">: </span><span style="color:#34495e;">建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 </span></li></ul><p><img alt="" height="341" src="/medias/images/All/44.png" width="1130">&nbsp;对应的SQL脚本：</p><pre><code class="language-sql">-- 多表查询create table student(    id   int auto_increment primary key comment '主键ID',    name varchar(10) comment '姓名',    no   varchar(10) comment '学号') comment '学生表';insert into studentvalues (null, '黛绮丝', '2000100101'),       (null, '谢逊', '2000100102'),       (null, '殷天正', '2000100103'),       (null, '韦一笑', '2000100104');create table course(    id   int auto_increment primary key comment '主键ID',    name varchar(10) comment '课程名称') comment '课程表';insert into coursevalues (null, 'Java'),       (null, 'PHP'),       (null, 'MySQL'),       (null, 'Hadoop');create table student_course(    id        int auto_increment comment '主键' primary key,    studentid int not null comment '学生ID',    courseid  int not null comment '课程ID',    constraint fk_courseid foreign key (courseid) references course (id),    constraint fk_studentid foreign key (studentid) references student (id)) comment '学生课程中间表';insert into student_course values (null,1,1),(null,1,2),(null,1,3),(null,2,2), (null,2,3),(null,3,4);</code></pre><h3>1.3 一对一&nbsp;</h3><ul><li><span style="color:#34495e;">案例</span><span style="color:#34495e;">: </span><span style="color:#34495e;">用户 与 用户详情的关系 </span></li>    <li><span style="color:#34495e;">关系</span><span style="color:#34495e;">: </span><span style="color:#34495e;">一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另</span><span style="color:#34495e;">一张表中，以提升操作效率 </span></li>    <li><span style="color:#34495e;">实现</span><span style="color:#34495e;">: </span><span style="color:#34495e;">在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的</span><span style="color:#34495e;">(UNIQUE) </span></li></ul><p><img alt="" height="255" src="/medias/images/All/45.png" width="1127"></p><p>对应的SQL：&nbsp;</p><pre><code class="language-sql">create table tb_user(    id     int auto_increment primary key comment '主键ID',    name   varchar(10) comment '姓名',    age    int comment '年龄',    gender char(1) comment '1: 男 , 2: 女',    phone  char(11) comment '手机号') comment '用户基本信息表';create table tb_user_edu(    id            int auto_increment primary key comment '主键ID',    degree        varchar(20) comment '学历',    major         varchar(50) comment '专业',    primaryschool varchar(50) comment '小学',    middleschool  varchar(50) comment '中学',    university    varchar(50) comment '大学',    userid        int unique comment '用户ID',    constraint fk_userid foreign key (userid) references tb_user (id)) comment '用户教育信息表';insert into tb_user(id, name, age, gender, phone)values (null, '黄渤', 45, '1', '18800001111'),       (null, '冰冰', 35, '2', '18800002222'),       (null, '码云', 55, '1', '18800008888'),       (null, '李彦宏', 50, '1', '18800009999');insert into tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid)values (null, '本科', '舞蹈', '静安区第一小学', '静安区第一中学', '北京舞蹈学院', 1),       (null, '硕士', '表演', '朝阳区第一小学', '朝阳区第一中学', '北京电影学院', 2),       (null, '本科', '英语', '杭州市第一小学', '杭州市第一中学', '杭州师范大学', 3),       (null, '本科', '应用数学', '阳泉第一小学', '阳泉区第一中学', '清华大学', 4);</code></pre><h1>2、多表查询概述&nbsp;</h1><h3>2.1 数据准备</h3><pre><code class="language-sql">-- 创建dept表，并插入数据create table dept(    id   int auto_increment comment 'ID' primary key,    name varchar(50) not null comment '部门名称') comment '部门表';INSERT INTO dept (id, name)VALUES (1, '研发部'),       (2, '市场部'),       (3, '财务部'),       (4, '销售部'),       (5, '总经办'),       (6, '人事部');-- 创建emp表，并插入数据create table emp(    id        int auto_increment comment 'ID' primary key,    name      varchar(50) not null comment '姓名',    age       int comment '年龄',    job       varchar(20) comment '职位',    salary    int comment '薪资',    entrydate date comment '入职时间',    managerid int comment '直属领导ID',    dept_id   int comment '部门ID') comment '员工表';-- 添加外键alter table emp    add constraint fk_emp_dept_id foreign key (dept_id) references dept (id);INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)VALUES (1, '金庸', 66, '总裁', 20000, '2000-01-01', null, 5),       (2, '张无忌', 20, '项目经理', 12500, '2005-12-05', 1, 1),       (3, '杨逍', 33, '开发', 8400, '2000-11-03', 2, 1),       (4, '韦一笑', 48, '开发', 11000, '2002-02-05', 2, 1),       (5, '常遇春', 43, '开发', 10500, '2004-09-07', 3, 1),       (6, '小昭', 19, '程序员鼓励师', 6600, '2004-10-12', 2, 1),       (7, '灭绝', 60, '财务总监', 8500, '2002-09-12', 1, 3),       (8, '周芷若', 19, '会计', 48000, '2006-06-02', 7, 3),       (9, '丁敏君', 23, '出纳', 5250, '2009-05-13', 7, 3),       (10, '赵敏', 20, '市场部总监', 12500, '2004-10-12', 1, 2),       (11, '鹿杖客', 56, '职员', 3750, '2006-10-03', 10, 2),       (12, '鹤笔翁', 19, '职员', 3750, '2007-05-09', 10, 2),       (13, '方东白', 19, '职员', 5500, '2009-02-12', 10, 2),       (14, '张三丰', 88, '销售总监', 14000, '2004-10-12', 1, 4),       (15, '俞莲舟', 38, '销售', 4600, '2004-10-12', 14, 4),       (16, '宋远桥', 40, '销售', 4600, '2004-10-12', 14, 4),       (17, '陈友谅', 42, null, 2000, '2011-10-12', 1, null);</code></pre><h3>2.2 概述&nbsp;</h3><div><span style="color:#34495e;">多表查询就是指从多张表中查询数据。</span></div><div><img alt="" height="1200" src="/medias/images/All/46.png" width="705"></div><h3><img alt="" height="511" src="/medias/images/All/47.png" width="912">&nbsp;2.3 分类</h3><ul><li>连接查询    <ul><li>        <div><span style="color:#34495e;">内连接：相当于查询</span><span style="color:#34495e;">A</span><span style="color:#34495e;">、</span><span style="color:#34495e;">B</span><span style="color:#34495e;">交集部分数据 </span></div>        </li>        <li>        <div><span style="color:#34495e;">外连接： </span></div>        </li>        <li>        <div><span style="color:#34495e;">左外连接：查询左表所有数据，以及两张表交集部分数据 </span></div>        </li>        <li>        <div><span style="color:#34495e;">右外连接：查询右表所有数据，以及两张表交集部分数据 </span></div>        </li>        <li>        <div><span style="color:#34495e;">自连接：当前表与自身的连接查询，自连接必须使用表别名</span></div>        </li>    </ul></li>    <li>子查询</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img alt="" height="189" src="/medias/images/All/48.png" width="551"></p><h1>3、内连接&nbsp;</h1><p><img alt="" height="342" src="/medias/images/All/49.png" width="896"></p><h5>1）隐式内连接</h5><blockquote><p><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">1 , </span><span style="color:#34495e;">表</span><span style="color:#34495e;">2&nbsp; &nbsp;</span><span style="color:#770088;">WHERE&nbsp; &nbsp;</span><span style="color:#34495e;">条件 </span><span style="color:#34495e;">... ;</span>&nbsp;</p></blockquote><h5>2）<span style="color:#34495e;">显式内连接</span></h5><blockquote><p><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">1&nbsp; &nbsp;[ INNER ]&nbsp; &nbsp;</span><span style="color:#770088;">JOIN&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">2&nbsp; &nbsp;</span><span style="color:#770088;">ON&nbsp; &nbsp;</span><span style="color:#34495e;">连接条件 </span><span style="color:#34495e;">... ;&nbsp;</span>&nbsp;</p></blockquote><pre><code class="language-sql">-- 内连接演示-- 1. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)-- 表结构：emp，dept-- 连接条件：emp.dept_id = dept.id-- 16条数据，因为有一个员工没有部门信息select emp.name, dept.name from emp, dept where emp.dept_id = dept.id;-- 起别名, 起了别名就只能通过别名.select e.name, d.name from emp e, dept d where e.dept_id = d.id;-- 2. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) --- INNER JOIN ... ON ...-- 表结构：emp，dept-- 连接条件：emp.dept_id = dept.idselect e.name,d.name from emp e inner join dept d on e.dept_id = d.id;-- inner可以省略select e.name,d.name from emp e join dept d on e.dept_id = d.id;</code></pre><blockquote><div><span style="color:#777777;">表的别名</span><span style="color:#777777;">: </span></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①. tablea as </span><span style="color:#777777;">别名</span><span style="color:#777777;">1 , tableb as </span><span style="color:#777777;">别名</span><span style="color:#777777;">2 ; </span></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②. tablea </span><span style="color:#777777;">别名</span><span style="color:#777777;">1 , tableb </span><span style="color:#777777;">别名</span><span style="color:#777777;">2 ; </span></div></blockquote><blockquote><p>注意事项：<span style="color:#777777;">一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</span></p></blockquote><h1>4、外连接&nbsp;</h1><p>&nbsp;<img alt="" height="242" src="/medias/images/All/50.png" width="700"></p><h5>1）左外连接</h5><blockquote><p>&nbsp;<span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">1&nbsp; &nbsp;LEFT&nbsp; &nbsp;[ OUTER ]&nbsp; &nbsp;</span><span style="color:#770088;">JOIN&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">2&nbsp; &nbsp;</span><span style="color:#770088;">ON&nbsp;&nbsp;</span><span style="color:#34495e;">条件 </span><span style="color:#34495e;">... ; </span></p></blockquote><p><span style="color:#34495e;">左外连接相当于查询表</span><span style="color:#34495e;">1(</span><span style="color:#34495e;">左表</span><span style="color:#34495e;">)</span><span style="color:#34495e;">的所有数据，当然也包含表</span><span style="color:#34495e;">1</span><span style="color:#34495e;">和表</span><span style="color:#34495e;">2</span><span style="color:#34495e;">交集部分的数据。 </span></p><h5>2）右外连接&nbsp;</h5><blockquote><p>&nbsp;<span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">1&nbsp; &nbsp;RIGHT&nbsp; &nbsp;[ OUTER ]&nbsp; &nbsp;</span><span style="color:#770088;">JOIN&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">2&nbsp; &nbsp;</span><span style="color:#770088;">ON&nbsp; &nbsp;</span><span style="color:#34495e;">条件 </span><span style="color:#34495e;">... ; </span></p></blockquote><p><span style="color:#34495e;">右外连接相当于查询表</span><span style="color:#34495e;">2(</span><span style="color:#34495e;">右表</span><span style="color:#34495e;">)</span><span style="color:#34495e;">的所有数据，当然也包含表</span><span style="color:#34495e;">1</span><span style="color:#34495e;">和表</span><span style="color:#34495e;">2</span><span style="color:#34495e;">交集部分的数据。</span></p><pre><code class="language-sql">-- 外连接演示-- 1. 查询emp表的所有数据，和对应的部门信息（左外连接）-- 由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。-- 表结构：emp, dept-- 连接条件：emp.dept_id = dept.id-- 17条数据，左外连接会完全包含左表的数据select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;-- outer关键字可以省略select e.*, d.name from emp e left join dept d on e.dept_id = d.id;-- 2. 查询dept表的所有数据，和对应的员工信息（右外连接）-- 由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询-- 右外连接会包含所有右表的数据select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;-- 右外连接也可以改成左外连接select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;</code></pre><blockquote><div><span style="color:#777777;">注意事项： </span></div><div></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL</span><span style="color:#777777;">中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。 </span></div></blockquote><h1>5、自连接</h1><h3>5.1 自连接查询</h3><div><span style="color:#34495e;">自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。我们先来学习一下自连接 的查询语法： </span></div><div></div><blockquote><div><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">A&nbsp; &nbsp;</span><span style="color:#34495e;">别名</span><span style="color:#34495e;">A&nbsp; &nbsp;</span><span style="color:#770088;">JOIN&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">A&nbsp; &nbsp;</span><span style="color:#34495e;">别名</span><span style="color:#34495e;">B </span><span style="color:#770088;">ON </span><span style="color:#34495e;">条件 </span><span style="color:#34495e;">... ;</span></div></blockquote><p><span style="color:#34495e;">而对于自连接查询，可以是内连接查询，也可以是外连接查询。</span></p><pre><code class="language-sql">-- 自连接-- 1. 查询员工及其所属领导的名字-- 表结构：emp-- 16条数据select a.name, b.name from emp a, emp b where a.managerid = b.id;-- 2. 查询所有员工emp及其领导的名字emp，如果员工没有领导，也需要查询出来-- 17条数据select a.name, b.name from emp a left join emp b on a.managerid = b.id;select a.name '员工', b.name '领导' from emp a left join emp b on a.managerid = b.id;</code></pre><blockquote><div><span style="color:#777777;">注意事项</span><span style="color:#777777;">: </span></div><div></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。</span></div></blockquote><h3>&nbsp;5.2 联合查询</h3><p>&nbsp;<span style="color:#34495e;">对于</span><span style="color:#34495e;">union</span><span style="color:#34495e;">查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</span></p><blockquote><p></p><div><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">A ... </span></div><div><span style="color:#770088;">UNION&nbsp; &nbsp;</span><span style="color:#34495e;">[ ALL ] </span></div><div><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表</span><span style="color:#34495e;">B ....; </span></div></blockquote><ul><li><span style="color:#34495e;">对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。 </span></li>    <li><span style="color:#34495e;">union all </span><span style="color:#34495e;">会将全部的数据直接合并在一起，</span><span style="color:#34495e;">union </span><span style="color:#34495e;">会对合并之后的数据去重。</span></li></ul><pre><code class="language-sql">-- 联合查询-- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。-- union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。-- union all, union-- 1. 将薪资低于5000的员工，和年龄大于50岁的员工全部查询出来-- 会有重复数据select * from  emp where salary &lt; 5000union allselect * from emp where age &gt; 50;</code><p><code class="language-sql">– 去重<br>select * from  emp where salary &lt; 5000<br>union<br>select * from emp where age &gt; 50;<br>– select * from emp where salary &lt; 5000 || emp.age &gt; 50;</code></p></pre><p></p><p><img alt="" height="382" src="/medias/images/All/51.png" width="919"></p><h1>6、子查询</h1><h3>6.1 概述</h3><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">概念</span></div><div></div><div><span style="color:#34495e;">SQL</span><span style="color:#34495e;">语句中嵌套</span><span style="color:#34495e;">SELECT</span><span style="color:#34495e;">语句，称为嵌套查询，又称子查询。</span></div><div></div><blockquote><div><span style="color:#770088;">SELECT&nbsp;&nbsp;</span><span style="color:#34495e;">*&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">t1&nbsp; &nbsp;</span><span style="color:#770088;">WHERE&nbsp; &nbsp;</span><span style="color:#34495e;">column1 = ( </span><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">column1&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">t2 ); </span></div></blockquote><p><span style="color:#34495e;">子查询外部的语句可以是</span><span style="color:#34495e;">INSERT / UPDATE / DELETE / SELECT </span><span style="color:#34495e;">的任何一个。</span>&nbsp;</p><div><span style="color:#34495e;">2). </span><span style="color:#34495e;">分类</span></div><div></div><div><div><span style="color:#34495e;">根据子查询结果不同，分为： </span></div><ol><li><span style="color:#34495e;">&nbsp;</span><span style="color:#34495e;">标量子查询（子查询结果为单个值） </span></li>    <li><span style="color:#34495e;">&nbsp;</span><span style="color:#34495e;">列子查询</span><span style="color:#34495e;">(</span><span style="color:#34495e;">子查询结果为一列</span><span style="color:#34495e;">) </span></li>    <li><span style="color:#34495e;">&nbsp;行子查询</span><span style="color:#34495e;">(</span><span style="color:#34495e;">子查询结果为一行</span><span style="color:#34495e;">) </span></li>    <li><span style="color:#34495e;">&nbsp;表子查询</span><span style="color:#34495e;">(</span><span style="color:#34495e;">子查询结果为多行多列</span><span style="color:#34495e;">)</span></li></ol></div><div><span style="color:#34495e;">根据子查询位置，分为： </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A. WHERE之后 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B. FROM之后 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C. SELECT之后 </span></div><div></div><h3>&nbsp;6.2&nbsp;<span style="color:#34495e;"><strong>标量子查询 </strong></span></h3><div><span style="color:#34495e;">子查询返回的结果是单个值（数字、字符串、日期等）最简单的形式，这种子查询称为标量子查询</span></div><div><span style="color:#34495e;">常用的操作符：</span><span style="color:#34495e;">= &lt;&gt; &gt; &gt;= &lt; &lt;= </span></div><div><pre><code class="language-sql">-- 子查询-- 标量子查询-- 子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。-- 常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;=-- 1. 查询“销售部”的所有员工信息--  a. 查询“销售部”部门IDselect id from dept where name = '销售部';--  b. 根据销售部部门ID，查询员工信息select * from emp where dept_id = 4;-- 用一条sql子查询搞定select * from emp where dept_id = (select id from dept where name = '销售部');</code><p><code class="language-sql">– 2. 查询在“方东白”入职之后的员工信息<br>–  a. 查询方东白的入职日期<br>select entrydate from emp where name = ‘方东白’;<br>–  b. 根据方东白的入职日期，查询在“方东白”入职之后的员工信息<br>select * from emp where entrydate &gt; ‘2009-02-12’;<br>– 合并<br>select * from emp where entrydate &gt; (select entrydate from emp where name = ‘方东白’);</code></p></pre><p></p><h3>6.3 列子查询</h3><div><span style="color:#34495e;">子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。 </span></div><div></div><div><div><span style="color:#34495e;">常用的操作符：</span><span style="color:#34495e;">IN </span><span style="color:#34495e;">、</span><span style="color:#34495e;">NOT IN </span><span style="color:#34495e;">、 </span><span style="color:#34495e;">ANY </span><span style="color:#34495e;">、</span><span style="color:#34495e;">SOME </span><span style="color:#34495e;">、 </span><span style="color:#34495e;">ALL </span></div><div></div><div><img alt="" height="433" src="/medias/images/All/52.png" width="910"></div></div></div><pre><code class="language-sql">-- 列子查询-- 子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。-- 常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL-- 1. 查询“销售部”和“市场部”的所有员工信息--  a. 查询“销售部”和“市场部”的部门IDselect id from dept where name = '销售部' or name = '市场部';--  b. 根据部门ID，查询员工信息select * from emp where dept_id = 2 or dept_id = 4;-- 合并select * from emp where dept_id in (select id from dept where name = '销售部' or name = '市场部');-- 2. 查询比财务部所有人工资都高的员工信息--  a. 查询所有财务部的人员工资select salary from emp where dept_id = (select id from dept where name = '财务部');--  b. 比财务部所有人工资都高的员工信息select * from emp where salary &gt; all (select salary from emp where dept_id = (select id from dept where name = '财务部'));-- 3. 查询比研发部其中任意一人工资高的员工信息--  a. 查询研发部所有人工资select salary from emp where dept_id = (select id from dept where name = '研发部');--  b. 比研发部任意一人工资高的员工信息select * from emp where salary &gt; any (select salary from emp where dept_id = (select id from dept where name = '研发部'));-- any\some 一个满足条件就行select * from emp where salary &gt; some (select salary from emp where dept_id = (select id from dept where name = '研发部'));</code></pre><h3>6.4 行子查询&nbsp;</h3><p><span style="color:#34495e;">子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。 </span></p><div><span style="color:#34495e;">常用的操作符：</span><span style="color:#34495e;">= </span><span style="color:#34495e;">、</span><span style="color:#34495e;">&lt;&gt; </span><span style="color:#34495e;">、</span><span style="color:#34495e;">IN </span><span style="color:#34495e;">、</span><span style="color:#34495e;">NOT IN </span></div><div></div><pre><code class="language-sql">-- 行子查询-- 子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。-- 常用的操作符：= 、&lt;&gt; 、IN 、NOT IN-- 1. 查询与 "张无忌" 的薪资及直属领导相同的员工信息--  a. 查询"张无忌"的薪资及直属领导select salary, managerid from emp where name = '张无忌';--  b. 查询与 "张无忌" 的薪资及直属领导相同的员工信息select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');</code></pre><h3>6.5 表子查询&nbsp;</h3><div><span style="color:#34495e;">子查询返回的结果是多行多列，这种子查询称为表子查询。</span></div><div></div><div><span style="color:#34495e;">常用的操作符：</span><span style="color:#34495e;">IN </span></div><div></div><div><pre><code class="language-sql">-- 表子查询-- 子查询返回的结果是多行多列，这种子查询称为表子查询。-- 常用的操作符：IN-- 1. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息--  a. 查询 "鹿杖客" , "宋远桥" 的职位和薪资select job, salary from emp where name = '鹿杖客' || name = '宋远桥';--  b. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息select * from emp where (job,salary) in (select job, salary from emp where name = '鹿杖客' || name = '宋远桥');</code><p><code class="language-sql">– 2. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息<br>–  a. 入职日期是 “2006-01-01” 之后的员工信息<br>select * from emp where entrydate &gt; ‘2006-01-01’;<br>–  b. 查询这部分员工, 对应的部门信息;<br>select e.<em>, d.</em> from (select * from emp where entrydate &gt; ‘2006-01-01’) e left join dept d on e.dept_id = d.id;</code></p></pre><p></p><h1>7、多表查询案例</h1><div><span style="color:#34495e;">数据环境准备</span><span style="color:#34495e;">:</span></div><div></div><div><pre><code class="language-sql">-- 多表查询案例-- 准备工作，创建薪资等级表，并且插入数据create table salgrade(    grade int,    losal int,    hisal int) comment '薪资等级表';insert into salgrade values (1,0,3000);insert into salgrade values (2,3001,5000);insert into salgrade values (3,5001,8000);insert into salgrade values (4,8001,10000);insert into salgrade values (5,10001,15000);insert into salgrade values (6,15001,20000);insert into salgrade values (7,20001,25000);insert into salgrade values (8,25001,30000);</code></pre><pre><code class="language-sql">-- 1. 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）-- 表: emp , dept-- 连接条件 : emp.dept_id = dept.idselect e.name, e.age, e.salary, d.* from emp e, dept d where e.dept_id = d.id;-- 2. 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）-- 表: emp , dept-- 连接条件 : emp.dept_id = dept.idselect e.name, e.age, e.salary, d.* from emp e join dept d on d.id = e.dept_id where e.age &lt; 30;-- 3. 查询拥有员工的部门ID、部门名称-- 表: emp , dept-- 连接条件 : emp.dept_id = dept.id-- distinct 对查询结果去重select distinct d.id, d.name from emp e, dept d where e.dept_id = d.id;-- 4. 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)-- 表: emp , dept-- 连接条件 : emp.dept_id = dept.id-- 外连接select e.*, d.name from emp e left outer join dept d on d.id = e.dept_id where e.age &gt; 40;-- 5. 查询所有员工的工资等级-- 表: emp , salgrade-- 连接条件：emp.salary &gt;= salgrade.losal and emp.salary &lt;= salgrade.hisalselect e.*, s.grade, s.losal, s.hisal from emp e, salgrade s where e.salary &gt;= s.losal &amp;&amp; e.salary &lt;= s.hisal;-- 另一种写法select e.*, s.grade, s.losal, s.hisal from emp e, salgrade s where e.salary between s.losal and s.hisal;-- 6. 查询 "研发部" 所有员工的信息及 工资等级-- 表: emp , salgrade , dept-- 连接条件 : emp.salary between salgrade.losal and salgrade.hisal ,-- emp.dept_id = dept.id-- 查询条件 : dept.name = '研发部'select e.*, s.gradefrom emp e,     dept d,     salgrade swhere (e.salary between s.losal and s.hisal and e.dept_id = d.id)  and d.name = '研发部';-- 7. 查询 "研发部" 员工的平均工资-- 表: emp , dept-- 连接条件 : emp.dept_id = dept.idselect avg(e.salary) from emp e, dept d where e.dept_id = d.id and d.name = '研发部';-- 8. 查询工资比 "灭绝" 高的员工信息-- select salary from emp e where e.name = '灭绝';select * from emp where salary &gt; (select salary from emp e where e.name = '灭绝');-- 9. 查询比平均薪资高的员工信息-- select avg(salary) from emp;select * from emp where salary &gt; (select avg(salary) from emp);-- 10.查询低于本部门平均工资的员工信息select avg(salary) from emp where dept_id = 1;select avg(salary) from emp where dept_id = 2;select * from emp e where salary &lt; (select avg(salary) from emp where dept_id = e.dept_id);-- 11. 查询所有的部门信息, 并统计部门的员工人数-- select count(*) from emp where dept_id = 1;select d.id, d.name, (select count(*) from emp e where e.dept_id = d.id) '人数' from dept d;-- 12. 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称-- 表: student , course , student_course-- 连接条件: student.id = student_course.studentid , course.id = student_course.courseidselect s.name,s.no,c.name from student s, student_course sc, course c where s.id = sc.studentid and sc.courseid = c.id;</code></pre></div></div>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础（五）约束</title>
      <link href="/2023/11/20/32-mysql-ji-chu-wu-yue-shu/"/>
      <url>/2023/11/20/32-mysql-ji-chu-wu-yue-shu/</url>
      
        <content type="html"><![CDATA[<p>版权申明：本文用于个人学习记录，学习课程为黑马程序员的mysql教程。如需获取官方的学习视频和文档资料，请至黑马程序员官方获取。下面附上教学视频的链接地址，向提供免费教学视频的老师致敬，学如逆水行舟，不进则退，共勉</p><p><a data-link-desc="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括共计195条视频，包括：01.MySQL课程介绍、02. 基础-课程内容&amp;数据库相关概念、03. 基础-概述-MySQL安装及启动等，UP主更多精彩视频，请关注UP账号。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db5d28283daae15e6008d16a1b91c557" title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili</a></p><h1>1、概述</h1><div><span style="color:#34495e;">概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</span></div><div></div><div></div><div><span style="color:#34495e;">目的：保证数据库中数据的正确、有效性和完整性。 </span></div><div></div><div><img alt="" height="600" src="/medias/images/All/34.png" width="778"></div><h1>2、演示</h1><p><img alt="" height="533" src="/medias/images/All/35.png" width="772">&nbsp;<span style="color:#34495e;">对应的建表语句为：</span></p><pre><code class="language-sql">CREATE TABLE user(    id     int AUTO_INCREMENT PRIMARY KEY COMMENT 'ID唯一标识',    name   varchar(10) NOT NULL UNIQUE COMMENT '姓名',    age    int check (age &gt; 0 &amp;&amp; age &lt;= 120) COMMENT '年龄',    status char(1) default '1' COMMENT '状态',    gender char(1) COMMENT '性别') comment '用户表';</code></pre><pre><code class="language-sql">insert into user(name, age, status, gender) values ('Tom1', 19, '1', '男'),('Tom2', 25, '0', '男');insert into user(name, age, status, gender) values ('Tom3', 19, '1', '男');select * from user;-- name 有非空约束not null-- 执行报错，[23000][1048] Column 'name' cannot be nullinsert into user(name, age, status, gender) values (null, 19, '1', '男');-- name 有唯一约束UNIQUE-- 执行报错，[23000][1062] Duplicate entry 'Tom3' for key 'user.name'insert into user(name, age, status, gender) values ('Tom3', 19, '1', '男');insert into user(name, age, status, gender) values ('Tom4', 80, '1', '男');-- age有检查约束，check条件为大于0小于120-- 执行报错，[HY000][3819] Check constraint 'user_chk_1' is violated.insert into user(name, age, status, gender) values ('Tom5', -1, '1', '男');-- 执行报错，[HY000][3819] Check constraint 'user_chk_1' is violated.insert into user(name, age, status, gender) values ('Tom5', 121, '1', '男');-- status有默认约束，default为1insert into user(name, age, gender) values ('Tom5', 120, '男');</code></pre><p>&nbsp;图形化界面创建约束：</p><p><img alt="" height="552" src="/medias/images/All/36.png" width="766"></p><h1>3、外键约束</h1><p>&nbsp;<img alt="" height="637" src="/medias/images/All/37.png" width="776"></p><pre><code class="language-sql">create table dept(    id   int auto_increment comment 'ID' primary key,    name varchar(50) not null comment '部门名称') comment '部门表';INSERT INTO dept (id, name) VALUES (1, '研发部'),(2, '市场部'),(3, '财务部'),(4, '销售部'),(5, '总经办');create table emp(    id int auto_increment comment 'ID' primary key,    name varchar(50) not null comment '姓名',    age int comment '年龄',    job varchar(20) comment '职位',    salary int comment '薪资',    entrydate date comment '入职时间',    managerid int comment '直属领导ID',    dept_id int comment '部门ID') comment '员工表';INSERT INTO    emp(id, name, age, job,salary, entrydate, managerid, dept_id)VALUES(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),(4, '韦一笑', 48, '开 发',11000, '2002-02-05', 2,1),(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),(6, '小昭', 19, '程 序员鼓励师',6600, '2004-10-12', 2,1);</code></pre><h2>1）添加外键</h2><blockquote><div><span style="color:#770088;">ALTER&nbsp; &nbsp;TABLE&nbsp; &nbsp;</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#34495e;">ADD&nbsp; &nbsp;CONSTRAINT&nbsp; &nbsp;</span><span style="color:#34495e;">外键名称&nbsp; &nbsp;</span><span style="color:#34495e;">FOREIGN KEY (</span><span style="color:#34495e;">外键字段名</span><span style="color:#34495e;">) </span></div><div><span style="color:#34495e;">REFERENCES&nbsp; &nbsp;</span><span style="color:#34495e;">主表 </span><span style="color:#34495e;">(</span><span style="color:#34495e;">主表列名</span><span style="color:#34495e;">) ;</span></div></blockquote><pre><code class="language-sql">-- 添加外键-- 为emp表的dept_id字段添加外键约束,关联dept表的主键id。alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);</code></pre><div><span style="color:#34495e;">添加了外键约束之后，我们再到</span><span style="color:#34495e;">dept</span><span style="color:#34495e;">表</span><span style="color:#34495e;">(</span><span style="color:#34495e;">父表</span><span style="color:#34495e;">)</span><span style="color:#34495e;">删除</span><span style="color:#34495e;">id</span><span style="color:#34495e;">为</span><span style="color:#34495e;">1</span><span style="color:#34495e;">的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。 </span></div><p><img alt="" height="547" src="/medias/images/All/38.jpeg" width="1200"></p><h2>&nbsp;2）<span style="color:#34495e;">删除外键</span></h2><blockquote><p>&nbsp;<span style="color:#770088;">ALTER&nbsp; TABLE&nbsp;&nbsp;</span><span style="color:#34495e;">表名&nbsp;&nbsp;</span><span style="color:#770088;">DROP&nbsp;&nbsp;</span><span style="color:#34495e;">FOREIGN KEY&nbsp;&nbsp;</span><span style="color:#34495e;">外键名称</span><span style="color:#34495e;">; </span></p></blockquote><pre><code class="language-sql">-- 删除外键-- 删除emp表的外键fk_emp_dept_id。alter table emp drop foreign key fk_emp_dept_id;</code></pre><h2>&nbsp;3）删除/更新行为</h2><p><img alt="" height="607" src="/medias/images/All/39.png" width="783"></p><p>具体语法为：</p><blockquote><p>&nbsp;<span style="color:#770088;">ALTER&nbsp; &nbsp;TABLE&nbsp; &nbsp;</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#34495e;">ADD&nbsp; &nbsp;CONSTRAINT&nbsp; &nbsp;</span><span style="color:#34495e;">外键名称&nbsp; &nbsp;</span><span style="color:#34495e;">FOREIGN KEY (</span><span style="color:#34495e;">外键字段</span><span style="color:#34495e;">) REFERENCES&nbsp; 主表名 (</span><span style="color:#34495e;">主表字段名</span><span style="color:#34495e;">)&nbsp;&nbsp;</span><span style="color:#770088;">ON UPDATE </span><span style="color:#34495e;">CASCADE </span><span style="color:#770088;">ON DELETE </span><span style="color:#34495e;">CASCADE; </span></p></blockquote><pre><code class="language-sql">-- 外键的删除和更新行为-- cascade: 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。alter table emp add constraint  fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade;-- SET NULL: 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。alter table emp add constraint  fk_emp_dept_id foreign key (dept_id) references dept(id) on update SET NULL on delete SET NULL;</code></pre><p><img alt="" height="779" src="/medias/images/All/40.png" width="794">&nbsp;<img alt="" height="345" src="/medias/images/All/41.png" width="774"></p><p>&nbsp;<img alt="" height="589" src="/medias/images/All/42.png" width="801"></p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础（四）函数</title>
      <link href="/2023/11/20/31-mysql-ji-chu-si-han-shu/"/>
      <url>/2023/11/20/31-mysql-ji-chu-si-han-shu/</url>
      
        <content type="html"><![CDATA[<p>版权申明：本文用于个人学习记录，学习课程为黑马程序员的mysql教程。如需获取官方的学习视频和文档资料，请至黑马程序员官方获取。下面附上教学视频的链接地址，向提供免费教学视频的老师致敬，学如逆水行舟，不进则退，共勉</p><p><a data-link-desc="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括共计195条视频，包括：01.MySQL课程介绍、02. 基础-课程内容&amp;数据库相关概念、03. 基础-概述-MySQL安装及启动等，UP主更多精彩视频，请关注UP账号。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db5d28283daae15e6008d16a1b91c557" title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili</a></p><h1>1、字符串函数</h1><div><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">中内置了很多字符串函数，常用的几个如下：</span></div><div></div><div><img alt="" height="412" src="/medias/images/All/29.png" width="605"></div><p></p><pre><code class="language-sql">#---------------函数------------------ concat : 字符串拼接select concat('Hello' , ' MySQL'); # Hello MySQL-- lower : 全部转小写select lower('Hello'); # hello-- upper : 全部转大写select upper('Hello'); # HELLO-- lpad : 左填充select lpad('01', 5, '-'); # ---05-- rpad : 右填充select rpad('01', 5, '-'); # 01--- -- trim : 去除空格select trim(' Hello MySQL '); # Hello MySQL-- substring : 截取子字符串select substring('Hello MySQL',1,5); # Hello-- select substring('Hello MySQL',1,7);  Hello M</code></pre><p><img alt="" height="768" src="/medias/images/All/30.png" width="621"></p><h1>&nbsp;2、数值函数</h1><div><span style="color:#34495e;">常见的数值函数如下：</span></div><div></div><div><img alt="" height="294" src="/medias/images/All/31.png" width="605"></div><pre><code class="language-sql"># 数值函数-- ceil：向上取整select ceil(1.1); # 2-- floor：向下取整select floor(1.9);  # 1-- mod：取模select mod(7,4); # 3select mod(7,2); # 1-- rand：获取随机数 0-1之间select rand();-- round：四舍五入select round(2.344,2); # 2.34-- 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，-- 所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0select lpad(round(rand()*1000000 , 0), 6, '0');</code></pre><h1>&nbsp;3、日期函数</h1><div><span style="color:#34495e;">常见的日期函数如下：</span></div><div></div><div><img alt="" height="474" src="/medias/images/All/32.png" width="609"></div><pre><code class="language-sql">#日期函数-- curdate：当前日期select curdate();-- curtime：当前时间select curtime();-- now：当前日期和时间select now();-- YEAR , MONTH , DAY：当前年、月、日select YEAR(now());select MONTH(now());select DAY(now());-- date_add：增加指定的时间间隔select date_add(now(), INTERVAL 70 YEAR );-- datediff：获取两个日期相差的天数select datediff('2021-10-01', '2021-12-01');-- 案例-- 查询所有员工的入职天数，并根据入职天数倒序排序。-- 思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。select name, datediff(curdate(), entrydate) as 'entrydays' from emp order by entrydays desc;</code></pre><h1>&nbsp;4、流程函数</h1><p>&nbsp;<span style="color:#34495e;">流程函数也是很常用的一类函数，可以在</span><span style="color:#34495e;">SQL</span><span style="color:#34495e;">语句中实现条件筛选，从而提高语句的效率。</span></p><p>&nbsp;<img alt="" height="369" src="/medias/images/All/33.png" width="610"></p><pre><code class="language-sql">-- 案例-- 查询所有员工的入职天数，并根据入职天数倒序排序。-- 思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。select name, datediff(curdate(), entrydate) as 'entrydays' from emp order by entrydays desc;#流程函数-- ifselect if(false, 'Ok', 'Error');-- ifnullselect ifnull('Ok','Default');select ifnull('','Default');select ifnull(null,'Default');-- case when then else end-- 需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----&gt; 一线城市 , 其他 ----&gt; 二线城市)select name, ( case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end ) as '工作地址' from emp;-- 案例-- 创建表create table score(    id int comment 'ID',    name varchar(20) comment '姓名',    math int comment '数学',    english int comment '英语',    chinese int comment '语文') comment '学员成绩表';-- 插入数据insert into score(id, name, math, english, chinese) VALUES (1, 'Tom', 67, 88, 95 ), (2, 'Rose' , 23, 66, 90),(3, 'Jack', 56, 98, 76);-- 查询id，name，合各学科的等级select id, name,       (case when math &gt;= 85 then '优秀' when math &gt;=60 then '及格' else '不及格' end ) '数学',       (case when english &gt;= 85 then '优秀' when english &gt;=60 then '及格' else '不及格' end ) '英语',       (case when chinese &gt;= 85 then '优秀' when chinese &gt;=60 then '及格' else '不及格' end ) '语文' from score;</code></pre><p></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础（三）DCL</title>
      <link href="/2023/11/20/30-mysql-ji-chu-san-dcl/"/>
      <url>/2023/11/20/30-mysql-ji-chu-san-dcl/</url>
      
        <content type="html"><![CDATA[<div>版权申明：本文用于个人学习记录，学习课程为黑马程序员的mysql教程。如需获取官方的学习视频和文档资料，请至黑马程序员官方获取。下面附上教学视频的链接地址，向提供免费教学视频的老师致敬，学如逆水行舟，不进则退，共勉</div><div><a data-link-desc="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括共计195条视频，包括：01.MySQL课程介绍、02. 基础-课程内容&amp;数据库相关概念、03. 基础-概述-MySQL安装及启动等，UP主更多精彩视频，请关注UP账号。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db5d28283daae15e6008d16a1b91c557" title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili</a></div><div><hr><p><span style="color:#34495e;">DCL英文全称是</span><span style="color:#34495e;"><strong>Data Control Language</strong></span><span style="color:#34495e;">(</span><span style="color:#34495e;">数据控制语言</span><span style="color:#34495e;">)</span><span style="color:#34495e;">，用来管理数据库用户、控制数据库的访 </span></p></div><div><span style="color:#34495e;">问权限。 </span></div><p></p><p><img alt="" height="556" src="/medias/images/All/26.png" width="1200"></p><h1>1、管理用户</h1><h4>1）查询用户</h4><pre><code class="language-sql">select * from mysql.user;</code></pre><p>&nbsp;<span style="color:#34495e;">查询的结果如下</span><span style="color:#34495e;">: </span></p><p><img alt="" height="221" src="/medias/images/All/27.png" width="1200"></p><p>&nbsp;<span style="color:#34495e;">其中 Host</span><span style="color:#34495e;">代表当前用户访问的主机</span><span style="color:#34495e;">, </span><span style="color:#34495e;">如果为</span><span style="color:#34495e;">localhost, </span><span style="color:#34495e;">仅代表只能够在当前本机访问，是不可以远程访问的。 User</span><span style="color:#34495e;">代表的是访问该数据库的用户名。在</span><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">中需要通过</span><span style="color:#34495e;">Host</span><span style="color:#34495e;">和</span><span style="color:#34495e;">User</span><span style="color:#34495e;">来唯一标识一 个用户。</span></p><h4>&nbsp;<span style="color:#34495e;">2）</span><span style="color:#34495e;">创建用户 </span></h4><blockquote><p><span style="color:#770088;">CREATE&nbsp;&nbsp;</span><span style="color:#34495e;">USER&nbsp;&nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">用户名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">@</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">主机名</span><span style="color:#22a2c9;">'&nbsp; &nbsp;</span><span style="color:#34495e;">IDENTIFIED&nbsp;&nbsp;</span><span style="color:#770088;">BY&nbsp;&nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">密码</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">;</span></p></blockquote><pre><code class="language-sql">-- 创建用户itcast，只能够在当前主机localhost访问，密码123456create user 'itcast'@'localhost' identified by '123456';-- 创建用户heima，可以在任意主机访问该数据库，密码123456create user 'heima'@'%' identified by '123456';</code></pre><h4>&nbsp;<span style="color:#34495e;">3）</span><span style="color:#34495e;">修改用户密码 </span></h4><blockquote><p><span style="color:#770088;">ALTER&nbsp;&nbsp;</span><span style="color:#34495e;">USER&nbsp;&nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">用户名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">@</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">主机名</span><span style="color:#22a2c9;">'&nbsp;&nbsp;</span><span style="color:#34495e;">IDENTIFIED WITH mysql_native_password </span><span style="color:#770088;">BY </span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">新密码</span><span style="color:#22a2c9;">' </span><span style="color:#34495e;">;</span></p></blockquote><pre><code class="language-sql">-- 修改用户 heima 的访问密码为1234alter user 'heima'@'%' identified with mysql_native_password by '1234';</code></pre><h4>&nbsp;<span style="color:#34495e;">4）</span><span style="color:#34495e;">删除用户 </span></h4><blockquote><p><span style="color:#770088;">DROP&nbsp;&nbsp;</span><span style="color:#34495e;">USER&nbsp;&nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">用户名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">@</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">主机名</span><span style="color:#22a2c9;">' </span><span style="color:#34495e;">;</span></p></blockquote><pre><code class="language-sql">-- 删除itcast@localhost用户drop user 'itcast'@'localhost';</code></pre><h4>&nbsp;注意事项：</h4><blockquote><ul><li><span style="color:#777777;">在</span><span style="color:#777777;">MySQL</span><span style="color:#777777;">中需要通过用户名</span><span style="color:#777777;">@</span><span style="color:#777777;">主机名的方式，来唯一标识一个用户。</span></li></ul><div><ul><li><span style="color:#777777;">主机名可以使用 </span><span style="color:#777777;">% </span><span style="color:#777777;">通配。</span></li></ul><div><ul><li><span style="color:#777777;">这类</span><span style="color:#777777;">SQL</span><span style="color:#777777;">开发人员操作的比较少，主要是</span><span style="color:#777777;">DBA</span><span style="color:#777777;">（ Database Administrator 数据库管理员）使用。 </span></li></ul></div></div></blockquote><h1>2、权限控制</h1><div><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">中定义了很多种权限，但是常用的就以下几种：</span></div><div></div><div><img alt="" height="582" src="/medias/images/All/28.png" width="913"></div><p></p><p><span style="color:#34495e;">上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考</span><span style="color:#42b983;"><strong><a class="link-info" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="官方文档" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></strong></span><span style="color:#34495e;">。</span></p><h4><span style="color:#34495e;">1）</span><span style="color:#34495e;">查询权限</span>&nbsp;</h4><blockquote><div><span style="color:#34495e;">SHOW&nbsp; &nbsp;GRANTS&nbsp; &nbsp;FOR&nbsp; &nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">用户名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">@</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">主机名</span><span style="color:#22a2c9;">' </span><span style="color:#34495e;">; </span></div></blockquote><pre><code class="language-sql">-- 查询 'heima'@'%' 用户的权限show grants for 'heima'@'%';</code></pre><h4><span style="color:#34495e;">2）</span><span style="color:#34495e;">授予权限 </span></h4><blockquote><div><div><span style="color:#34495e;">GRANT&nbsp; &nbsp;</span><span style="color:#34495e;">权限列表&nbsp; &nbsp;</span><span style="color:#770088;">ON&nbsp; &nbsp;</span><span style="color:#34495e;">数据库名</span><span style="color:#34495e;">.</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#34495e;">TO&nbsp; &nbsp;&nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">用户名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">@</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">主机名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">; </span></div></div></blockquote><pre><code class="language-sql">-- 授予 'heima'@'%' 用户itcast数据库所有表的所有操作权限grant all on itcast.* to 'heima'@'%';</code></pre><div><h4><span style="color:#34495e;">3）</span><span style="color:#34495e;">撤销权限 </span></h4><blockquote><div><span style="color:#34495e;">REVOKE&nbsp; &nbsp;</span><span style="color:#34495e;">权限列表&nbsp; &nbsp;</span><span style="color:#770088;">ON&nbsp; &nbsp;</span><span style="color:#34495e;">数据库名</span><span style="color:#34495e;">.</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">用户名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">@</span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">主机名</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">; </span></div></blockquote></div><pre><code class="language-sql">-- 撤销 'heima'@'%' 用户的itcast数据库的所有权限revoke all on itcast.* from 'heima'@'%';</code></pre><h4>注意事项：</h4><blockquote><ul><li><span style="color:#777777;">多个权限之间，使用逗号分隔 </span></li>    <li><span style="color:#777777;">授权时， 数据库名和表名可以使用 </span><span style="color:#777777;">* </span><span style="color:#777777;">进行通配，代表所有。 </span></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础（二）分组查询、排序查询、分页查询</title>
      <link href="/2023/11/20/29-mysql-ji-chu-er-fen-zu-cha-xun-pai-xu-cha-xun-fen-ye-cha-xun/"/>
      <url>/2023/11/20/29-mysql-ji-chu-er-fen-zu-cha-xun-pai-xu-cha-xun-fen-ye-cha-xun/</url>
      
        <content type="html"><![CDATA[<p>版权申明：本文用于个人学习记录，学习课程为黑马程序员的mysql教程。如需获取官方的学习视频和文档资料，请至黑马程序员官方获取。下面附上教学视频的链接地址，向提供免费教学视频的老师致敬，学如逆水行舟，不进则退，共勉<a data-link-desc="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括共计195条视频，包括：01.MySQL课程介绍、02. 基础-课程内容&amp;数据库相关概念、03. 基础-概述-MySQL安装及启动等，UP主更多精彩视频，请关注UP账号。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?vd_source=db5d28283daae15e6008d16a1b91c557" title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili</a></p><h1>1、分组查询</h1><h3>1）&nbsp;语法&nbsp;</h3><blockquote><div><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#34495e;">[ </span><span style="color:#770088;">WHERE </span><span style="color:#34495e;">条件 </span><span style="color:#34495e;">]&nbsp; &nbsp;</span><span style="color:#770088;">GROUP BY&nbsp; &nbsp;</span><span style="color:#34495e;">分组字段名&nbsp; &nbsp;</span><span style="color:#34495e;">[ </span><span style="color:#770088;">HAVING </span><span style="color:#34495e;">分组后过滤条件 ]; </span></div></blockquote><h3>2）&nbsp;where与having区别</h3><blockquote><ul><li><span style="color:#34495e;">执行时机不同：</span><span style="color:#34495e;">where</span><span style="color:#34495e;">是分组之前进行过滤，不满足</span><span style="color:#34495e;">where</span><span style="color:#34495e;">条件，不参与分组；而</span><span style="color:#34495e;">having</span><span style="color:#34495e;">是分组</span><span style="color:#34495e;">之后对结果进行过滤。 </span></li>    <li><span style="color:#34495e;">判断条件不同：</span><span style="color:#34495e;">where</span><span style="color:#34495e;">不能对聚合函数进行判断，而</span><span style="color:#34495e;">having</span><span style="color:#34495e;">可以。</span></li></ul></blockquote><blockquote><div><span style="color:#0d0016;"><strong>注意事项: </strong></span></div><ul><li><span style="color:#0d0016;">分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。 </span></li>    <li><span style="color:#0d0016;">执行顺序: where &gt; 聚合函数 &gt; having 。 </span></li>    <li><span style="color:#0d0016;">支持多字段分组, 具体语法为 : group by columnA,columnB </span></li></ul></blockquote><h3>3） 案例：</h3><pre><code class="language-sql">-- 分组查询-- 1. 根据性别分组，统计男性员工和女性员工的数量select gender, count(*) from emp group by gender;-- 2. 根据性别分组，统计男性员工和女性员工的平均年龄select gender, avg(age) from emp group by gender;-- 3. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址select workaddress, count(*) from emp where age &lt; 45 group by workaddress having count(*) &gt;= 3;-- 可以给上面的count(*) 起一个别名select workaddress, count(*) address_count from emp where age &lt; 45 group by workaddress having address_count &gt;= 3;-- 4. 统计各个工作地址上班的男性及女性员工的数量select gender, workaddress, count(*) from emp group by gender, workaddress;</code></pre><div></div><h1><span style="color:#34495e;"><strong>2、排序查询 </strong></span></h1><div><span style="color:#34495e;">排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。</span></div><div></div><h3><span style="color:#34495e;">1)&nbsp;&nbsp;</span><span style="color:#34495e;">语法 </span></h3><blockquote><p><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#770088;">ORDER&nbsp; &nbsp;BY&nbsp; &nbsp;</span><span style="color:#34495e;">字段</span><span style="color:#34495e;">1&nbsp; </span><span style="color:#34495e;">排序方式</span><span style="color:#34495e;">1 , </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">2&nbsp;&nbsp;</span><span style="color:#34495e;">排序方式</span><span style="color:#34495e;">2 ; </span></p></blockquote><h3><span style="color:#34495e;">2)&nbsp;&nbsp;</span><span style="color:#34495e;">排序方式 </span>&nbsp;</h3><ul><li><span style="color:#34495e;">ASC : </span><span style="color:#34495e;">升序（</span><span style="color:#34495e;">默认值）</span></li>    <li><span style="color:#34495e;">DESC: </span><span style="color:#34495e;">降序</span></li></ul><blockquote><div><span style="color:#777777;">注意事项： </span></div><ul><li><span style="color:#777777;">如果是升序</span><span style="color:#777777;">, </span><span style="color:#777777;">可以不指定排序方式</span><span style="color:#777777;">ASC ; </span></li>    <li><span style="color:#777777;">如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 </span><span style="color:#777777;">; </span></li></ul></blockquote><h3><span style="color:#34495e;">3）案例</span><span style="color:#34495e;">:&nbsp;</span></h3><pre><code class="language-sql">-- 排序查询-- 1、根据年龄对公司的员工进行升序排序select * from emp order by age asc;select * from emp order by age;-- 2、根据入职时间, 对员工进行降序排序select * from emp order by entrydate desc;-- 3、根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序select * from emp order by age asc, entrydate desc;</code></pre><h1>3、分页查询</h1><div><span style="color:#34495e;">分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。 </span></div><div></div><h3><span style="color:#34495e;">1）语法</span></h3><blockquote><div><div><span style="color:#770088;">SELECT&nbsp; &nbsp;</span><span style="color:#34495e;">字段列表&nbsp; &nbsp;</span><span style="color:#770088;">FROM&nbsp; &nbsp;</span><span style="color:#34495e;">表名&nbsp; &nbsp;</span><span style="color:#770088;">LIMIT&nbsp; &nbsp;</span><span style="color:#34495e;">起始索引</span><span style="color:#34495e;">, </span><span style="color:#34495e;">查询记录数 </span><span style="color:#34495e;">; </span></div></div></blockquote><blockquote><p><span style="color:#777777;">注意事项: </span></p><ul><li><span style="color:#777777;">起始索引从</span><span style="color:#777777;">0</span><span style="color:#777777;">开始，起始索引 </span><span style="color:#777777;">= </span><span style="color:#777777;">（查询页码 </span><span style="color:#777777;">- 1</span><span style="color:#777777;">）</span><span style="color:#777777;">* </span><span style="color:#777777;">每页显示记录数。 </span></li>    <li><span style="color:#777777;">分页查询是数据库的方言，不同的数据库有不同的实现，</span><span style="color:#777777;">MySQL</span><span style="color:#777777;">中是</span><span style="color:#777777;">LIMIT</span><span style="color:#777777;">。 </span></li>    <li><span style="color:#777777;">如果查询的是第一页数据，起始索引可以省略，直接简写为 </span><span style="color:#777777;">limit 10</span><span style="color:#777777;">。 </span></li></ul></blockquote><h3>2）案例&nbsp;</h3><pre><code class="language-sql">-- 分页查询-- 查询第一页员工数据，每页展示10条记录select * from emp limit 0,10;select * from emp limit 10;-- 查询第2页员工数据, 每页展示10条记录 --------&gt; (页码-1)*页展示记录数SELECT * FROM emp LIMIT 10 OFFSET 10;select * from emp limit 10,10;</code></pre><h1>&nbsp;4、练习</h1><pre><code class="language-sql">-- 案例-- 1. 查询年龄为20,21,22,23岁的员工信息。select * from emp where age in (20,21,22,23);-- 2. 查询性别为 男 ，并且年龄在 20-40 岁(含)以内的姓名为三个字的员工。select * from emp where gender = '男' and age between 20 and 40 and name like '___';-- 如果为了结构清晰，也可以给条件加上括号select * from emp where gender = '男' and (age between 20 and 40) and name like '___';-- 3. 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数。select gender, count(*) from emp where age &lt; 60 group by gender;-- 4. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。select name, age from emp where age &lt;= 35 order by age asc, entrydate desc;-- 5. 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。select * from emp where gender = '男' and age between 20 and 40 order by age asc , entrydate asc limit 5;</code></pre><h1>5、执行顺序</h1><div><span style="color:#34495e;">在讲解</span><span style="color:#34495e;">DQL</span><span style="color:#34495e;">语句的具体语法之前，我们已经讲解了</span><span style="color:#34495e;">DQL</span><span style="color:#34495e;">语句的完整语法，及编写顺序，接下来，我们要 来说明的是DQL</span><span style="color:#34495e;">语句在执行时的执行顺序，也就是先执行那一部分，后执行那一部分。 </span></div><div></div><p><img alt="" height="426" src="/medias/images/All/24.png" width="972"></p><p><span style="color:#34495e;">验证：</span></p><p>&nbsp;<span style="color:#34495e;">查询年龄大于</span><span style="color:#34495e;">15</span><span style="color:#34495e;">的员工姓名、年龄，并根据年龄进行升序排序。</span></p><pre><code class="language-sql">select name , age from emp where age &gt; 15 order by age asc;</code></pre><p>&nbsp;<span style="color:#34495e;">在查询时，我们给</span><span style="color:#34495e;">emp</span><span style="color:#34495e;">表起一个别名 </span><span style="color:#34495e;">e</span><span style="color:#34495e;">，然后在</span><span style="color:#34495e;">select </span><span style="color:#34495e;">及 </span><span style="color:#34495e;">where</span><span style="color:#34495e;">中使用该别名。</span></p><pre><code class="language-sql">select e.name , e.age from emp e where e.age &gt; 15 order by age asc;</code></pre><div><span style="color:#34495e;">执行上述</span><span style="color:#34495e;">SQL</span><span style="color:#34495e;">语句后，我们看到依然可以正常的查询到结果，此时就说明： </span><span style="color:#34495e;">from </span><span style="color:#34495e;">先执行</span><span style="color:#34495e;">, </span><span style="color:#34495e;">然后 </span></div><div><span style="color:#34495e;">where </span><span style="color:#34495e;">和 </span><span style="color:#34495e;">select </span><span style="color:#34495e;">执行。那 </span><span style="color:#34495e;">where </span><span style="color:#34495e;">和 </span><span style="color:#34495e;">select </span><span style="color:#34495e;">到底哪个先执行呢</span><span style="color:#34495e;">? </span></div><div></div><div><span style="color:#34495e;">此时，此时我们可以给</span><span style="color:#34495e;">select</span><span style="color:#34495e;">后面的字段起别名，然后在 </span><span style="color:#34495e;">where </span><span style="color:#34495e;">中使用这个别名，然后看看是否可 </span></div><div><span style="color:#34495e;">以执行成功。</span></div><div></div><pre><code class="language-sql">select e.name ename , e.age eage from emp e where eage &gt; 15 order by age asc;</code></pre><p>&nbsp;<span style="color:#34495e;">执行上述</span><span style="color:#34495e;">SQL</span><span style="color:#34495e;">报错了</span><span style="color:#34495e;">: </span></p><p><img alt="" height="150" src="/medias/images/All/25.png" width="773"></p><p><strong>&nbsp;<span style="color:#34495e;">由此我们可以得出结论</span><span style="color:#34495e;">: from </span><span style="color:#34495e;">先执行，然后执行 </span><span style="color:#34495e;">where </span><span style="color:#34495e;">， 再执行</span><span style="color:#34495e;">select </span><span style="color:#34495e;">。 </span></strong></p><p><span style="color:#34495e;">接下来，我们再执行如下</span><span style="color:#34495e;">SQL</span><span style="color:#34495e;">语句，查看执行效果：</span></p><pre><code class="language-sql">select e.name ename , e.age eage from emp e where e.age &gt; 15 order by eage asc;</code></pre><p>&nbsp;<span style="color:#34495e;">结果执行成功。 那么也就验证了</span><span style="color:#34495e;">: order by </span><span style="color:#34495e;">是在</span><span style="color:#34495e;">select </span><span style="color:#34495e;">语句之后执行的。 </span></p><blockquote><div><strong><span style="color:#34495e;">综上所述，我们可以看到</span><span style="color:#34495e;">DQL</span><span style="color:#34495e;">语句的执行顺序为： </span><span style="color:#34495e;">from ... where ... group by ... </span></strong></div><div></div><div><strong><span style="color:#34495e;">having ... select ... order by ... limit ...</span></strong></div></blockquote><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 基础（一）Mysql的安装以及DDL语句、DML语句、DQL语句</title>
      <link href="/2023/11/10/28-mysql-ji-chu-yi-mysql-de-an-zhuang-yi-ji-ddl-yu-ju-dml-yu-ju-dql-yu-ju/"/>
      <url>/2023/11/10/28-mysql-ji-chu-yi-mysql-de-an-zhuang-yi-ji-ddl-yu-ju-dml-yu-ju-dql-yu-ju/</url>
      
        <content type="html"><![CDATA[<p>版权申明：本文用于个人学习记录，学习课程为黑马程序员的mysql教程。如需获取官方的学习视频和文档资料，请至黑马程序员官方获取。下面附上教学视频的链接地址，向提供免费教学视频的老师致敬，学如逆水行舟，不进则退，共勉<a data-link-desc="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括共计195条视频，包括：01.MySQL课程介绍、02. 基础-课程内容&amp;数据库相关概念、03. 基础-概述-MySQL安装及启动等，UP主更多精彩视频，请关注UP账号。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&amp;vd_source=db5d28283daae15e6008d16a1b91c557" title="黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括_哔哩哔哩_bilibili</a></p><h1>1. 安装</h1><p>下载地址：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="MySQL :: Download MySQL Installer" href="https://dev.mysql.com/downloads/installer/" title="MySQL :: Download MySQL Installer">MySQL :: Download MySQL Installer</a></p><p><img alt="" height="1193" src="/medias/images/All/02.png" width="1200"></p><p>mysql安装好之后</p><p>用管理员身份运行cmd</p><p>使用net stop mysql80 可以停止mysql服务</p><p>使用net start mysql80 可以启动mysql服务</p><p><img alt="" height="966" src="/medias/images/All/03.png" width="1200"></p><p><img alt="" height="330" src="/medias/images/All/04.png" width="827"></p><p>如果想在终端的任意位置输入mysql命令，需要新增配置环境变量：</p><p>C:\Program Files\MySQL\MySQL Server 8.0\bin</p><h1>2.&nbsp;<span style="color:#34495e;"><strong>SQL </strong></span></h1><blockquote><div>&nbsp;<span style="color:#34495e;">全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 </span></div><div>&nbsp;<span style="color:#34495e;">一套操作关系型数据库统一标准 。</span>&nbsp;&nbsp;</div></blockquote><h2><span style="color:#34495e;"><strong>2.1 SQL</strong></span><span style="color:#34495e;"><strong>通用语法</strong></span></h2><blockquote><div><span style="color:#34495e;">1). SQL</span><span style="color:#34495e;">语句可以单行或多行书写，以分号结尾。 </span></div><div></div><div><span style="color:#34495e;">2). SQL</span><span style="color:#34495e;">语句可以使用空格</span><span style="color:#34495e;">/</span><span style="color:#34495e;">缩进来增强语句的可读性。 </span></div><div></div><div><span style="color:#34495e;">3). MySQL</span><span style="color:#34495e;">数据库的</span><span style="color:#34495e;">SQL</span><span style="color:#34495e;">语句不区分大小写，关键字建议使用大写。 </span></div><div></div><div><span style="color:#34495e;">4). </span><span style="color:#34495e;">注释： </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单行注释：-- </span><span style="color:#34495e;">注释内容</span> <span style="color:#34495e;">或</span><span style="color:#34495e;"> # </span><span style="color:#34495e;">注释内容 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多行注释：/* </span><span style="color:#34495e;">注释内容</span><span style="color:#34495e;"> */ </span></div></blockquote><h2><span style="color:#34495e;"><strong>2.2&nbsp;SQL分类</strong></span></h2><h3><img alt="" height="982" src="/medias/images/All/05.png" width="1200"></h3><h2><span style="color:#34495e;"><strong>2.3 DDL</strong></span></h2><p>&nbsp;<span style="color:#34495e;">Data Definition Language</span><span style="color:#34495e;">，数据定义语言，用来定义数据库对象</span><span style="color:#34495e;">(</span><span style="color:#34495e;">数据库，表，字段</span><span style="color:#34495e;">) </span><span style="color:#34495e;">。 </span></p><h4><span style="color:#34495e;"><strong>2.3.1 </strong></span><span style="color:#34495e;"><strong>数据库操作</strong></span></h4><h6><span style="color:#34495e;"><strong>1). </strong></span><span style="color:#34495e;"><strong>查询所有数据库 </strong></span></h6><blockquote><p><span style="color:#34495e;">show databases ; </span>&nbsp;（注意分号）</p></blockquote><p><img alt="" height="219" src="/medias/images/All/06.png" width="399"></p><h6><span style="color:#34495e;"><strong>2). </strong></span><span style="color:#34495e;"><strong>创建数据库 </strong></span></h6><div></div><blockquote><div><div><span style="color:#770088;">create </span><span style="color:#34495e;">database [ if </span><span style="color:#770088;">not </span><span style="color:#34495e;">exists ] </span><span style="color:#34495e;">数据库名 </span><span style="color:#34495e;">[ default charset </span><span style="color:#34495e;">字符集 </span><span style="color:#34495e;">] [ collate </span><span style="color:#34495e;">排序规则 ] ; </span></div></div></blockquote><p>&nbsp;案例：</p><p>创建一个<span style="color:#34495e;">itcast</span>数据库，<span style="color:#34495e;">使用数据库默认的字符集。</span></p><blockquote><p>&nbsp;create database itcast;</p></blockquote><div><img alt="" height="282" src="/medias/images/All/07.png" width="447"></div><blockquote><p><span style="color:#34495e;">在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错：ERROR 1007 (HY000): Can't create database 'itcast'; database exists</span></p></blockquote><div><span style="color:#34495e;">可以通过</span><span style="color:#34495e;">if not exists </span><span style="color:#34495e;">参数来解决这个问题，数据库不存在</span><span style="color:#34495e;">, </span><span style="color:#34495e;">则创建该数据库，如果存在，则不 </span></div><div><span style="color:#34495e;">创建。</span></div><div></div><blockquote><p>&nbsp;<span style="color:#770088;">create </span><span style="color:#34495e;">database if </span><span style="color:#770088;">not </span><span style="color:#34495e;">extists itcast; </span></p></blockquote><div><img alt="" height="276" src="/medias/images/All/08.png" width="591"></div><p></p><h6><span style="color:#34495e;"><strong>3). 查询当前数据库 </strong></span></h6><blockquote><div><span style="color:#770088;">select </span><span style="color:#34495e;">database() ;&nbsp; &nbsp;注意加括号和分号</span></div></blockquote><h6><span style="color:#34495e;"><strong>4). </strong></span><span style="color:#34495e;"><strong>切换数据库 </strong></span>&nbsp;</h6><blockquote><div><span style="color:#34495e;">use </span><span style="color:#34495e;">数据库名 ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 举例：</span><span style="color:#770088;">use itcast;&nbsp; </span><span style="color:#0d0016;">将数据库切换到 itcast</span></div></blockquote><p><img alt="" height="442" src="/medias/images/All/09.png" width="571"></p><h6>5<span style="color:#34495e;"><strong>). </strong></span><span style="color:#34495e;"><strong>删除数据库</strong></span></h6><blockquote><div><span style="color:#770088;">drop </span><span style="color:#34495e;">database [ if exists ] </span><span style="color:#34495e;">数据库名 ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;drop database if exists test;</span></div></blockquote><div><span style="color:#34495e;">如果删除一个不存在的数据库，将会报错。此时，可以加上参数 </span><span style="color:#34495e;">if exists </span><span style="color:#34495e;">，如果数据库存在，再 </span></div><div><span style="color:#34495e;">执行删除，否则不执行删除。</span></div><p><img alt="" height="341" src="/medias/images/All/10.png" width="683"></p><h4><span style="color:#34495e;"><strong>2.3.2 </strong></span><span style="color:#34495e;"><strong>表操作</strong></span></h4><h5><span style="color:#34495e;"><strong>2.3.2.1 </strong></span><span style="color:#34495e;"><strong>表操作</strong></span><span style="color:#34495e;"><strong>-</strong></span><span style="color:#34495e;"><strong>查询创建 </strong></span></h5><h6><span style="color:#34495e;"><strong>1). </strong></span><span style="color:#34495e;"><strong>查询当前数据库所有表</strong></span></h6><blockquote><p><span style="color:#34495e;">show tables; </span></p></blockquote><p>&nbsp;<span style="color:#34495e;">比如</span><span style="color:#34495e;">,</span><span style="color:#34495e;">我们可以切换到</span><span style="color:#34495e;">sys</span><span style="color:#34495e;">这个系统数据库</span><span style="color:#34495e;">,</span><span style="color:#34495e;">并查看系统数据库中的所有表结构。</span></p><blockquote><p></p><div><span style="color:#34495e;">use sys; </span></div><div></div><div><span style="color:#34495e;">show tables;</span></div></blockquote><p><img alt="" height="805" src="/medias/images/All/11.png" width="1200"></p><h6>&nbsp;2<span style="color:#34495e;"><strong>). </strong></span><span style="color:#34495e;"><strong>创建表结构 </strong></span></h6><blockquote><p></p><div><span style="color:#770088;">CREATE TABLE </span><span style="color:#34495e;">表名</span><span style="color:#34495e;">( </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字段1 </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">1</span><span style="color:#34495e;">类型 </span><span style="color:#34495e;">[ COMMENT </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">1</span><span style="color:#34495e;">注释 </span><span style="color:#34495e;">], </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字段2 </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">2</span><span style="color:#34495e;">类型 </span><span style="color:#34495e;">[COMMENT </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">2</span><span style="color:#34495e;">注释 </span><span style="color:#34495e;">], </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字段3 </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">3</span><span style="color:#34495e;">类型 </span><span style="color:#34495e;">[COMMENT </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">3</span><span style="color:#34495e;">注释 </span><span style="color:#34495e;">], </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...... </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字段n </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">n</span><span style="color:#34495e;">类型 </span><span style="color:#34495e;">[COMMENT </span><span style="color:#34495e;">字段</span><span style="color:#34495e;">n</span><span style="color:#34495e;">注释 </span><span style="color:#34495e;">] </span></div><div><span style="color:#34495e;">) [ COMMENT </span><span style="color:#34495e;">表注释 </span><span style="color:#34495e;">] ;</span></div></blockquote><blockquote><p><span style="color:#777777;">注意</span><span style="color:#777777;">: [...] </span><span style="color:#777777;">内为可选参数，最后一个字段后面没有逗号 </span>&nbsp;</p></blockquote><p><img alt="" height="521" src="/medias/images/All/12.png" width="1200"></p><pre><code class="language-sql">create table tb_user( id int comment '编号', name varchar(50) comment '姓名', age int comment '年龄', gender varchar(1) comment '性别') comment '用户表';</code></pre><h6><span style="color:#34495e;"><strong>3). </strong></span><span style="color:#34495e;"><strong>查看指定表结构 </strong></span></h6><p><span style="color:#34495e;">通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL</span><span style="color:#34495e;">，是否存在默认值等信息。</span></p><blockquote><p><span style="color:#770088;">desc </span><span style="color:#34495e;">表名 ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;desc tb_user;</span></p></blockquote><p><img alt="" height="185" src="/medias/images/All/13.png" width="561"></p><h6>&nbsp;4<span style="color:#34495e;"><strong>). </strong></span><span style="color:#34495e;"><strong>查询指定表的建表语句 </strong></span></h6><blockquote><p><span style="color:#34495e;">show </span><span style="color:#770088;">create table </span><span style="color:#34495e;">表名 ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;show create table tb_user;</span></p></blockquote><div><span style="color:#34495e;">通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询 到，因为这部分是数据库的默认值，如：存储引擎、字符集等。</span></div><p><img alt="" height="367" src="/medias/images/All/14.png" width="790"></p><h5><span style="color:#34495e;"><strong>2.3.2.2 </strong></span><span style="color:#34495e;"><strong>表操作</strong></span><span style="color:#34495e;"><strong>-</strong></span><span style="color:#34495e;"><strong>数据类型 </strong></span></h5><div><span style="color:#34495e;">在上述的建表语句中，我们在指定字段的数据类型时，用到了</span><span style="color:#34495e;">int </span><span style="color:#34495e;">，</span><span style="color:#34495e;">varchar</span><span style="color:#34495e;">，那在</span><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">中除了 </span></div><div><span style="color:#34495e;">以上的数据类型，还有哪些常见的数据类型呢？ 接下来</span><span style="color:#34495e;">,</span><span style="color:#34495e;">我们就来介绍一下</span><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">的数据类型。 </span></div><div></div><div><strong><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</span></strong></div><div></div><h6><span style="color:#34495e;">1). </span><span style="color:#34495e;">数值类型 </span></h6><blockquote><p>&nbsp;<img alt="" height="829" src="/medias/images/All/15.png" width="630"></p></blockquote><blockquote><div><span style="color:#34495e;">如</span><span style="color:#34495e;">: </span></div><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">年龄字段 </span><span style="color:#34495e;">-- </span><span style="color:#34495e;">不会出现负数</span><span style="color:#34495e;">, </span><span style="color:#34495e;">而且人的年龄不会太大 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age tinyint unsigned </span></div><div></div><div><span style="color:#34495e;">2). </span><span style="color:#34495e;">分数 </span><span style="color:#34495e;">-- </span><span style="color:#34495e;">总分</span><span style="color:#34495e;">100</span><span style="color:#34495e;">分</span><span style="color:#34495e;">, </span><span style="color:#34495e;">最多出现一位小数 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score double(4,1) </span></div></blockquote><h6>&nbsp;<span style="color:#34495e;">2). </span><span style="color:#34495e;">字符串类型</span></h6><p><img alt="" height="478" src="/medias/images/All/16.png" width="616"></p><p><span style="color:#34495e;">char 与 varchar </span><span style="color:#34495e;">都可以描述字符串，</span><span style="color:#34495e;">char</span><span style="color:#34495e;">是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar</span><span style="color:#34495e;">是变长字符串，指定的长度为最大占用长度 。相对来说，</span><span style="color:#34495e;">char</span><span style="color:#34495e;">的性 能会更高些。 </span></p><blockquote><p></p><div><span style="color:#34495e;">如： </span></div><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">用户名 </span><span style="color:#34495e;">username ------&gt; </span><span style="color:#34495e;">长度不定</span><span style="color:#34495e;">, </span><span style="color:#34495e;">最长不会超过</span><span style="color:#34495e;">50 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;username varchar(50) </span></div><div></div><div><span style="color:#34495e;">2). </span><span style="color:#34495e;">性别 </span><span style="color:#34495e;">gender ---------&gt; </span><span style="color:#34495e;">存储值</span><span style="color:#34495e;">, </span><span style="color:#34495e;">不是男</span><span style="color:#34495e;">,</span><span style="color:#34495e;">就是女 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gender char(1) </span></div><div></div><div><span style="color:#34495e;">3). </span><span style="color:#34495e;">手机号 </span><span style="color:#34495e;">phone --------&gt; </span><span style="color:#34495e;">固定长度为</span><span style="color:#34495e;">11 </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;phone char(11) </span></div></blockquote><h6><span style="color:#34495e;">3). </span><span style="color:#34495e;">日期时间类型 </span>&nbsp;</h6><p><img alt="" height="383" src="/medias/images/All/17.png" width="616"></p><blockquote><div><span style="color:#34495e;">如</span><span style="color:#34495e;">: </span></div><div><span style="color:#34495e;">1). </span><span style="color:#34495e;">生日字段 </span><span style="color:#34495e;">birthday </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;birthday date </span></div><div></div><div><span style="color:#34495e;">2). </span><span style="color:#34495e;">创建时间 </span><span style="color:#34495e;">createtime </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createtime datetime </span></div></blockquote><h5><span style="color:#34495e;"><strong>2.3.2.3 </strong></span><span style="color:#34495e;"><strong>表操作</strong></span><span style="color:#34495e;"><strong>-</strong></span><span style="color:#34495e;"><strong>案例 </strong></span></h5><div><span style="color:#34495e;">设计一张员工信息表，要求如下： </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 编号（纯数字） </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 员工工号</span><span style="color:#34495e;"> (</span><span style="color:#34495e;">字符串类型，长度不超过</span><span style="color:#34495e;">10</span><span style="color:#34495e;">位</span><span style="color:#34495e;">) </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 员工姓名（字符串类型，长度不超过</span><span style="color:#34495e;">10</span><span style="color:#34495e;">位） </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 性别（男/</span><span style="color:#34495e;">女，存储一个汉字） </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 年龄（正常人年龄，不可能存储负数） </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 身份证号（二代身份证号均为</span><span style="color:#34495e;">18</span><span style="color:#34495e;">位，身份证中有</span><span style="color:#34495e;">X</span><span style="color:#34495e;">这样的字符） </span></div><div><span style="color:#34495e;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7. 入职时间（取值年月日即可） </span></div><div><span style="color:#34495e;">对应的建表语句如下</span><span style="color:#34495e;">:</span></div><pre><code class="language-sql">create table emp(    id        int comment '编号',    workno    varchar(10) comment '工号',    name      varchar(10) comment '姓名',    gender    char(1) comment '性别',    age       tinyint unsigned comment '年龄',    idcard    char(18) comment '身份证号',    entrydate date comment '入职时间') comment '员工表';</code></pre><div><span style="color:#34495e;">SQL</span><span style="color:#34495e;">语句编写完毕之后，就可以在</span><span style="color:#34495e;">MySQL</span><span style="color:#34495e;">的命令行中执行</span><span style="color:#34495e;">SQL</span><span style="color:#34495e;">，然后也可以通过 </span><span style="color:#34495e;">desc </span><span style="color:#34495e;">指令查询表结构信息：</span></div><div><img alt="" height="227" src="/medias/images/All/18.png" width="590"></div><h5></h5><h5><span style="color:#34495e;"><strong>2.3.2.4 </strong></span><span style="color:#34495e;"><strong>表操作</strong></span><span style="color:#34495e;"><strong>-</strong></span><span style="color:#34495e;"><strong>修改 </strong></span></h5><h6><span style="color:#34495e;">1). 添加字段 </span></h6><blockquote><p><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">表名 </span><span style="color:#34495e;">ADD </span><span style="color:#34495e;">字段名 类型 </span><span style="color:#34495e;">(</span><span style="color:#34495e;">长度</span><span style="color:#34495e;">) [ COMMENT </span><span style="color:#34495e;">注释 </span><span style="color:#34495e;">] [ </span><span style="color:#34495e;">约束 </span><span style="color:#34495e;">];</span></p><p></p><p><span style="color:#34495e;">// 添加字段</span><br><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">emp ADD nickname </span><span style="color:#3300aa;">varchar</span><span style="color:#34495e;">(</span><span style="color:#116644;">20</span><span style="color:#34495e;">) COMMENT </span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">昵称</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">; </span></p></blockquote><h6><span style="color:#34495e;">2). 修改字段</span></h6><blockquote><div><span style="color:#34495e;">// 修改数据类型</span></div><div><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">表名 </span><span style="color:#34495e;">MODIFY </span><span style="color:#34495e;">字段名 新数据类型 </span><span style="color:#34495e;">(长度);&nbsp; &nbsp;</span></div><div></div><div>// 修改字段名和字段类型</div><div><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">表名 </span><span style="color:#34495e;">CHANGE </span><span style="color:#34495e;">旧字段名 新字段名 类型 </span><span style="color:#34495e;">(</span><span style="color:#34495e;">长度</span><span style="color:#34495e;">) [ COMMENT </span><span style="color:#34495e;">注释 </span><span style="color:#34495e;">] [ </span><span style="color:#34495e;">约束 </span><span style="color:#34495e;">];</span></div><div></div><div>// 修改字段，将nickname字段修改为username，类型为varchar(30)<br><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">emp CHANGE nickname username </span><span style="color:#3300aa;">varchar</span><span style="color:#34495e;">(</span><span style="color:#116644;">30</span><span style="color:#34495e;">) COMMENT </span><span style="color:#22a2c9;">'</span><span style="color:#22a2c9;">昵称</span><span style="color:#22a2c9;">'</span><span style="color:#34495e;">; </span></div></blockquote><h6><span style="color:#34495e;">3). 删除字段</span></h6><blockquote><p><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">表名 </span><span style="color:#770088;">DROP </span><span style="color:#34495e;">字段名</span><span style="color:#34495e;">; </span></p><p></p><p><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">emp </span><span style="color:#770088;">DROP </span><span style="color:#34495e;">username;</span></p></blockquote><h6><span style="color:#34495e;">4). 修改表名</span></h6><blockquote><div><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">表名 </span><span style="color:#34495e;">RENAME TO </span><span style="color:#34495e;">新表名</span><span style="color:#34495e;">; </span></div><div></div><div><span style="color:#770088;">ALTER TABLE </span><span style="color:#34495e;">emp RENAME TO employee; </span></div></blockquote><h5><span style="color:#34495e;"><strong>2.3.2.5 </strong></span><span style="color:#34495e;"><strong>表操作</strong></span><span style="color:#34495e;"><strong>-</strong></span><span style="color:#34495e;"><strong>删除 </strong></span></h5><h6><span style="color:#34495e;">1). 删除表</span></h6><blockquote><p><span style="color:#770088;">DROP TABLE </span><span style="color:#34495e;">[ IF EXISTS ] </span><span style="color:#34495e;">表名</span><span style="color:#34495e;">; </span></p><p></p><div><span style="color:#770088;">DROP TABLE </span><span style="color:#34495e;">IF EXISTS tb_user; </span></div></blockquote><h6><span style="color:#34495e;">2).&nbsp;删除指定表</span><span style="color:#34495e;">, </span><span style="color:#34495e;">并重新创建表 </span></h6><blockquote><p><span style="color:#34495e;">TRUNCATE </span><span style="color:#770088;">TABLE </span><span style="color:#34495e;">表名</span><span style="color:#34495e;">;</span></p><p></p><p>&nbsp;truncate table employee;</p></blockquote><blockquote><p><span style="color:#fe2c24;">&nbsp;注意: 在删除表的时候，表中的全部数据也都会被删除。</span></p></blockquote><h2>2.4 图形化工具DataGrip的安装和配置 （此处略过）</h2><p>DataGrip是<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="JetBrains" href="http://www.baidu.com/baidu.php?url=0s0000aPch_Smgbn9iFKGJTQ01BL9YK1qMNAv68BpHNJ76wD6vyPRwmEPhHh9YZyjZc7-dWJZVSDc1znA8d9oKjiU7VCHzxcgJXwpxIib15-0dVC8OWHlmUMcqNmAAlyJ3HdjeeM49QCLcEBTF56DkGT6639Nt8OoljA2Mc1KYvAt4-bTqkJmkgWBJXc2-bA5lCAbLaHLjk3ooupl3mSyN0xa_bM.DY_NR2Ar5Od66zGCg1nEBWG63DLkYZHpm5HGIKLsRP5QAeKPa-BqM76l32AM-YG8x6Y_f33X8a9G4myIrP-SJFBAQ5XzO5xPM3DLkYZHpTSro5W9l32AM-9I7fH7fm3DLkYZHpTS5KnMo6CpXy6hUiksFEWCrhYJN9h9mLyyUS26.U1Yk0ZDqIvNBTLwEThY0TA-W5H00IjdLuyF1IAqzUfKGUHYznWR0u1dsThc0Iybqmh7GuZR0TA-b5HD40APGujYdPfKVIjYknjD4g1DsnHIxn1Dzn7tznjRkg1nvnjD0pvbqn0KzIjY1PWf0mhbqnHR3g1csP7tdnjn0UynqnH0krNtknjDLg1Dsn-tznjRkg100TgKGujYs0Z7Wpyfqn0KzuLw9u1Ys0A7B5HKxn0K-ThTqn0KsTjY3rjm3rjm1Pjm0UMus5H08nj0snj0snj00Ugws5H00uAwETjYs0ZFJ5H00uANv5gKW0AuY5H00TA6qn0KET1Ys0AFL5HDs0A4Y5H00TLCq0A71gv-bm1dsTzd8p6KGuAnqHbG2RsKspZw45fKYmgFMugfqPWPxn7tkPH00IZN15HT1nHcvn1cYP1cLnHfvPjbLnjn0ThNkIjYkPWb4PHbLnjDkrj6k0ZPGujd9uAckmhFhnW0snjK9rH-W0AP1UHYdfHRvnYNDPjPAnH7afHRk0A7W5HD0TA3qn0KkUgfqn0KkUgnqn0KlIjYs0AdWgvuzUvYqn7tsg1Kxn7ts0Aw9UMNBuNqsUA78pyw15HKxn7tdrjbznWfdg1Kxn0Ksmgwxuhk9u1Ys0AwWpyfqn0K-IA-b5iYk0A71TAPW5H00IgKGUhPW5H00Tydh5H00uhPdIjYs0A-1mvsqn0K9uAu_myTqnfK_uhnqn0KbmvPb5HmkrDR4PYcvfRmdrHKaPHczwbw7P10zrjnvrDRzPH7KPjwAP1cLnb77wbdnH-PDRR-nHfKYTh7buHYvP10dnjD0mhwGujYdf1RswWmsfHbvfHndwjKArH63wRRzfWKKnHRYfRm4P6KEm1Yk0AFY5H00Uv7YI1Ys0AqY5H00ULFsIjYsc10Wc10Wnansc108nj0snj0sc10WwDuRc10WQinsQW0snj0snankQW0snj0snansc10Wna3snj0snj0Wnansc10Wn0KBmy4omyPW5H0Wnansc100XZPYIHYzPjf1nHnLnfKkgLmqna33ndtsQW0sg108njKxna33ndtsQWfLg1Kxna3YPdts0AF1gLKzUvwGujYs0ZFEpyu_myTqn0KWIWY0pgPxmLK95H00mL0qn0K-TLfqn0KWThnqPH63nHc&amp;us=newvui&amp;xst=TjY3rjm3rjm1PjmKm1YvnH97rHIaPb7APHbsfWRznbuDwHTsnW61PW97nWRkfHfYwWTzP1FKwRuPHD4Hw77FHDYKmWYdf1RswWmsfHbvfHndwjKArH63wRRzfWKKnHRYfRm4P6715HDzPHDdrHbkPj6LPjbdrjfznW0Yg1czPNts0gTqIvNBTLwEThYKTHdLuyF1IAqzUf7d5HcYPjnkn1Tk0gfqnHm4rHR4P10kn67VTHYs0W0aQf7Wpjdhmdqsms7_IHYs0yP85yF9pywd0gFY5H0Kn1bsPj0Lnjfzn6&amp;word=&amp;ck=7322.2.1699597015566.0.0.272.189.0&amp;shh=www.baidu.com&amp;wd=" title="JetBrains">JetBrains</a>出品的数据库管理客户端工具，可以购买或免费试用或自行破解</p><h2>2.5&nbsp; DML</h2><div><span style="color:#34495e;">DML</span><span style="color:#34495e;">英文全称是</span><span style="color:#34495e;">Data Manipulation Language(</span><span style="color:#34495e;">数据操作语言</span><span style="color:#34495e;">)</span><span style="color:#34495e;">，用来对数据库中表的数据记录进 </span></div><div><span style="color:#34495e;">行增、删、改操作。 </span></div><div><ul><li><span style="color:#34495e;">添加数据（</span><span style="color:#34495e;">INSERT</span><span style="color:#34495e;">） </span></li>    <li><span style="color:#34495e;">修改数据（</span><span style="color:#34495e;">UPDATE</span><span style="color:#34495e;">） </span></li>    <li><span style="color:#34495e;">删除数据（</span><span style="color:#34495e;">DELETE</span><span style="color:#34495e;">）</span></li></ul></div><h4>&nbsp;<span style="color:#34495e;"><strong>2.5.1 </strong></span><span style="color:#34495e;"><strong>添加数据 </strong></span><span style="color:#34495e;"><strong> </strong></span></h4><pre><code class="language-sql">// 添加数据// 给指定字段添加数据，INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);insert into employee(id, workno, name, gender, age, idcard, entrydate)values (1, '1', 'Itcast', '男', 10, '123456789012345678', '2000-01-01');// 查询表里的所有数据select * from employee;// 给全部字段添加数据，INSERT INTO 表名 VALUES (值1, 值2, ...);insert into employeevalues (2, '2', '张无忌', '男', 18, '123456789012345670', '2005-01-01');// 批量添加数据-- INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值 1, 值2, ...) ;-- INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;insert into employeevalues (3, '3', '韦一笑', '男', 38, '123456789712345670', '2005-01-01'),       (4, '4', '赵敏', '女', 18, '123456757123456700', '2005-01-01');</code></pre><h4>&nbsp;&nbsp;<span style="color:#34495e;"><strong>2.5.2&nbsp;修改</strong></span><span style="color:#34495e;"><strong>数据</strong></span></h4><pre><code class="language-sql">// 修改数据-- UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;-- 修改id为1的数据，将name修改为itheimaupdate employee set name = 'itheima' where id = 1;-- 修改id为1的数据，将name修改为小昭，gender修改为女update employee set name = '小昭',gender='女' where id = 1;-- 将所有的员工入职日期修改为2008-01-01update employee set entrydate = '2008-01-01';</code></pre><blockquote><p><span style="color:#fe2c24;">&nbsp;注意: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</span></p></blockquote><h4>&nbsp;&nbsp;&nbsp;<span style="color:#34495e;"><strong>2.5.3&nbsp;删除</strong></span><span style="color:#34495e;"><strong>数据</strong></span></h4><pre><code class="language-sql">// 删除数据-- DELETE FROM 表名 [ WHERE 条件 ] ;-- 删除性别为女的数据delete from employee where gender = '女';-- 删除表里所有的数据delete from employee;</code></pre><blockquote><div><span style="color:#777777;">注意事项</span><span style="color:#777777;">: </span></div><div></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;• DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表所有数据</span></div><div></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;• DELETE 语句不能删除某一个字段的值</span><span style="color:#777777;">(</span><span style="color:#777777;">可以使用</span><span style="color:#777777;">UPDATE</span><span style="color:#777777;">，将该字段值置为</span><span style="color:#777777;">NULL即</span><span style="color:#777777;">可</span></div><div></div><div><span style="color:#777777;">&nbsp;&nbsp;&nbsp;• 当进行删除全部数据操作时，</span><span style="color:#777777;">datagrip</span><span style="color:#777777;">会提示我们，询问是否确认删除，我们直接点击 </span></div><div><span style="color:#777777;">Execute</span><span style="color:#777777;">即可。 </span></div></blockquote><h2>&nbsp;2.6 DQL&nbsp;</h2><h5>2.6.1 基本语法</h5><p>DQL是数据查询语言，用来查询数据库中表的记录。查询关键字：select</p><blockquote><p>DQL 查询语句，语法结构如下：<br>SELECT&nbsp;<br>&nbsp;&nbsp; &nbsp;字段列表<br>FROM<br>&nbsp;&nbsp; &nbsp;表名列表<br>WHERE<br>&nbsp;&nbsp; &nbsp;条件列表<br>GROUP BY<br>&nbsp;&nbsp; &nbsp;分组字段列表<br>HAVING<br>&nbsp;&nbsp; &nbsp;分组后条件列表<br>ORDER BY<br>&nbsp;&nbsp; &nbsp;排序字段列表<br>LIMIT<br>&nbsp;&nbsp; &nbsp;分页参数</p></blockquote><pre><code class="language-sql">-- 删除原有的employee表drop table if exists employee;-- 创建一个emp表create table emp(    id          int comment '编号',    workno      varchar(10) comment '工号',    name        varchar(10) comment '姓名',    gender      char(1) comment '性别',    age         tinyint unsigned comment '年龄',    idcard      char(18) comment '身份证号',    workaddress varchar(50) comment '工作地址',    entrydate   date comment '入职时间') comment '员工表';-- 给员工表插入一些数据INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (1, '00001', '柳岩666', '女', 20, '123456789012345678', '北京', '2000-01-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (2, '00002', '张无忌', '男', 18, '123456789012345670', '北京', '2005-09-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (3, '00003', '韦一笑', '男', 38, '123456789712345670', '上海', '2005-08-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (4, '00004', '赵敏', '女', 18, '123456757123845670', '北京', '2009-12-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (5, '00005', '小昭', '女', 16, '123456769012345678', '上海', '2007-07-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (6, '00006', '杨逍', '男', 28, '12345678931234567X', '北京', '2006-01-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (7, '00007', '范瑶', '男', 40, '123456789212345670', '北京', '2005-05-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (8, '00008', '黛绮丝', '女', 38, '123456157123645670', '天津', '2015-05-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (9, '00009', '范凉凉', '女', 45, '123156789012345678', '北京', '2010-04-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (10, '00010', '陈友谅', '男', 53, '123456789012345670', '上海', '2011-01-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (11, '00011', '张士诚', '男', 55, '123567897123465670', '江苏', '2015-05-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (12, '00012', '常遇春', '男', 32, '123446757152345670', '北京', '2004-02-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (13, '00013', '张三丰', '男', 88, '123656789012345678', '江苏', '2020-11-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (14, '00014', '灭绝', '女', 65, '123456719012345670', '西安', '2019-05-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (15, '00015', '胡青牛', '男', 70, '12345674971234567X', '西安', '2018-04-01');INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate) VALUES (16, '00016', '周芷若', '女', 18, null, '北京', '2012-06-01');</code></pre><h5>2.6.2 基本查询&nbsp;</h5><pre><code class="language-sql">-- 1. 查询指定字段 name, workno, age 返回select name, workno, age from emp;</code></pre><p><img alt="" height="496" src="/medias/images/All/19.png" width="558"></p><pre><code class="language-sql">-- 2. 查询所有字段返回select * from emp;</code></pre><p><img alt="" height="675" src="/medias/images/All/20.png" width="1200"></p><pre><code class="language-sql">-- 3. 查询所有员工的工作地址，起别名select workaddress as '工作地址' from emp;-- as 可以省略select workaddress '工作地址' from emp;</code></pre><p><img alt="" height="628" src="/medias/images/All/21.png" width="719"></p><pre><code class="language-sql">-- 4. 查询公司员工的上班地址（不要重复）select distinct workaddress '工作地址' from emp;</code></pre><p><img alt="" height="431" src="/medias/images/All/22.png" width="572"></p><h5>&nbsp;2.6.3 条件查询</h5><blockquote><div><span style="color:#0d0016;">语法:</span><span style="color:#770088;">&nbsp; &nbsp; &nbsp;SELECT&nbsp;&nbsp;</span><span style="color:#34495e;">字段列表&nbsp;&nbsp;</span><span style="color:#770088;">FROM&nbsp;&nbsp;</span><span style="color:#34495e;">表名&nbsp;&nbsp;</span><span style="color:#770088;">WHERE&nbsp;&nbsp;</span><span style="color:#34495e;">条件列表 </span><span style="color:#34495e;">;</span></div></blockquote><p><img alt="" height="776" src="/medias/images/All/23.png" width="629"></p><pre><code class="language-sql">DQL-条件查询-- SELECT 字段列表 FROM 表名 WHERE 条件列表 ;-- 1. 查询年龄等于 88 的员工select * from emp where age = 88;-- 2. 查询年龄小于 20 的员工信息select * from emp where age &lt; 20;-- 3. 查询年龄小于等于 20 的员工信息select * from emp where age &lt;= 20;-- 4. 查询没有身份证号的员工信息select * from emp where idcard is null;-- 5. 查询有身份证号的员工信息select * from emp where idcard is not null;-- 6. 查询年龄不等于 88 的员工信息select * from emp where age != 88;select * from emp where age &lt;&gt; 88;-- 7. 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息select * from emp where age &gt;= 15 &amp;&amp; age &lt;= 20;select * from emp where age &gt;= 15 and age &lt;= 20;select * from emp where age between 15 and 20;-- 8. 查询性别为 女 且年龄小于 25岁的员工信息select * from emp where gender = '女' and age &lt; 25;select * from emp where gender = '女' &amp;&amp; age &lt; 25;-- 9. 查询年龄等于18 或 20 或 40 的员工信息select * from emp where age = 18 || age = 20 || age = 40;select * from emp where age = 18 or age = 20 or age = 40;select * from emp where age in (18, 20, 40);-- 10. 查询姓名为两个字的员工信息 _ %select * from emp where name like '__';-- 11. 查询身份证号最后一位是X的员工信息select * from emp where emp.idcard like '_________________X';select * from emp where emp.idcard like '%X';</code></pre><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 后台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js判断对象是否包含某个key</title>
      <link href="/2023/11/06/27-js-pan-duan-dui-xiang-shi-fou-bao-han-mou-ge-key/"/>
      <url>/2023/11/06/27-js-pan-duan-dui-xiang-shi-fou-bao-han-mou-ge-key/</url>
      
        <content type="html"><![CDATA[<h3>1. 使用&nbsp;<code>in</code>&nbsp;运算符：</h3><ul><li>如果对象&nbsp;<code>obj</code>&nbsp;或其原型链中包含名为 “key” 的属性，则返回&nbsp;<code>true</code>。</li>    <li>如果对象&nbsp;<code>obj</code>&nbsp;不包含名为 “key” 的属性，并且它的原型链上也不存在该属性，则返回&nbsp;<code>false</code>。&nbsp;</li></ul><pre><code class="language-javascript">  let obj = {    name: "Jerry",    age: 18,  };</code><p><code class="language-javascript">  console.log(“name” in obj); // true<br>  console.log(“toString” in obj); // true</code></p></pre><p></p><blockquote><p>由于&nbsp;<code>toString</code>&nbsp;方法存在于&nbsp;<code>Object</code>&nbsp;的原型中，因此使用&nbsp;<code>in</code>&nbsp;运算符检查&nbsp;<code>"toString" in obj</code>&nbsp;会返回&nbsp;<code>true</code>，但&nbsp;<code>obj.hasOwnProperty("toString")</code>&nbsp;返回&nbsp;<code>false</code>，因为该属性不是直接属于&nbsp;<code>obj</code>&nbsp;对象的。&nbsp;</p></blockquote><h3>2. 使用&nbsp;<code>hasOwnProperty()</code>&nbsp;方法：</h3><ul><li>如果对象&nbsp;<code>obj</code>&nbsp;直接拥有名为 “key” 的属性，则返回&nbsp;<code>true</code>。</li>    <li>如果对象&nbsp;<code>obj</code>&nbsp;不直接拥有名为 “key” 的属性，或者它的原型链上存在该属性，则返回&nbsp;<code>false</code>。</li></ul><pre><code class="language-javascript">let obj = {  name: "Jerry",  age: 18,};</code><p><code class="language-javascript">console.log(obj.hasOwnProperty(“name”)); // true<br>console.log(obj.hasOwnProperty(“toString”)); // false</code></p></pre><p></p><h3>3.&nbsp;使用&nbsp;<code>Object.keys()</code>&nbsp;方法：</h3><blockquote><p><code>Object.keys()</code>&nbsp;方法会返回对象自身可枚举的属性组成的数组，然后使用&nbsp;<code>includes()</code>&nbsp;方法来检查指定的键是否存在于该数组中。</p></blockquote><pre><code class="language-javascript">let obj = {  name: "Jerry",  age: 18,};console.log(Object.keys(obj).includes("name")); // trueconsole.log(Object.keys(obj).includes("toString")); // false</code></pre><p>如果帮助到您了，可以留下一个赞👍告诉我&nbsp;</p><p></p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解 URLSearchParams</title>
      <link href="/2023/11/02/26-xiang-jie-urlsearchparams/"/>
      <url>/2023/11/02/26-xiang-jie-urlsearchparams/</url>
      
        <content type="html"><![CDATA[<p><code><strong>定义：</strong>URLSearchParams</code>&nbsp;是一个 JavaScript 内置类，用于处理 <strong>URL 查询字符串</strong>（query string）的解析和构建。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>URL 查询字符串</strong>是 URL 中位于问号（?）后面的部分，用于传递参数和数值。例如，在以下 URL 中（https://example.com/page?name=John&amp;age=30），查询字符串是&nbsp;<code>name=John&amp;age=30</code></p></blockquote><p>通常可以使用 window.location.search 来获取URL中的查询字符串。关于URL的组成和获取各个部分的方法详解可以参考我的另一篇博文：<a data-link-desc="文章浏览阅读12次。详解URL的组成以及获取URL各部分的方法" data-link-icon="https://g.csdnimg.cn/static/logo/favicon32.ico" data-link-title="详解URL的组成以及获取URL各部分的方法-CSDN博客" href="https://blog.csdn.net/weixin_42289279/article/details/134118803?spm=1001.2014.3001.5502" title="详解URL的组成以及获取URL各部分的方法-CSDN博客">详解URL的组成以及获取URL各部分的方法-CSDN博客</a></p><p></p><p>&nbsp;我测试的初始URL是：http://127.0.0.1:5501/103001_URLSearchParams.html?name=jerry</p><p></p><pre><code class="language-javascript">  // 浏览器中的URL：http://127.0.0.1:5501/103001_URLSearchParams.html?name=jerry  // 获取url中的查询字符串  const searchStr = window.location.search;  // URLSearchParams() 构造函数可以接受一个查询字符串作为参数，用于初始化 URLSearchParams 对象。  const searchParams = new URLSearchParams(searchStr);  console.log('searchParams', searchParams);</code></pre><p>下面根据控制台的这张图来详细说说 URLSearchParams 原型上有哪些属性和方法：&nbsp;</p><p>&nbsp;<img alt="" height="364" src="/medias/images/All/01.png" width="445"></p><h3>&nbsp;1. size 属性</h3><p>用于返回查询参数的数量。&nbsp;</p><pre><code class="language-javascript">const searchParams= new URLSearchParams('key1=value1&amp;key2=value2&amp;key3=value3');console.log(searchParams.size); // 输出：3</code></pre><blockquote><p>&nbsp;注意：到2021年为止，<span style="color:#fe2c24;">URLSearchParams的size属性</span>是在<span style="color:#fe2c24;">Chrome 89版本</span>中加入的。不过需要注意的是，不同浏览器可能对URLSearchParams接口的支持程度不同，因此在实际使用时，建议检查目标浏览器的兼容性。</p></blockquote><h3>2.&nbsp;URLSearchParams.append(name, value)</h3><p>向查询字符串中添加一个新的参数。 可以append多个同名的，不会覆盖，会追加</p><pre><code class="language-javascript">// URLSearchParams.append(name, value)：向查询字符串中添加一个新的参数。可以append多个同名的，不会覆盖，会追加  searchParams.append("gender", "male");  searchParams.append("gender", "female");</code></pre><h3>3.&nbsp;URLSearchParams.<strong><code>get(name) 入参name必传。</code></strong><span style="color:#fe2c24;"><code>这个方法应该是最常用的</code></span></h3><p>获取指定名称的参数值。如果存在多个同名参数，则返回第一个参数的值。</p><pre><code class="language-javascript">console.log(searchParams.get('gender')); // 字符串 'male' 如果有多个，默认返回第一个console.log(searchParams.get('age'));    // get 一个不存在的，返回null</code></pre><h3>4.&nbsp;URLSearchParams.getAll<strong><code>(name) 入参name必传</code></strong></h3><p>获取指定名称的所有参数值，返回一个数组。</p><pre><code class="language-javascript">console.log(searchParams.getAll('gender')); // 数组 &nbsp;['male', 'female']</code></pre><h3>5.&nbsp;URLSearchParams.has(name)</h3><p>检查查询字符串中是否存在指定名称的参数。如果存在，则返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。&nbsp;</p><pre><code class="language-javascript">console.log(searchParams.has('gender')); // 存在返回trueconsole.log(searchParams.has('age'));    // 不存在返回false</code></pre><h3>6.&nbsp;&nbsp;URLSearchParams.set(name, value)</h3><p>设置指定名称的参数值。如果参数已存在，则会替换为新的值。</p><pre><code class="language-javascript">// URLSearchParams.set(name, value)：设置查询字符串中指定参数的值，如果参数不存在，则添加新的参数。  searchParams.set('age', 18);  console.log(searchParams.get('age')); // 18</code></pre><h3>&nbsp;7. URLSearchParams.delete(name)</h3><pre><code class="language-javascript">// URLSearchParams.delete(name)：从查询字符串中删除指定的参数。  searchParams.delete('age');  console.log(searchParams.get('age')); // null  因为age被上一行删除了，所以返回null</code></pre><h3>&nbsp;8.&nbsp;URLSearchParams.toString()</h3><p>将 URLSearchParams 对象转换为字符串表示形式，返回查询字符串。</p><pre><code class="language-javascript">// URLSearchParams.toString()：将 URLSearchParams 对象转换为字符串表示形式，返回查询字符串。  console.log(searchParams.toString()); // name=jerry&amp;gender=male&amp;gender=female</code></pre><h3>9. URLSearchParams.sort()&nbsp;</h3><p>按照参数名称对查询字符串中的参数进行排序。</p><pre><code class="language-javascript">// 按照参数名称对查询字符串中的参数进行排序。  searchParams.sort();  console.log(searchParams.toString()); // gender=male&amp;gender=female&amp;name=jerry</code></pre><h3>10.&nbsp;&nbsp;URLSearchParams.entries()&nbsp;</h3><p>返回一个迭代器，该迭代器包含了所有查询参数的键值对。</p><pre><code class="language-javascript">// entries() 方法用于返回一个迭代器，该迭代器包含了所有查询参数的键值对。  for (const [key, value] of searchParams.entries()) {    console.log(key, value);  }  // gender male  // gender female  // name jerry</code></pre><h3>&nbsp;11.&nbsp; URLSearchParams.forEach()&nbsp;</h3><p>遍历。回调第一个参数是value，第二个参数是key</p><pre><code class="language-javascript">searchParams.forEach((value, key)=&gt;{  console.log(key, value);})// gender male// gender female// name jerry</code></pre><h3>12.&nbsp;URLSearchParams.keys()&nbsp;</h3><p>用于返回一个迭代器，该迭代器包含了所有查询参数的键。</p><pre><code class="language-javascript">// keys() 方法用于返回一个迭代器，该迭代器包含了所有查询参数的键。for (const key of searchParams.keys()) {  console.log(key);}// gender// gender// name</code></pre><h3>&nbsp;13.&nbsp;URLSearchParams.values()&nbsp;</h3><p>用于返回一个迭代器，该迭代器包含了所有查询参数的值。</p><pre><code class="language-javascript">// values() 方法用于返回一个迭代器，该迭代器包含了所有查询参数的值。  for (const value of searchParams.values()) {    console.log(value);  }  // male  // female  // jerry</code></pre><p><strong>至此所有的属性和方法都写了，最后附上我测试的完整代码：</strong></p><pre><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;测试URLSearchParams&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;&lt;script&gt;  // 浏览器中的URL：http://127.0.0.1:5501/103001_URLSearchParams.html?name=jerry  // 获取url中的查询字符串  const searchStr = window.location.search;  // URLSearchParams() 构造函数可以接受一个查询字符串作为参数，用于初始化 URLSearchParams 对象。  const searchParams = new URLSearchParams(searchStr);  console.log("searchParams", searchParams);  // URLSearchParams.append(name, value)：向查询字符串中添加一个新的参数。可以append多个同名的，不会覆盖，会追加  searchParams.append("gender", "male");  searchParams.append("gender", "female");  console.log(searchParams.getAll("gender")); // 数组 &nbsp;['male', 'female']  console.log(searchParams.get("gender")); // 字符串 'male' 如果有多个，默认返回第一个  console.log(searchParams.get("age")); // get 一个不存在的，返回null  console.log(searchParams.has("gender")); // 存在返回true  console.log(searchParams.has("age")); // 不存在返回false  // URLSearchParams.set(name, value)：设置查询字符串中指定参数的值，如果参数不存在，则添加新的参数。  searchParams.set("age", 18);  console.log(searchParams.get("age")); // 18  // URLSearchParams.delete(name)：从查询字符串中删除指定的参数。  searchParams.delete("age");  console.log(searchParams.get("age")); // null  因为age被上一行删除了，所以返回null  // URLSearchParams.toString()：将 URLSearchParams 对象转换为字符串表示形式，返回查询字符串。  console.log(searchParams.toString()); // name=jerry&amp;gender=male&amp;gender=female  // 按照参数名称对查询字符串中的参数进行排序。  searchParams.sort();  console.log(searchParams.toString()); // gender=male&amp;gender=female&amp;name=jerry  // entries() 方法用于返回一个迭代器，该迭代器包含了所有查询参数的键值对。  for (const [key, value] of searchParams.entries()) {    console.log(key, value);  }  // gender male  // gender female  // name jerry  searchParams.forEach((value, key) =&gt; {    console.log(key, value);  });  // gender male  // gender female  // name jerry  console.log(searchParams.keys());  // keys() 方法用于返回一个迭代器，该迭代器包含了所有查询参数的键。  for (const key of searchParams.keys()) {    console.log(key);  }  // gender  // gender  // name  // values() 方法用于返回一个迭代器，该迭代器包含了所有查询参数的值。  for (const value of searchParams.values()) {    console.log(value);  }  // male  // female  // jerry&lt;/script&gt;</code></pre><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解URL的组成以及获取URL各部分的方法</title>
      <link href="/2023/10/30/25-xiang-jie-url-de-zu-cheng-yi-ji-huo-qu-url-ge-bu-fen-de-fang-fa/"/>
      <url>/2023/10/30/25-xiang-jie-url-de-zu-cheng-yi-ji-huo-qu-url-ge-bu-fen-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>浏览器的URL是<strong>统一资源定位器 （&nbsp;</strong>Uniform Resource Locator&nbsp;<strong>）</strong>的缩写。</p><p>一个完整的URL通常由以下几个部分组成：</p><h3>1. <strong>协议（Protocol）</strong></h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 的协议部分指示浏览器应该使用哪种协议来获取资源。常见的协议有&nbsp;<code>http://</code>、<code>https://</code>、<code>ftp://</code>&nbsp;等。例如，<code>https://example.com</code>&nbsp;中的协议是&nbsp;<code>https://</code>。</p></blockquote><h3>2.&nbsp;<strong>域名（Domain）</strong>&nbsp;</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 的域名部分标识了要访问的服务器的主机名。域名可以是一个 IP 地址或者一个可读性更好的主机名。例如，<code>https://example.com</code>&nbsp;中的域名是&nbsp;<code>example.com</code>。</p></blockquote><h3>3.&nbsp;<strong>端口（Port）</strong>&nbsp;</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 的端口部分指定了服务器上要使用的端口号。如果未指定端口号，则默认使用协议的默认端口。例如，<code>https://example.com:8080</code>&nbsp;中的端口是&nbsp;<code>8080</code>。</p></blockquote><h3>4.&nbsp;<strong>路径（Path）</strong>&nbsp;</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 的路径部分指定了服务器上要访问的资源的路径。路径以斜杠（/）开头，并根据服务器上的目录结构进行指定。例如，<code>https://example.com/path/to/resource</code>&nbsp;中的路径是&nbsp;<code>/path/to/resource</code>。</p></blockquote><h3>5.&nbsp;<strong>查询字符串（Query String）</strong>&nbsp;</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 的查询字符串部分用于向服务器传递参数和数值。查询字符串以问号（?）开头，参数和数值使用键值对的形式进行表示，多个键值对之间使用与号（&amp;）分隔。例如，<code>https://example.com/page?name=John&amp;age=30</code>&nbsp;中的查询字符串是&nbsp;<code>name=John&amp;age=30</code>。</p></blockquote><h3>6.<strong>片段标识（Fragment Identifier）</strong>&nbsp;</h3><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL 的片段标识部分用于指定在资源中的特定位置或锚点。片段标识以井号（#）开头，后面跟着标识符。例如，<code>https://example.com/page#section1</code>&nbsp;中的片段标识是&nbsp;<code>section1</code>。</p></blockquote><h3>&nbsp;如何用js获取URL中各个部分？</h3><p>我在vscode中创建了一个HTML文件，用本地服务器打开后如下：</p><p><img alt="" height="1200" src="/medias/images/URL参数/01.png" width="1200"></p><p>对于测试的URL：</p><blockquote><p><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target" href="http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target" title="http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target">http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target</a></p></blockquote><h4>1.&nbsp;window.location.href：</h4><blockquote><p>URL的整个字符串</p><p>本例返回：<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target" href="http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target" title="http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target">http://127.0.0.1:5501/103002_url.html?name=Jerry&amp;age=18&amp;sex=male#target</a></p></blockquote><h4>&nbsp;2.&nbsp;window.location.protocol：</h4><blockquote><p>URL 的协议部分</p><p>本例返回：http:</p></blockquote><h4>&nbsp;3.&nbsp;window.location.host：</h4><blockquote><p>URL 的主机（IP 地址或域名）和端口。</p><p>本例返回：127.0.0.1:5501</p><p>如果有域名，比如百度（<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="https://www.baidu.com/" href="https://www.baidu.com/" title="https://www.baidu.com/">https://www.baidu.com/</a>）就会返回：www.baidu.com</p></blockquote><h4>&nbsp;4. window.location.port&nbsp;</h4><blockquote><p>URL 的端口部分</p><p>本例返回：5501</p><p>如果采用默认的80端口(即使添加了:80)，那么返回值并不是默认的80而是空字符</p></blockquote><h4>5. window.location.pathname&nbsp;</h4><blockquote><p>URL 的路径部分</p><p>本例返回：/103002_url.html</p></blockquote><h4>6.&nbsp;window.location.search&nbsp;</h4><blockquote><p>URL 的参数部分</p><p>本例返回：?name=Jerry&amp;age=18&amp;sex=male</p></blockquote><h4>7.&nbsp;window.location.hash</h4><blockquote><p>URL的锚点</p><p>本例返回：#target</p></blockquote><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css省略号，单行省略号，多行省略号</title>
      <link href="/2023/10/26/24-css-sheng-lue-hao-dan-xing-sheng-lue-hao-duo-xing-sheng-lue-hao/"/>
      <url>/2023/10/26/24-css-sheng-lue-hao-dan-xing-sheng-lue-hao-duo-xing-sheng-lue-hao/</url>
      
        <content type="html"><![CDATA[<h2>单行省略号&nbsp;</h2><p><img alt="" height="312" src="/medias/images/css省略号/01.png" width="1200"></p><pre><code class="language-javascript">.single-line-ellipsis {    white-space: nowrap;  /* 用于防止文本换行 */    overflow: hidden;     /* 用于隐藏超出容器宽度的内容 */    text-overflow: ellipsis;  /* 用于显示省略号 */}</code></pre><h2>&nbsp;多行省略号</h2><p><img alt="" height="536" src="/medias/images/css省略号/01.png" width="1200"></p><pre><code class="language-javascript">.multi-line-ellipsis {    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 3; /* 显示的行数 */    overflow: hidden;    text-overflow: ellipsis;}</code></pre><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我</p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2中不支持通过数组下标更改数组的值，无法做到响应式，页面没有重新渲染</title>
      <link href="/2023/10/24/23-vue2-zhong-bu-zhi-chi-tong-guo-shu-zu-xia-biao-geng-gai-shu-zu-de-zhi-wu-fa-zuo-dao-xiang-ying-shi-ye-mian-mei-you-chong-xin-xuan-ran/"/>
      <url>/2023/10/24/23-vue2-zhong-bu-zhi-chi-tong-guo-shu-zu-xia-biao-geng-gai-shu-zu-de-zhi-wu-fa-zuo-dao-xiang-ying-shi-ye-mian-mei-you-chong-xin-xuan-ran/</url>
      
        <content type="html"><![CDATA[<p>首先直接看图：data中有一个persons数组，现在想修改第一条数据</p><p><img alt="" height="918" src="/medias/images/vue2中不支持通过数组下标更改数组的值/01.png" width="1200"></p><p></p><pre><code class="language-javascript">methods: {    updateMei(){        // this.persons[0].name = '马老师' //奏效        // this.persons[0].age = 50 //奏效        // this.persons[0].sex = '男' //奏效        this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} //不奏效        // this.persons.splice(0,1,{id:'001',name:'马老师',age:50,sex:'男'}) // 奏效    }}</code></pre><blockquote><p>上述代码中，this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 这行代码是不奏效的，虽然修改了data中的数据，但是页面中模版并没有更新。<img alt="" height="993" src="/medias/images/vue2中不支持通过数组下标更改数组的值/02.png" width="1200"></p></blockquote><p>&nbsp;为什么？尤大给出的解释是：基于性能问题的考虑。</p><p><img alt="" height="863" src="/medias/images/vue2中不支持通过数组下标更改数组的值/03.png" width="1200"></p><blockquote><p>&nbsp;Vue2的官方文档也写了，数组更新检测，只有下面7种方法被vue重写过的，主要做两个操作：1、先调用Array原型上对应的方法。2、重新解析模版，生成虚拟DOM</p></blockquote><p><img alt="" height="773" src="/medias/images/vue2中不支持通过数组下标更改数组的值/04.png" width="1197"></p><blockquote><p>&nbsp;也就是说，通过 this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} 这种直接修改数组下标的方式，vue底层是不会重新解析模版，更新视图的。&nbsp;</p></blockquote><blockquote><p>但是为什么通过数组下标.属性名 this.persons[0].name，这种修改的方式可以更新视图呢？&nbsp;主要是因为数组中对象的属性都被添加了getter/setter<img alt="" height="768" src="/medias/images/vue2中不支持通过数组下标更改数组的值/05.png" width="1200"></p></blockquote><blockquote><p>&nbsp;综上所述：在Vue<span style="color:#fe2c24;">修改数组中的某个元素</span>一定要用如下方法：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.Vue.set() 或 vm.$set()</p></blockquote><blockquote><p>也可以根据实际场景，使用filter、map等方法，对数据过滤处理后，重新赋值，也可以达到更新视图的目的 ：</p><p><img alt="" height="829" src="/medias/images/vue2中不支持通过数组下标更改数组的值/06.png" width="1200"></p></blockquote><blockquote><p>除了通过数组下标的这种修改，此外还要注意的是：通过数组.length修改数组的长度，也不会触发页面的更新 ：</p></blockquote><p><img alt="" height="865" src="/medias/images/vue2中不支持通过数组下标更改数组的值/07.png" width="1200"></p><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解vue2中的this.$set</title>
      <link href="/2023/10/24/22-xiang-jie-vue2-zhong-de-this.set/"/>
      <url>/2023/10/24/22-xiang-jie-vue2-zhong-de-this.set/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 Vue.js 中，this.$set 是一个用于在响应式对象上设置属性的方法。<br>它可以用于在 Vue 实例的数据对象或组件的响应式属性上添加新的属性，确保新添加的属性也是响应式的。</p></blockquote><p>使用 this.$set 的语法如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，object 是要设置属性的对象，key 是要设置的属性名，value 是要设置的属性值。</p><blockquote><p>默认情况下，Vue.js 的响应式系统会在初始化时对数据对象进行递归地劫持，使其成为响应式的。这意味着当你直接给一个已经存在的属性赋值时，Vue 会自动检测到这个变化并更新视图。但是，对于新增加的属性，Vue 无法自动追踪变化，这时就需要使用 this.$set 来手动将新增的属性转换为响应式。</p></blockquote><p>下面是一个示例，演示如何在 Vue 实例中使用 this.$set：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 在 Vue 实例的数据对象中添加一个新属性</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>dataObject<span class="token punctuation">,</span> <span class="token string">'newProperty'</span><span class="token punctuation">,</span> <span class="token string">'new value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在上面的示例中，我们通过 this.$set 方法向 dataObject 对象和组件的响应式属性中添加了一个新的属性 newProperty，并为其赋值为 ‘new value’。这样做可以确保 newProperty 是响应式的，当其值发生变化时，相关的视图也会更新。</p><blockquote><p>需要注意的是，this.$set 只能用于在响应式对象上设置属性。不能直接给vue实例中的data设置属性，错误示范：</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">,</span> <span class="token string">'newProperty'</span><span class="token punctuation">,</span> <span class="token string">'new value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>控制台报错：vue.js:634 [Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.</p></blockquote><blockquote><p>官网也写了注意事项：<br><img src="https://img-blog.csdnimg.cn/0ee97a6a43be4aa2887fe93be5faae5d.png" alt="在这里插入图片描述"></p></blockquote><h2 id="值得一提的是，直接给data中的对象赋值为一个对象，那么对象身上的属性值也是具有响应式的。"><a href="#值得一提的是，直接给data中的对象赋值为一个对象，那么对象身上的属性值也是具有响应式的。" class="headerlink" title="值得一提的是，直接给data中的对象赋值为一个对象，那么对象身上的属性值也是具有响应式的。"></a>值得一提的是，直接给data中的对象赋值为一个对象，那么对象身上的属性值也是具有响应式的。</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      <span class="token literal-property property">myObject</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 将对象属性初始化为空对象</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// Vue.set(this.myObject,'sex','男')    // 生效，响应式</span><span class="token comment">// this.$set(this.myObject,'sex','男')  // 生效，响应式</span><span class="token comment">// this.myObject.sex = '男'             // 不生效，非响应式</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>myObject <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span> <span class="token comment">// 直接给对象赋值为另一个对象，生效，响应式</span>      <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">25</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在上面的示例中，我们在 Vue 实例的 data 中将 myObject 属性初始化为空对象 {}，然后在 mounted 钩子函数中直接将 myObject 赋值为另一个对象。由于赋值为新对象，Vue 的响应式系统会重新劫持 myObject，使其成为响应式的，你可以直接在页面中访问和使用 myObject 的属性。</p></blockquote><p> 如果帮助到您了，可以留下一个赞👍告诉我 </p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解localStorage和sessionStorage，以及两者的区别</title>
      <link href="/2023/10/24/21-xiang-jie-localstorage-he-sessionstorage-yi-ji-liang-zhe-de-qu-bie/"/>
      <url>/2023/10/24/21-xiang-jie-localstorage-he-sessionstorage-yi-ji-liang-zhe-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1>localStorage：</h1><p><code>&nbsp; &nbsp;localStorage</code>&nbsp;是浏览器提供的一种客户端存储机制，用于在用户的浏览器中存储键值对形式的数据。下面是关于&nbsp;<code>localStorage</code>&nbsp;的详细解释：</p><h4>1. 存储数据：</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用&nbsp;<code>localStorage</code>&nbsp;存储数据非常简单。你可以使用 JavaScript 的&nbsp;<code>localStorage</code>&nbsp;对象，在客户端将数据以键值对的形式存储在浏览器中。例如，要存储一个名为 "username" 的值为 "John" 的数据，可以使用以下代码：</p></blockquote><pre><code class="language-javascript">localStorage.setItem("username", "John");</code></pre><h4>2. 获取数据：&nbsp;</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用&nbsp;<code>localStorage</code>&nbsp;获取存储的数据也很简单。你可以使用&nbsp;<code>localStorage.getItem(key)</code>&nbsp;方法，通过指定键来获取对应的值。例如，要获取之前存储的 "username" 的值，可以使用以下代码：</p></blockquote><pre><code class="language-javascript">var username = localStorage.getItem("username");</code></pre><h4>3. 更新数据：</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想更新已存储的数据，只需使用相同的键来设置新的值即可。例如，要更新之前存储的 "username" 的值为 "Jane"，可以使用以下代码：</p></blockquote><pre><code class="language-javascript">localStorage.setItem("username", "Jane");</code></pre><h4>4. 删除数据：&nbsp;</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用&nbsp;<code>localStorage.removeItem(key)</code>&nbsp;方法来删除特定键的数据。例如，要删除之前存储的 "username" 的数据，可以使用以下代码：</p></blockquote><pre><code class="language-javascript">localStorage.removeItem("username");</code></pre><h4>5. 清空数据：</h4><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想一次性删除所有存储在&nbsp;<code>localStorage</code>&nbsp;中的数据，可以使用&nbsp;<code>localStorage.clear()</code>&nbsp;方法。例如，要清空所有数据，可以使用以下代码：</p></blockquote><pre><code class="language-javascript">localStorage.clear();</code></pre><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在&nbsp;<code>localStorage</code>&nbsp;中存储对象时，需要将对象转换为字符串形式，因为&nbsp;<code>localStorage</code>&nbsp;只能存储字符串数据。你可以使用&nbsp;<code>JSON.stringify()</code>&nbsp;方法将对象转换为 JSON 字符串，然后将其存储在&nbsp;<code>localStorage</code>&nbsp;中。当需要使用存储的对象时，可以使用&nbsp;<code>JSON.parse()</code>&nbsp;方法将 JSON 字符串转换回原始的 JavaScript 对象。以下是一个示例，演示如在&nbsp;<code>localStorage</code>&nbsp;中存储和获取对象：</p></blockquote><pre><code class="language-javascript">// 存储对象var user = {  name: "John",  age: 30,  email: "john@example.com"};localStorage.setItem("user", JSON.stringify(user));// 获取对象var storedUser = localStorage.getItem("user");var parsedUser = JSON.parse(storedUser);console.log(parsedUser.name); // 输出 "John"console.log(parsedUser.age); // 输出 30console.log(parsedUser.email); // 输出 "john@example.com"</code></pre><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例中，我们首先使用&nbsp;<code>JSON.stringify()</code>&nbsp;方法将&nbsp;<code>user</code>&nbsp;对象转换为 JSON 字符串，然后使用&nbsp;<code>localStorage.setItem()</code>&nbsp;方法将其存储在&nbsp;<code>localStorage</code>&nbsp;中。当我们需要获取存储的对象时，我们使用&nbsp;<code>localStorage.getItem()</code>&nbsp;方法获取存储的 JSON 字符串，然后使用&nbsp;<code>JSON.parse()</code>&nbsp;方法将其转换回原始的 JavaScript 对象。</p><p></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，存储在&nbsp;<code>localStorage</code>&nbsp;中的对象经过序列化和反序列化的过程，会丢失对象的方法和原型信息，只保留对象的属性和值。因此，在使用存储的对象时，需要确保对象的方法和原型信息已经重新设置。</p></blockquote><h1><strong>&nbsp;<code>sessionStorage：</code></strong></h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>sessionStorage</code>&nbsp;的语法与<code>localStorage</code>的一致，如上面示例，只需把<code>localStorage</code>对象换成<code>sessionStorage</code>&nbsp;对象就行。下面主要说说两者的区别：</p></blockquote><h1>区别：</h1><p><strong>1. 作用域不同：</strong></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>sessionStorage</code>&nbsp;的作用域限定在当前会话（当前浏览器标签页或窗口），而&nbsp;<code>localStorage</code>&nbsp;的作用域是永久的，数据在不同会话（遵循同源策略）之间共享。</p></blockquote><p><strong>2. 生命周期不同：</strong></p><blockquote><p><code>&nbsp; &nbsp;sessionStorage</code>&nbsp;的数据在会话结束时被清除，即当用户关闭浏览器标签页或窗口时，<code>sessionStorage</code>&nbsp;中的数据会被删除。而&nbsp;<code>localStorage</code>&nbsp;的数据是持久化的，除非被显式清除，否则会一直保存在客户端。</p></blockquote><p>&nbsp;关于<code>sessionStorage</code>&nbsp;的生命周期，还想多说几句：<code>sessionStorage</code>&nbsp;是当前浏览器tab页有效，只要当前浏览器的标签关闭，<code>sessionStorage</code>&nbsp;中的数据就会被清空，无需整个浏览器关闭。</p><h4>&nbsp;3.&nbsp;<strong>存储容量不同：</strong></h4><blockquote><p><code>&nbsp; &nbsp;sessionStorage</code>&nbsp;的存储容量通常比&nbsp;<code>localStorage</code>&nbsp;小。一般来说，<code>sessionStorage</code>&nbsp;的容量限制在 5MB 左右，而&nbsp;<code>localStorage</code>&nbsp;的容量限制通常在 5MB 到 10MB 之间，不同浏览器可能会有所不同。</p></blockquote><h4>4.&nbsp;<strong>数据共享不同：</strong>&nbsp;</h4><blockquote><p><code>&nbsp; &nbsp;sessionStorage</code>&nbsp;的数据在同一个浏览器标签页或窗口中共享，但不会跨标签页或窗口共享。而&nbsp;<code>localStorage</code>&nbsp;的数据在同一个域名下的所有标签页和窗口中共享。</p></blockquote><p>&nbsp;关于<code>sessionStorage</code>&nbsp;的问题：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器打开了两个标签，访问相同的URL，在其中一个页面点击按钮清空<code>sessionStorage</code>&nbsp;，会对另外一个标签的<code>sessionStorage</code>&nbsp;有影响吗？</p><p>答案是不会。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在浏览器中，每个标签页都有自己独立的 `sessionStorage` 对象，用于存储会话级别的数据。如果你在一个标签页中执行了清空 `sessionStorage` 的操作，它只会清空当前标签页的 `sessionStorage`，不会对其他标签页的 `sessionStorage` 产生直接影响。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当你在一个标签页中清空了 `sessionStorage`，其他标签页中的 `sessionStorage` 数据将保持不变，不会被自动清空。每个标签页都有自己独立的存储空间，它们之间是相互隔离的。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是&nbsp;<code>localStorage</code>&nbsp;，则会有影响。因为<code>localStorage</code>&nbsp;遵循浏览器的同源策略（Same Origin Policy）。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同源策略是一种安全机制，用于限制不同源（Origin）的网页之间的交互，以防止恶意网页访问其他网页的数据。&nbsp;&nbsp;在同源策略中，两个网页只有在协议、主机和端口都相同的情况下，两个网页才被认为是同源的。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于 `localStorage`，它的同源策略是基于域名的。只有当两个网页具有相同的协议、主机和端口时，它们才能访问相同的 `localStorage` 数据。如果网页的域名不同，即使在同一个浏览器中打开，它们也无法访问彼此的 `localStorage` 数据。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种同源策略的限制是出于安全考虑。通过限制不同源网页之间的交互，可以防止恶意网页窃取用户的敏感数据或进行其他恶意行为。</p></blockquote><h4>5.&nbsp;<strong>数据访问方式不同：</strong>&nbsp;</h4><blockquote><p><code>&nbsp; &nbsp;sessionStorage</code>&nbsp;和&nbsp;<code>localStorage</code>&nbsp;分别通过 JavaScript 的&nbsp;<code>sessionStorage</code>&nbsp;和&nbsp;<code>localStorage</code>&nbsp;对象进行访问和操作。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据你的需求，选择适合的存储方式。如果你需要在会话期间存储临时数据，且数据不需要在不同标签页或窗口之间共享，可以使用&nbsp;<code>sessionStorage</code>。如果你需要永久性地存储数据，或者需要在不同标签页或窗口之间共享数据，可以使用&nbsp;<code>localStorage</code>。&nbsp;</p></blockquote><p>&nbsp;</p><p>如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI的el-table表格分页的序号问题</title>
      <link href="/2023/10/12/20-elementui-de-el-table-biao-ge-fen-ye-de-xu-hao-wen-ti/"/>
      <url>/2023/10/12/20-elementui-de-el-table-biao-ge-fen-ye-de-xu-hao-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>问题现象：</p><p><img alt="" height="335" src="/medias/images/el-table表格分页的序号问题/01.png" width="1131"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el-table结合el-pagination实现表格分页功能时，当需要在表格的第一列显示序号，并且点击分页时，如果不做处理，序号每页都是从1开始。如果想实现自增长的效果，需要做如下处理：</p></blockquote><pre><code class="language-javascript">&lt;el-table size="mini" :data="tableData" height="250" border style="width: 100%"&gt;    &lt;el-table-column        type="index"        width="90"        :index="indexMethod"        label="Index"&gt;    &lt;/el-table-column&gt;&lt;/el-table&gt;</code></pre><pre><code class="language-javascript">indexMethod(index) {    // this.currentPage 当前页码    // this.listStep 每页条数    return (this.currentPage- 1) * this.pageSize + index + 1;}</code></pre><p><img alt="" height="1054" src="/medias/images/el-table表格分页的序号问题/02.png" width="1200"><img alt="" height="378" src="/medias/images/el-table表格分页的序号问题/03.png" width="1200"></p><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Object.is()方法，以及与比较操作符“===”、“==”的区别</title>
      <link href="/2023/10/11/19-xiang-jie-object.is-fang-fa-yi-ji-yu-bi-jiao-cao-zuo-fu-de-qu-bie/"/>
      <url>/2023/10/11/19-xiang-jie-object.is-fang-fa-yi-ji-yu-bi-jiao-cao-zuo-fu-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<div><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用双等号==进行相等判断时，如果两边的类型不一致，则会进 行强制类型转化后再进行比较。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用三等号===进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</p></blockquote></div><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相 同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</p></blockquote><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Object.is()</code>&nbsp;方法是 JavaScript 中用于比较两个值是否相等的方法。它的行为类似于严格相等运算符（===），但有一些特殊的情况需要注意。</p></blockquote><p><span style="color:#0d0016;">&nbsp;</span><strong><span style="color:#0d0016;"><code>Object.is()</code></span>&nbsp;</strong>方法的语法如下：</p><pre><code class="language-javascript">Object.is(value1, value2)</code></pre><p>其中，<code>value1</code>&nbsp;和&nbsp;<code>value2</code>&nbsp;是要进行比较的两个值。</p><p><span style="color:#0d0016;"><strong><code>Object.is()</code></strong></span>&nbsp;方法比较两个值并返回一个布尔值，表示这两个值是否相等。它的比较规则如下：</p><blockquote><ul><li>如果两个值都是&nbsp;<code>undefined</code>，则它们相等。</li>    <li>如果两个值都是&nbsp;<code>null</code>，则它们相等。</li>    <li>如果两个值都是&nbsp;<code>NaN</code>，则它们相等。</li>    <li>如果两个值都是同一个对象（引用相等），则它们相等。</li>    <li>如果两个值都是字符串，并且它们包含相同的字符序列，则它们相等。</li>    <li>如果两个值都是数字，并且它们有相同的值（包括正零、负零和&nbsp;<code>NaN</code>），则它们相等。</li>    <li>如果两个值都是布尔值，并且它们具有相同的值（<code>true</code>&nbsp;或&nbsp;<code>false</code>），则它们相等。</li></ul></blockquote><blockquote><p>除了上述情况外，<code>Object.is()</code>&nbsp;方法将返回&nbsp;<code>false</code>。</p></blockquote><p>下面是一些示例：</p><pre><code class="language-javascript">Object.is(5, 5); // trueObject.is('hello', 'hello'); // trueObject.is({}, {}); // falseObject.is([], []); // falseObject.is(null, null); // trueObject.is(undefined, undefined); // trueObject.is(NaN, NaN); // trueObject.is(0, -0); // falseObject.is(true, true); // true</code></pre><blockquote><p>&nbsp;需要注意的是，<code>Object.is()</code>&nbsp;方法与&nbsp;<code>==</code>&nbsp;和&nbsp;<code>===</code>&nbsp;运算符有一些不同之处。例如，<code>===</code>&nbsp;运算符将&nbsp;<code>-0</code>&nbsp;和&nbsp;<code>+0</code>&nbsp;视为相等，但&nbsp;<code>Object.is()</code>&nbsp;方法将它们视为不相等。同样，<code>===</code>&nbsp;运算符将&nbsp;<code>NaN</code>&nbsp;与任何其他值都视为不相等，但&nbsp;<code>Object.is()</code>&nbsp;方法将&nbsp;<code>NaN</code>&nbsp;视为相等。</p></blockquote><p>在实际使用中，你可以根据具体的比较需求选择使用&nbsp;<code>Object.is()</code>&nbsp;方法或其他比较方式&nbsp;</p><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录ElementUI的bug：v-loading设置文本无效</title>
      <link href="/2023/10/08/18-ji-lu-elementui-de-bug-v-loading-she-zhi-wen-ben-wu-xiao/"/>
      <url>/2023/10/08/18-ji-lu-elementui-de-bug-v-loading-she-zhi-wen-ben-wu-xiao/</url>
      
        <content type="html"><![CDATA[<h1><a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.6/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N7T8" data-link-title="el-input上v-loding添加element-loading-text不起作用？" href="https://segmentfault.com/q/1010000043716620" title="el-input上v-loding添加element-loading-text不起作用？">el-input上v-loding添加element-loading-text不起作用？</a></h1><p>想要的效果如下图：</p><p>可以自定义文案、图标和背景色</p><p><img alt="" height="502" src="/medias/images/v-loading设置文本无效/01.png" width="1200"></p><p>参考ElementUI的文档，在el-input标签上添加了如下属性：</p><pre><code class="language-javascript">v-loading="dialogGenerateSQLLoading"element-loading-text="拼命加载中"element-loading-spinner="el-icon-loading"</code></pre><p>但是并不生效，一直是默认的加载效果：</p><p><img alt="" height="376" src="/medias/images/v-loading设置文本无效/02.png" width="1200"></p><p>应该是ElementUI的bug，解决方案：</p><p>给el-input标签加一个div父元素，给div元素添加上面的属性，就可以了</p><p><img alt="" height="56" src="/medias/images/v-loading设置文本无效/03.png" width="906"></p><p>最终效果：</p><p><img alt="" height="290" src="/medias/images/v-loading设置文本无效/04.png" width="1200"></p><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2项目实现自定义右键菜单, 可添加图标、事件等</title>
      <link href="/2023/08/31/17-vue2-xiang-mu-shi-xian-zi-ding-yi-you-jian-cai-dan-ke-tian-jia-tu-biao-shi-jian-deng/"/>
      <url>/2023/08/31/17-vue2-xiang-mu-shi-xian-zi-ding-yi-you-jian-cai-dan-ke-tian-jia-tu-biao-shi-jian-deng/</url>
      
        <content type="html"><![CDATA[<p>通常浏览器都会有自己的右键菜单，如下图的谷歌浏览器网页上的右键菜单：</p><p><img alt="" height="281" src="/medias/images/vue2项目实现自定义右键菜单/01.png" width="236"></p><p>下面介绍一下如何在vue的项目中实现自定义菜单，如下图所示 ：</p><p><img alt="" height="264" src="/medias/images/vue2项目实现自定义右键菜单/02.png" width="393"></p><p>1. 安装依赖包</p><pre><code class="language-javascript">npm install vue-contextmenujs</code></pre><p>2. 在main.js中引用</p><pre><code class="language-javascript">import Contextmenu from 'vue-contextmenujs';Vue.use(Contextmenu);</code></pre><p>3. 在需要实现自定义右键的元素上加上&nbsp;@contextmenu.prevent="onContextmenu"</p><pre><code class="language-javascript">&lt;div class="CodeMirror-Contain" @contextmenu.prevent="onContextmenu"&gt;    &lt;textarea ref="codeMirror"&gt;&lt;/textarea&gt;&lt;/div&gt;</code></pre><p>4. methods中添加方法</p><pre><code class="language-javascript">// 鼠标右键事件onContextmenu(event) {    this.$contextmenu({        items: this.contextMenuData,        event, // 鼠标事件信息        customClass: 'custom-class', // 自定义菜单 class        zIndex: 3, // 菜单样式 z-index        minWidth: 230 // 主菜单最小宽度    });    return false;},</code></pre><p>5.&nbsp; contextMenuData 的数据如下</p><pre><code class="language-javascript">this.contextMenuData = [    {        label: '运行',        icon: 'iconfont icon-zhihang',        onClick: () =&gt; {            this.onRunCode();        }    },    {        label: '运行',        icon: 'iconfont icon-sql_exec_new',        onClick: () =&gt; {            this.onRunCodeNewTab();        }    },    {        label: '收藏',        icon: 'iconfont icon-baocun1',        divided: true,        onClick: () =&gt; {            this.onCommitOrder();        }    },    {        label: '格式化',        icon: 'iconfont icon-geshihua1',        onClick: () =&gt; {            this.onFormatSQL();        }    }];</code></pre><blockquote><p>contextMenuData中，label是文字，onClick是绑定的点击事件，icon是图标，我这里用的阿里的iconfont，如果想使用ElementUI的图标，可以把icon的值设置为&nbsp;icon el-icon-edit。第一个参数必填，固定为icon，第二个参数就是ElementUI图标库里对应的类名。</p></blockquote><pre><code class="language-javascript">icon: 'icon el-icon-edit',</code></pre><p><img alt="" height="190" src="/medias/images/vue2项目实现自定义右键菜单/03.png" width="522"></p><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript如何判断数据类型，以及typeof 、instanceof 的区别，Object.prototype.toString的返回值</title>
      <link href="/2023/08/23/16-javascript-ru-he-pan-duan-shu-ju-lei-xing-yi-ji-typeof-instanceof-de-qu-bie-object.prototype.tostring-de-fan-hui-zhi/"/>
      <url>/2023/08/23/16-javascript-ru-he-pan-duan-shu-ju-lei-xing-yi-ji-typeof-instanceof-de-qu-bie-object.prototype.tostring-de-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<h3>typeof&nbsp;</h3><blockquote><p>typeof 只能判断出基本数据类型，会将<span style="color:#000000;">数组、对象、null 都会被判断为 object。具体的typeof使用可以参考我另一篇的博客：</span><a data-link-desc="typeof 总是返回一个字符串，返回值共八种包括：'number'、'bigint'、'string'、'boolean'、'undefined'、'symbol'、'object'、'function'" data-link-icon="https://g.csdnimg.cn/static/logo/favicon32.ico" data-link-title="整理typeof返回值_程序猿小野的博客-CSDN博客" href="https://blog.csdn.net/weixin_42289279/article/details/131373980?spm=1001.2014.3001.5501" title="整理typeof返回值_程序猿小野的博客-CSDN博客">整理typeof返回值_程序猿小野的博客-CSDN博客</a></p></blockquote><h3>&nbsp;instanceof</h3><blockquote><p>instanceof 可以正确判断对象的类型，其内部运行机制是判断在其 原型链中能否找到该类型的原型。</p></blockquote><pre><code class="language-javascript">console.log(undefined instanceof undefined); // TypeError: Right-hand side of 'instanceof' is not an objectconsole.log(null instanceof null) // TypeError: Right-hand side of 'instanceof' is not an object</code></pre><blockquote><p>不能判断unll和undefined，直接报错</p></blockquote><pre><code class="language-javascript">console.log(2 instanceof Number) // flaseconsole.log('123abc' instanceof String) // flaseconsole.log(true instanceof Boolean) // flaseconsole.log(new String() instanceof String) // trueconsole.log(new String('String created with constructor') instanceof String) // trueconsole.log(new Number() instanceof Number) // trueconsole.log(new Date() instanceof Object) // trueconsole.log([] instanceof Array) // trueconsole.log(function () {} instanceof Function) // trueconsole.log({} instanceof Object) // true</code></pre><blockquote><p>&nbsp;&nbsp;可以看到，instanceof 只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链 中是否存在一个构造函数的 prototype 属性。</p></blockquote><pre><code class="language-javascript">function C() {}var c = new C()console.log(c instanceof C) // true，因为 Object.getPrototypeOf(c) === C.prototypeconsole.log(c.__proto__ === C.prototype); // trueC.prototype = {}console.log(c instanceof C) // false，C.prototype 指向了一个空对象,这个空对象不在 c 的原型链上.console.log(c.__proto__ === C.prototype); // false</code></pre><h3>&nbsp;总结typeof 和 instanceof 的区分</h3><blockquote><p>1. typoof 和 instanceof 都无法判断null，typoof返回Object，instanceof报错</p><p>2. typeof 可以判断undefined，而 instanceof 判断会报错</p><p>3.&nbsp;typeof 无法判断Array和Object，instanceof 可以</p><p>4. type 判断undefined 和null的区别（两个变量类型之间）</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof undefined // "undefined"</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typeof null // "object"</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined == null // true</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined === null // false</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined != null // false</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;undefined !== null // true</p></blockquote><h3>Object.prototype.toString:</h3><pre><code class="language-javascript">console.log(Object.prototype.toString.call(1)) // "[object Number]"console.log(Object.prototype.toString.call('hi')) // "[object String]"console.log(Object.prototype.toString.call({ a: 'hi' })) // "[object Object]"console.log(Object.prototype.toString.call([1, 'a'])) // "[object Array]"console.log(Object.prototype.toString.call(true)) // "[object Boolean]"console.log(Object.prototype.toString.call(() =&gt; {})) // "[object Function]"console.log(Object.prototype.toString.call(null)) // "[object Null]"console.log(Object.prototype.toString.call(undefined)) // "[object Undefined]"console.log(Object.prototype.toString.call(Symbol(1))) // "[object Symbol]"console.log(Object.prototype.toString.call(BigInt(1))) // "[object BigInt]"</code></pre><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JS方法之slice、splice、substring、substr</title>
      <link href="/2023/08/23/15-xiang-jie-js-fang-fa-zhi-slice-splice-substring-substr/"/>
      <url>/2023/08/23/15-xiang-jie-js-fang-fa-zhi-slice-splice-substring-substr/</url>
      
        <content type="html"><![CDATA[<h3>1. slice()</h3><blockquote><p>slice(start, end):</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串和数组都可以使用slice方法。slice 方法用于从字符串或数组中提取指定范围的子串或子数组，并返回一个新的字符串或数组。<strong>并不会改变原字符串和数组</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它接受两个参数，start 表示起始位置（包含），end 表示结束位置（不包含）。如果省略 end 参数，则提取从 start 位置到字符串或数组末尾的所有元素。</p></blockquote><pre><code class="language-javascript">const str = 'Hello, World!'console.log(str.slice(7, 12)) // "World"const arr = [1, 2, 3, 4, 5]console.log(arr.slice(2, 4)) // [3, 4]console.log(str.slice(1)) // ello, World!console.log(arr.slice(1)) // [2, 3, 4, 5]// 如果start是负数，则会从数组尾部开始算起。这里只有start没有end,且start为负数，所以只能获取到最后1个元素console.log(str.slice(-1)) // !console.log(arr.slice(-1)) // [ 5 ]console.log(str.slice(1, -1)) // ello, Worldconsole.log(arr.slice(1, -1)) // [ 2, 3, 4 ]// 获取除了最后1个元素以外的全部元素console.log(str.slice(0, -1)) // Hello, Worldconsole.log(arr.slice(0, -1)) // [ 1, 2, 3, 4 ]// 都为负数，值为空字符创或空数组console.log(str.slice(-1, -1)) // ""console.log(arr.slice(-1, -1)) // []</code></pre><h3>2. splice ()</h3><blockquote><p>splice(start, deleteCount, item1, item2, ...)：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splice 方法用于修改原始数组，可以删除、替换或插入元素，并返回被删除的元素组成的数组。它接受多个参数，其中 start 表示起始位置，deleteCount 表示要删除的元素个数，item1, item2, ... 表示要插入的新元素。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>splice 方法不可以用于字符串</strong></p></blockquote><pre><code class="language-javascript">const arr1 = [1, 2, 3, 4, 5]console.log(arr1.splice(2, 2, 6, 7)) // 从数组下标2的位置，删除2个元素，并添加6和7两个值// [ 3, 4 ] splice方法的返回值是被删除的元素组成的数组。console.log(arr1) // arr1 变为 [1, 2, 6, 7, 5]const arr2 = [1, 2, 3, 4, 5]console.log(arr2.splice(2, 0, 6)) // [] 从数组下标2的位置，删除0个元素，并添加6console.log(arr2) // arr2 变为 [ 1, 2, 6, 3, 4, 5 ]const arr3 = [1, 2, 3, 4, 5]console.log(arr3.splice(-1, 1, 6)) // [ 5 ] 返回了数组的最后一位，并添加6console.log(arr3) // arr3 变为 [ 1, 2, 3, 4, 6 ]const arr4 = [1, 2, 3, 4, 5]console.log(arr4.splice(-1, 0, 6)) // [] 从最后1个元素开始且不删除元素，同时在最后1个元素前面新增1个元素console.log(arr4) // arr4 变为 [ 1, 2, 3, 4, 6, 5 ]const arr5 = [1, 2, 3, 4, 5]console.log(arr5.splice(-1, 3)) // [ 5 ] 截取到数组的最后一个元素后会停止console.log(arr5) // arr5 变为 [ 1, 2, 3, 4 ]const arr6 = [1, 2, 3, 4, 5]console.log(arr6.splice(-1, 2)) // [ 5 ] // 当start为-1时，不管end的值是多少，都表示截取到数组的最后一个元素后会停止console.log(arr6) // arr6 变为 [ 1, 2, 3, 4 ]</code></pre><h3>3. substring()&nbsp;</h3><blockquote><p>substring(start, end)：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;substring 方法用于从字符串中提取指定范围的子串，并返回一个新的字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它接受两个参数，start 表示起始位置（包含），end 表示结束位置（不包含）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果省略 end 参数，则提取从 start 位置到字符串末尾的所有字符。</p></blockquote><pre><code class="language-javascript">const str = 'Hello, World!';console.log(str.substring(7, 12)); // Worldconsole.log(str.substring(1)); // ello, World!console.log(str.substring(0)); // Hello, World!console.log(str.substring(-1)); // Hello, World!console.log(str.substring(2, -2)); // He</code></pre><h3>4. substr()&nbsp;</h3><blockquote><p>substr(start, length)：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;substr 方法用于从字符串中提取指定长度的子串，并返回一个新的字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它接受两个参数，start 表示起始位置（包含），length 表示要提取的字符个数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果省略 length 参数，则提取从 start 位置到字符串末尾的所有字符。</p></blockquote><p></p><pre><code class="language-javascript">const str = 'Hello, World!';console.log(str.substr(7, 1)); // Wconsole.log(str.substr(7, 2)); // Woconsole.log(str.substr(1)); // ello, World!console.log(str.substr(0)); // Hello, World!console.log(str.substr(-1)); // !console.log(str.substr(-3)); // ld!console.log(str.substr(2, -2)); // '' length 不管传0，-1，-2等都返回空字符串</code></pre><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解javascript的reduce()方法，各种场景</title>
      <link href="/2023/08/15/14-xiang-jie-javascript-de-reduce-fang-fa-ge-chong-chang-jing/"/>
      <url>/2023/08/15/14-xiang-jie-javascript-de-reduce-fang-fa-ge-chong-chang-jing/</url>
      
        <content type="html"><![CDATA[<blockquote><p>语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</p></blockquote><blockquote><p>参数：</p><p>1. function(total,currentValue, currentIndex,arr)&nbsp; 必需。用于执行每个数组元素的函数。</p><ul><li>total&nbsp;必需。<em>初始值</em>, 或者计算结束后的返回值。</li>    <li>currentValue&nbsp;必需。当前元素。</li>    <li>currentIndex 可选。当前元素的索引。</li>    <li>arr&nbsp;可选。当前元素所属的数组对象。</li></ul><p>2.&nbsp;initialValue&nbsp;可选。传递给函数的初始值</p></blockquote><p>&nbsp;如何使用？参考如下示例：</p><h3>1. 实现累加，计算数组里所有值的和</h3><pre><code class="language-javascript">let arr = [1, 2, 3, 4, 5]let result = arr.reduce((total, currentValue, currentIndex, arr) =&gt; {    console.log('total', total)    console.log('currentValue', currentValue)    console.log('currentIndex', currentIndex)    console.log('arr', arr)  // total 1  // currentValue 2  // currentIndex 1  // arr [ 1, 2, 3, 4, 5 ]  // total 3  // currentValue 3  // currentIndex 2  // arr [ 1, 2, 3, 4, 5 ]  // total 6  // currentValue 4  // currentIndex 3  // arr [ 1, 2, 3, 4, 5 ]  // total 10  // currentValue 5  // currentIndex 4  // arr [ 1, 2, 3, 4, 5 ]    return total + currentValue})console.log(result) // 15</code></pre><pre><code class="language-javascript">let arr = [1, 2, 3, 4, 5]let result = arr.reduce((total, currentValue, currentIndex, arr) =&gt; {    console.log('total', total)    console.log('currentValue', currentValue)    console.log('currentIndex', currentIndex)    console.log('arr', arr)  // total 10  // currentValue 1  // currentIndex 0  // arr [ 1, 2, 3, 4, 5 ]  // total 11  // currentValue 2  // currentIndex 1  // arr [ 1, 2, 3, 4, 5 ]  // total 13  // currentValue 3  // currentIndex 2  // arr [ 1, 2, 3, 4, 5 ]  // total 16  // currentValue 4  // currentIndex 3  // arr [ 1, 2, 3, 4, 5 ]  // total 20  // currentValue 5  // currentIndex 4  // arr [ 1, 2, 3, 4, 5 ]    return total + currentValue}, 10)console.log(result) // 25</code></pre><blockquote><p>上面两个示例表示，如果没有设置初始值initialValue，那么第一次遍历时的total就是数组的第一项，函数会遍历执行 <strong>数组的长度 - 1</strong> 次。</p><p>如果有设置初始值initialValue，那么第一次遍历时的total就是初始值initialValue，函数会遍历执行 <strong>数组的长度</strong> 次。</p><p>如果有return 语句，第二次遍历时的 total 就是上一次return语句返回的值。如果没有return语句，total返回undefined（一般不会这样使用，都是有return语句的）</p><p>currentIndex是currentValue在数组中的下标值，arr是调用reduce()的数组</p><p>较为常用的就是前两个参数</p></blockquote><h3>2.&nbsp;&nbsp;累加数组中对象的值</h3><pre><code class="language-javascript">let arr = [    { name: 'yee', num: 666 },    { name: 'qian', num: 111 },    { name: 'li', num: 111 },]let result = arr.reduce((prev, next) =&gt; {    return prev + next.num}, 0)console.log(result) // 888</code></pre><h3>3.&nbsp;计算数组中每个元素出现的次数</h3><pre><code class="language-javascript">let arr = ['mysql', 'oracle', 'oracle', 'mysql', 'oracle', 'oracle', 'oceanbase', 'goldendb', 'db2', 'mongodb', 'gbase']let result = arr.reduce(function (prev, next) {    prev[next] = prev[next] + 1 || 1    return prev}, {})console.log(result);// { mysql: 2, oracle: 4, oceanbase: 1, goldendb: 1, db2: 1, mongodb: 1, gbase: 1 }</code></pre><h3>4. 数组去重</h3><pre><code class="language-javascript">let arr = [1, 2, 3, 3, 2, 1, null, null, undefined, true, false, NaN, false, true, undefined]let result = arr.reduce((prev, next) =&gt; {    return prev.includes(next) ? prev : prev.concat(next)}, [])console.log(result); // [ 1, 2, 3, null, undefined, true, false, NaN ]</code></pre><h3>5. 对象数组的去重，相比于第4点，这种实际使用情况更多</h3><pre><code class="language-javascript">// 根据对象的id值去重let arr = [    { id: 1, name: '张三' },    { id: 2, name: '李四' },    { id: 3, name: '王五' },    { id: 1, name: '张三' },]let result = arr.reduce((prev, next) =&gt; {    const isExist = prev.some((item) =&gt; item.id === next.id)    if (!isExist) {        prev.push(next)    }    return prev}, [])console.log(result)// [ { id: 1, name: '张三' }, { id: 2, name: '李四' }, { id: 3, name: '王五' } ]</code></pre><h3>6.&nbsp;将多维数组转为一维数组</h3><pre><code class="language-javascript">// 二维let arr = [    [1, 2, 3],    [4, 5, 6],    [7, 8, 9],]let result = arr.reduce((prev, next) =&gt; {    return prev.concat(next)}, [])console.log(result)// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]// 多维let arr1 = [1, [2, [[3, 4], 5], 6, 7, [8, 9, [10, 11, [12, 13]]]]]function splitArr(arr) {    return arr.reduce((prev, next) =&gt; {        return prev.concat(Array.isArray(next) ? splitArr(next) : next)    }, [])}console.log(splitArr(arr1)) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]console.log(arr1.flat(Infinity)) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 ]// 另：使用ES6中的flat()方法也可以实现// flat(n): n非必填项，n默认是1,表示扁平化深度。Infinity表示不管嵌套多少层。</code></pre><h3>7. 将对象数组，按照对象的某个属性值进行分类</h3><pre><code class="language-javascript">let animals = [    { name: '小明', age: 6, type: 'dog' },    { name: '小芳', age: 18, type: 'person' },    { name: '小红', age: 6, type: 'cat' },    { name: '小野', age: 18, type: 'person' },    { name: '小雨', age: 6, type: 'dog' },    { name: '小龙', age: 18, type: 'person' },    { name: '滚滚', age: 8, type: 'dog' },]function classification(arr, attr) {    if (!Array.isArray(arr)) {        return []    }    return arr.reduce((prev, next) =&gt; {        let obj = prev.find((item) =&gt; item.type == next.type)        if (obj) {            obj.list.push(next)        } else {            prev.push({                [attr]: next[attr],                list: [next],            })        }        return prev    }, [])}console.log(classification(animals, 'type'))// [//   {//       "type": "dog",//       "list": [//           {//               "name": "小明",//               "age": 6,//               "type": "dog"//           },//           {//               "name": "小雨",//               "age": 6,//               "type": "dog"//           },//           {//               "name": "滚滚",//               "age": 8,//               "type": "dog"//           }//       ]//   },//   {//       "type": "person",//       "list": [//           {//               "name": "小芳",//               "age": 18,//               "type": "person"//           },//           {//               "name": "小野",//               "age": 18,//               "type": "person"//           },//           {//               "name": "小龙",//               "age": 18,//               "type": "person"//           }//       ]//   },//   {//       "type": "cat",//       "list": [//           {//               "name": "小红",//               "age": 6,//               "type": "cat"//           }//       ]//   }// ]</code></pre><blockquote><p>除了上述场景，reduce() 方法还可以用于更复杂的数据处理和转换操作。它提供了一种灵活且强大的方式来处理数组中的元素，并生成最终的结果。根据具体的需求，你可以灵活运用 reduce() 方法来解决各种数组操作的问题。</p></blockquote><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL.createObjectURL() 和 FileReader.readAsDataURL() 的区别，大文件下载浏览器崩溃的处理方案</title>
      <link href="/2023/08/09/13-url.createobjecturl-he-filereader.readasdataurl-de-qu-bie-da-wen-jian-xia-zai-liu-lan-qi-beng-kui-de-chu-li-fang-an/"/>
      <url>/2023/08/09/13-url.createobjecturl-he-filereader.readasdataurl-de-qu-bie-da-wen-jian-xia-zai-liu-lan-qi-beng-kui-de-chu-li-fang-an/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：大文件下载（2G以上）。研发和测试环境都没有问题，到现场大文件下载浏览器内存崩溃了。一开始使用 <strong>FileReader.readAsDataURL()</strong> 下载大文件会导致浏览器崩溃，使用<strong>URL.createObjectURL() </strong>之后问题解决。</p></blockquote><h2>FileReader.readAsDataURL()&nbsp;</h2><p>URL.createObjectURL() 和 FileReader.readAsDataURL() 都是用于在浏览器中处理文件的方法，但它们有一些区别。</p><blockquote><p>FileReader.readAsDataURL() 方法用于读取指定的文件，并将其内容转换为 Data URL 字符串。Data URL 是一种将文件内容嵌入到 URL 中的格式，可以直接用于在浏览器中显示文件内容。</p></blockquote><pre><code class="language-javascript">let blob = new Blob([res.data]); // res.data是后台返回的文件let reader = new FileReader();reader.readAsDataURL(blob);reader.onload = (e) =&gt; {    // 转换完成，创建一个a标签用于下载    let a = document.createElement('a');    a.download = fileName;    a.href = e.target.result;    document.body.appendChild(a);    a.click();    document.body.removeChild(a);}</code></pre><p><strong>以上的实现，下载大文件时，导致了浏览器的内存崩溃。&nbsp;</strong></p><p></p><h2>URL.createObjectURL()</h2><blockquote><p>URL.createObjectURL() 方法用于创建一个指向指定文件的 URL。它接受一个参数，即要创建 URL 的文件对象（如 Blob 或 File 对象），然后返回一个表示该文件的 URL 字符串。这个 URL 可以被用于在浏览器中显示或处理文件，下面示例代码使用URL.createObjectURL()实现文件下载：</p></blockquote><pre><code class="language-javascript">let blob = new Blob([res.data]); // res.data是后台返回的文件let eleLink = document.createElement('a');eleLink.download = fileName;eleLink.style.display = 'none';const url = URL.createObjectURL(blob);// 将生成的url赋值给a标签的href属性eleLink.href = url;// 添加到dom节点body上document.body.appendChild(eleLink);// 触发点击eleLink.click();// 然后移除document.body.removeChild(eleLink);// 释放URL, 这样可以确保及时释放资源，避免内存泄漏问题。URL.revokeObjectURL(url);</code></pre><h3>下载大文件时， FileReader.readAsDataURL()比较卡，URL.createObjectURL() 不卡，是为什么？</h3><p>FileReader.readAsDataURL() 和 URL.createObjectURL() 是两种不同的方法，它们在处理大文件时的性能和效果可能会有所不同。</p><blockquote><p>FileReader.readAsDataURL() 方法是将文件内容读取为 Data URL（Base64 编码的字符串）。这意味着它会将整个文件内容转换为一个非常长的字符串，这在处理大文件时可能会导致性能问题。因为将整个文件内容转换为 Data URL 需要耗费大量的内存和计算资源。</p></blockquote><blockquote><p>相比之下，URL.createObjectURL() 方法是为文件创建一个临时的 URL，可以直接访问文件内容。这个 URL 可以被用于加载文件，而不需要将整个文件转换为字符串。因此，URL.createObjectURL() 方法在处理大文件时可能更高效，因为它不需要将整个文件内容读取到内存中。</p></blockquote><blockquote><p>所以，如果你需要处理大文件并且关注性能，可以考虑使用 URL.createObjectURL() 方法来加载文件，而不是使用 FileReader.readAsDataURL() 方法。但是需要注意的是，使用 URL.createObjectURL() 方法创建的 URL 是临时的，使用完后需要及时释放，以避免内存泄漏。</p></blockquote><h3>将URL.createObjectURL(blob)赋值给dom属性，再移除掉这个dom，此时URL释放了嘛？</h3><blockquote><p>当你使用URL.createObjectURL(blob)创建一个URL，并将它赋值给DOM属性后，如果你移除了这个DOM元素，URL并不会立即释放。相反，URL会一直保持有效，直到你显式地调用URL.revokeObjectURL(url)来释放它。</p></blockquote><blockquote><p>调用URL.revokeObjectURL(url)会告诉浏览器该URL不再需要，浏览器会立即释放相关的资源。所以，如果你不再需要这个URL，记得在移除DOM元素后调用URL.revokeObjectURL(url)来释放它。这样可以确保及时释放资源，避免内存泄漏问题。</p></blockquote><p>以下是一个示例代码，演示了如何使用URL.createObjectURL()和URL.revokeObjectURL()：</p><pre><code class="language-javascript">// 创建URLconst url = URL.createObjectURL(blob);// 将URL赋值给DOM属性domElement.src = url;// 移除DOM元素domElement.remove();// 释放URLURL.revokeObjectURL(url);</code></pre><p></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 文件下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何判断数组中是否存在某个值或者某个对象的属性值</title>
      <link href="/2023/08/01/12-js-ru-he-pan-duan-shu-zu-zhong-shi-fou-cun-zai-mou-ge-zhi-huo-zhe-mou-ge-dui-xiang-de-shu-xing-zhi/"/>
      <url>/2023/08/01/12-js-ru-he-pan-duan-shu-zu-zhong-shi-fou-cun-zai-mou-ge-zhi-huo-zhe-mou-ge-dui-xiang-de-shu-xing-zhi/</url>
      
        <content type="html"><![CDATA[<h1><strong>一、判断数组是否存在某个值</strong></h1><h3>1、indexOf()</h3><blockquote><p>indexOf() 方法可返回数组中某个指定的元素位置。该方法将从头到尾地检索数组，看它是否含有对应的元素。开始检索的位置在数组 start 处或数组的开头（没有指定 start 参数时）。如果找到一个 item，则返回 item 的第一次出现的位置。开始位置的索引为 0。</p><p>如果在数组中没找到指定元素则返回 -1。</p></blockquote><pre><code class="language-javascript">let animals = ['dog', 'cat', 'mouse', 'tiger', 'fish', 'cat']; console.log(animals.indexOf('dog')); // 0 console.log(animals.indexOf('cat')); // 1// 从index为2的位置开始查找console.log(animals.indexOf('cat', 2)); // 5 console.log(animals.indexOf('giraffe')); // -1</code></pre><h3>2、lastIndexOf()&nbsp;</h3><blockquote><p>lastIndexOf()&nbsp;方法将从尾到头地检索数组中指定元素 item。开始检索的位置在数组的 start 处或数组的结尾（没有指定 start 参数时）。如果找到一个 item，则返回 item 从尾向前检索第一个次出现在数组的位置。数组的索引开始位置是从 0 开始的。如果在数组中没找到指定元素则返回 -1。</p></blockquote><pre><code class="language-javascript">let animals = ['dog', 'cat', 'mouse', 'tiger', 'fish', 'cat']; console.log(animals.lastIndexOf('dog')); // 0 console.log(animals.lastIndexOf('cat')); // 5// 从index为2的位置开始查找console.log(animals.lastIndexOf('cat', 2)); // 1 console.log(animals.lastIndexOf('giraffe')); // -1</code></pre><h3>3、includes()</h3><blockquote><p>includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p><p>arr.includes(searchElement)<br>arr.includes(searchElement, fromIndex)</p><p>第一个参数必传，需要查找的元素值。第二个参数可选，从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</p></blockquote><pre><code class="language-javascript">console.log([1, 2, 3].includes(2));     // trueconsole.log([1, 2, 3].includes(4));     // falseconsole.log([1, 2, 3].includes(3, 3));  // falseconsole.log([1, 2, 3].includes(3, -1)); // trueconsole.log([2, 1].includes(2, -1));    // fasleconsole.log([1, 2].includes(2, -1));    // trueconsole.log([1, 2, NaN].includes(NaN)); // true</code></pre><h3>4、find()</h3><blockquote><p>find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p><p>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回&nbsp;<em>true</em>&nbsp;时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li>    <li>如果没有符合条件的元素返回 undefined</li></ul><p><strong>注意:</strong>&nbsp;find() 对于空数组，函数是不会执行的。</p><p><strong>注意:</strong>&nbsp;find() 并没有改变数组的原始值。</p></blockquote><pre><code class="language-javascript">let ages = [3, 10, 18, 20, 30];let age = ages.find(item =&gt; item &gt; 18);console.log(age); // 20let age2 = ages.find(item =&gt; item &gt;= 18);console.log(age2); // 18let age3 = ages.find(item =&gt; item == 40);console.log(age3); // undefined</code></pre><h3>5、findIndex()&nbsp;</h3><blockquote><p>findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p><p>findIndex() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回&nbsp;<em>true</em>&nbsp;时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</li>    <li>如果没有符合条件的元素返回 -1</li></ul><p><strong>注意:</strong>&nbsp;findIndex() 对于空数组，函数是不会执行的。</p><p><strong>注意:</strong>&nbsp;findIndex() 并没有改变数组的原始值。</p></blockquote><pre><code class="language-javascript">let ages = [3, 10, 18, 20, 30];let index = ages.findIndex(item =&gt; item &gt; 18);console.log(index); // 3let index2 = ages.findIndex(item =&gt; item &gt;= 18);console.log(index2); // 2let index3 = ages.findIndex(item =&gt; item == 40);console.log(index3); // -1</code></pre><h1>二、判断数组的对象中是否包含某个属性值&nbsp;</h1><p>这种场景下，indexOf、lastIndexOf、includes都不适用。</p><h3>1、find()</h3><p>用法同上4，直接上代码</p><pre><code class="language-javascript">let arr = [    { id: 1, name: 'name1' },    { id: 2, name: 'name2' },    { id: 3, name: 'name3' },]let obj = arr.find(item =&gt; item.name == 'name2');console.log(obj); // { id: 2, name: 'name2' }let obj2 = arr.find(item =&gt; item.id == 4);console.log(obj2); // undefined</code></pre><h3>2、findIndex()</h3><p>用法同上5，直接上代码</p><pre><code class="language-javascript">let arr = [    { id: 1, name: 'name1' },    { id: 2, name: 'name2' },    { id: 3, name: 'name3' },]let index = arr.findIndex((item) =&gt; item.name == 'name2')console.log(index) // 1let index2 = arr.findIndex((item) =&gt; item.id == 4)console.log(index2) // -1</code></pre><h3>3、some()</h3><blockquote><p>some()&nbsp;方法的返回值是一个布尔值，如果数组中<strong>至少有一个</strong>元素满足条件，则返回&nbsp;<strong>true</strong>，剩余的元素不会再执行检测，所有元素都不满足条件时才返回&nbsp;<strong>false。</strong></p><p></p><p>关于js的some方法和every方法，我单独写了一篇博客，深入了解请移步：<a data-link-desc="上述示例代码中，some 方法会遍历数组 array 中的每个对象，并使用回调函数判断当前对象的 name 属性是否等于目标名称 targetName。除了判断数组中是否存在某个值，some 方法还可以用于判断数组中是否存在满足其他条件的元素，比如判断数组中是否存在某个对象的值等。它会遍历数组中的每个元素，并对每个元素应用一个回调函数，只有当所有元素都满足条件时，every() 方法才会返回 true，否则返回 false。它会遍历数组中的每个元素，直到找到满足条件的元素或遍历完整个数组。" data-link-icon="https://g.csdnimg.cn/static/logo/favicon32.ico" data-link-title="深入浅出JavaScript中的some()方法和every()方法_程序猿小野的博客-CSDN博客" href="https://blog.csdn.net/weixin_42289279/article/details/132043130?spm=1001.2014.3001.5501" title="深入浅出JavaScript中的some()方法和every()方法_程序猿小野的博客-CSDN博客">深入浅出JavaScript中的some()方法和every()方法_程序猿小野的博客-CSDN博客</a></p></blockquote><pre><code class="language-javascript">let arr = [    { id: 1, name: 'name1' },    { id: 2, name: 'name2' },    { id: 3, name: 'name3' },]function checkValInArr(arr, id) {    return arr.some((item) =&gt; item.id == id)}console.log(checkValInArr(arr, 3)) // trueconsole.log(checkValInArr(arr, 4)) // false</code></pre><p>&nbsp;正所谓条条大路通罗马，实现的方式其实有很多种，总结了这些，希望对你有帮助！</p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出JavaScript中的some()方法和every()方法</title>
      <link href="/2023/08/01/11-shen-ru-qian-chu-javascript-zhong-de-some-fang-fa-he-every-fang-fa/"/>
      <url>/2023/08/01/11-shen-ru-qian-chu-javascript-zhong-de-some-fang-fa-he-every-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2>some()&nbsp;</h2><blockquote><p>some() 方法是 JavaScript 数组的一个内置方法，用于检测数组中是否<span style="color:#fe2c24;"><strong>至少有一个</strong></span>元素满足指定的条件。它会遍历数组中的每个元素，直到找到满足条件的元素或遍历完整个数组。</p></blockquote><p>some() 方法的语法如下：</p><pre><code class="language-javascript">array.some(function(currentValue,index,arr),thisValue)</code></pre><blockquote><p>参数说明：<br>- function：必需，用于测试每个元素的回调函数，可以接受三个参数：<br>&nbsp; - currentValue：必需，当前元素的值。<br>&nbsp; - index：可选，当前元素的索引值。<br>&nbsp; - array：可选，当前元素属于的数组对象。<br>- thisValue：可选，执行回调函数时使用的 `this` 值。</p></blockquote><blockquote><p>some()&nbsp;方法的返回值是一个布尔值，如果数组中<span style="color:#fe2c24;"><strong>至少有一个</strong></span>元素满足条件，则返回 <strong>true</strong>，剩余的元素不会再执行检测，所有元素都不满足条件时才返回 <strong>false</strong></p></blockquote><p>下面是一个使用 some&nbsp;方法判断数组中是否存在某个值的示例代码：</p><pre><code class="language-javascript">const array = [1, 2, 3, 4, 5];const targetValue = 3;const isValueExist = array.some(element =&gt; element === targetValue);console.log(isValueExist); // 输出 true</code></pre><p>上述示例代码中，some&nbsp;方法会遍历数组array 中的每个元素，并使用回调函数判断当前元素是否等于目标值 targetValue。如果找到了一个元素等于目标值，则返回 true，否则返回 false。</p><p>除了判断数组中是否存在某个值，some&nbsp;方法还可以用于判断数组中是否存在满足其他条件的元素，比如判断数组中是否存在某个对象的值等。下面是一个使用 some&nbsp;方法判断数组中是否存在某个对象的值的示例代码：</p><pre><code class="language-javascript">const array = [&nbsp; { name: 'Alice', age: 25 },&nbsp; { name: 'Bob', age: 30 },&nbsp; { name: 'Charlie', age: 35 }];const targetName = 'Bob';const isObjectValueExist = array.some(obj =&gt; obj.name === targetName);console.log(isObjectValueExist); // 输出 true</code></pre><p>上述示例代码中，some&nbsp;方法会遍历数组 array&nbsp;中的每个对象，并使用回调函数判断当前对象的 name&nbsp;属性是否等于目标名称 targetName。如果找到了一个对象的 name&nbsp;属性等于目标名称，则返回 true，否则返回 false。</p><h2>every()</h2><blockquote><p>every()&nbsp;方法是 JavaScript 数组的一个高阶函数，用于检查数组中的<span style="color:#fe2c24;">所有元素</span>是否满足指定的条件。它会遍历数组中的每个元素，并对每个元素应用一个回调函数，只有当所有元素都满足条件时，every()&nbsp;方法才会返回 true，否则返回 false。</p></blockquote><p>every()&nbsp;方法的语法如下：</p><pre><code class="language-javascript">array.every(function(currentValue,index,arr), thisValue)</code></pre><p>参数说明：<br>- function：必需，表示对每个元素进行处理的回调函数。<br>&nbsp; - currentValue：必需，当前元素的值。<br>&nbsp; - index：可选，当前正在处理的元素的索引。<br>&nbsp; - arr：可选，调用 every&nbsp;方法的数组。<br>- thisValue：可选，执行回调函数时使用的 `this` 值。</p><p>下面是一个使用 every()&nbsp;方法的示例代码，判断数组中的所有元素是否都大于 0：</p><pre><code class="language-javascript">const array = [1, 2, 3, 4, 5];const allPositive = array.every((element) =&gt; element &gt; 0);console.log(allPositive); // 输出 true</code></pre><p>在上面的代码中，回调函数 (element) =&gt; element &gt; 0&nbsp;用于判断每个元素是否大于 0。由于数组中的所有元素都大于 0，所以 every() 方法返回 true。</p><blockquote><p>需要注意的是：<strong>如果数组为空，则 every()&nbsp;方法会直接返回 true。另外，如果数组中有一个元素不满足条件，every()&nbsp;方法会立即停止遍历，并返回 false。</strong></p></blockquote><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI中的el-tab-pane组件使用v-show不生效的问题</title>
      <link href="/2023/07/15/10-elementui-zhong-de-el-tab-pane-zu-jian-shi-yong-v-show-bu-sheng-xiao-de-wen-ti/"/>
      <url>/2023/07/15/10-elementui-zhong-de-el-tab-pane-zu-jian-shi-yong-v-show-bu-sheng-xiao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>现象：</p><p>在el-tab-pane标签上使用v-show，即使v-show的值为false，el-tab的标签仍然展示。即使将v-show加在slot子节点上，也会显示tab的背景图和close图标；如下图：</p><p><img alt="" height="126" src="/medias/images/el-tab-pane组件使用v-show不生效的问题/01.png" width="561"></p><p><strong>解决方法一：可以使用使用v-if，亲测有效。</strong></p><p>但是有些场景下不适合使用v-if，比如切换比较频繁，并且需要保留之前的状态等</p><p><strong>解决方法二：</strong></p><p>注意观察tab的dom结构，你会发现el-tab-pane会生成一个唯一id，id的值就是tab-加上name属性的值。</p><p><img alt="" height="26" src="/medias/images/el-tab-pane组件使用v-show不生效的问题/02.png" width="998"></p><p><img alt="" height="294" src="/medias/images/el-tab-pane组件使用v-show不生效的问题/03.png" width="1200"></p><pre><code>watch:{    '会改变的值'(val){        if(xxxxx){            // 根据条件判断、如果需要隐藏，则获取到id后设置style的display为none            document.getElementById(`tab-${需要设置的tab的name}`).style.display = 'none';        } else {            // 如果需要显示、则获取到id后设置style的display为inline-block            document.getElementById(`tab-${需要设置的tab的name}`).style.display = 'inline-block';        }    }}</code></pre><p><strong>解决方法三：</strong></p><p><strong>原理类似方法二，使用this.$refs.tabs.$children[0].$refs.tabs获取到dom元素后修改样式</strong></p><p>在el-tabs元素上加上ref：</p><p><img alt="" height="82" src="/medias/images/el-tab-pane组件使用v-show不生效的问题/04.png" width="1200"></p><blockquote><p>this.$refs.tabs.$children[0].$refs.tabs获取到的值：所有tab页签dom元素的集合。如下图：</p></blockquote><p><img alt="" height="289" src="/medias/images/el-tab-pane组件使用v-show不生效的问题/05.png" width="629"></p><pre><code class="language-javascript"> watch: {        tabActive: {            handler(val) {                // this.$refs.tabs.$children[0].$refs.tabs获取到的就是所有的tab页签dom元素的集合                // 遍历之后，item.id就是div元素的id属性                // 里面会有tab对应的id值，判断id是否包含顶部页签的值，关联上                // 再设置style是否显示与隐藏                let tabList = this.$refs.tabs.$children[0].$refs.tabs;                tabList &amp;&amp; tabList.map(item =&gt; {                    if (!item.id.includes(this.srcTabActive + val)) {                        item.style.display = 'none';                    } else {                        item.style.display = 'inline-block';                    }                });        },        deep: true    }},</code></pre><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;</p><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this.$refs获取不到子元素身上的方法is not a function等问题</title>
      <link href="/2023/07/15/09-this.refs-huo-qu-bu-dao-zi-yuan-su-shen-shang-de-fang-fa-is-not-a-function-deng-wen-ti/"/>
      <url>/2023/07/15/09-this.refs-huo-qu-bu-dao-zi-yuan-su-shen-shang-de-fang-fa-is-not-a-function-deng-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>背景：使用v-for循环动态绑定ref，取值报错</p><p>问题控制台报错如下图：</p><p><img alt="" height="288" src="/medias/images/vue中refs取值问题/01.png" width="1200"></p><blockquote><p>&nbsp;可以确定的是，子组件上是有execSqlData的方法，那么为什么还会报is not a function呢？</p></blockquote><p>分析：如果是动态的ref值取错了，那么会报 <strong>Cannot read properties of undefined</strong>，如下图：</p><p><img alt="" height="558" src="/medias/images/vue中refs取值问题/02.png" width="1200"></p><p>证明this.$refs[ref] 取到了值，只不过值身上没有execSqlData的方法，才会报&nbsp;execSqlData is not a function.</p><p>控制台打印：这里不仔细看，都没发现是个数组</p><p><img alt="" height="76" src="/medias/images/vue中refs取值问题/03.png" width="772"></p><p>vue官方文档：</p><p><img alt="" height="362" src="/medias/images/vue中refs取值问题/04.png" width="776"></p><p>问题解决：&nbsp;</p><blockquote><p>当 ref 和 v-for 一起使用的时候，用this.$refs[xxx][0] 获取子组件身上的值</p></blockquote><pre><code class="language-javascript">this.$nextTick(() =&gt; {    console.log(this.$refs[ref]);    // 使用了v-for循环动态绑定ref，this.$ref[name]获取的是数组     // 因此this.$refs[name]改为this.$refs[name][0]    this.$refs[ref][0].execSqlData(data);});</code></pre><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js读取剪切板内容的问题记录</title>
      <link href="/2023/07/13/08-js-du-qu-jian-qie-ban-nei-rong-de-wen-ti-ji-lu-kai-fa-huan-jing-ke-yi-bu-shu-dao-xian-shang-zhi-hou-wu-xiao-navigator.clipboard.readtext-he-document.execcommand-paste-du-bu-xing/"/>
      <url>/2023/07/13/08-js-du-qu-jian-qie-ban-nei-rong-de-wen-ti-ji-lu-kai-fa-huan-jing-ke-yi-bu-shu-dao-xian-shang-zhi-hou-wu-xiao-navigator.clipboard.readtext-he-document.execcommand-paste-du-bu-xing/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在工作中基于Guacamole.js做了H5图形网关，在Web浏览器中实现远程桌面和VNC连接。</p><p><img alt="" height="1026" src="/medias/images/js读取剪切板/01.png" width="1200"></p><p>&nbsp;但是基于guacamole客户端是无法直接实现复制粘贴的功能的，复制还可以通过js代码去实现，但是粘贴功能无法实现，因为浏览器的安全策略，<span style="color:#fe2c24;">只有安全域名下，才能读取剪切板的内容</span>。安全域包括<strong>本地访问</strong>与<strong>开启TLS安全认证</strong>的地址，如&nbsp;<strong>https 协议的地址</strong>、<strong>127.0.0.1</strong>&nbsp;或&nbsp;<strong>localhost</strong>&nbsp;。所以才会出现开发的时候可以读取剪切板的内容，部署上线了之后却不行，<strong>大概率是因为线上的环境是http协议的。</strong></p><p><img alt="" height="143" src="/medias/images/js读取剪切板/02.png" width="399"></p><p></p><p><img alt="" height="1008" src="/medias/images/js读取剪切板/03.png" width="1200"></p><p>&nbsp;<img alt="" height="1020" src="/medias/images/js读取剪切板/04.png" width="1200">这时候如果想实现粘贴的功能，就有两个方向：1、将环境的协议换成https的。2、利用文本框去监听paste事件，获取到剪切板的值。</p><p><strong>&nbsp;1、将环境的协议换成https的，浏览器会弹窗提醒，需要允许后，可以成功读取</strong></p><p><img alt="" height="510" src="/medias/images/js读取剪切板/05.png" width="1200"></p><p>&nbsp;<strong>2、利用文本框去实现粘贴，这种也不是直接粘贴，多一道操作（Apache Guacamole官方也是用这种方法实现的）</strong></p><p><img alt="" height="1200" src="/medias/images/js读取剪切板/06.png" width="1200"></p><p>&nbsp;但是在看了jumpserver的demo后，发现竟然可以直接使用ctrl+c、ctrl+v</p><p><img alt="" height="634" src="/medias/images/js读取剪切板/07.png" width="1200"></p><p>&nbsp;在仔细翻看源码和查看网页元素之后发现，jumpserver是利用xterm.js实现的</p><p><a data-link-icon="https://demo.jumpserver.org/luna/favicon.ico" data-link-title="https://demo.jumpserver.org/luna/" href="https://demo.jumpserver.org/luna/" title="https://demo.jumpserver.org/luna/">https://demo.jumpserver.org/luna/</a></p><p><a data-link-desc="Terminal front-end component written in JavaScript that works in the browser." data-link-icon="http://xtermjs.org/images/favicon.png" data-link-title="Xterm.js" href="http://xtermjs.org/" title="Xterm.js">Xterm.js</a></p><blockquote><p>&nbsp;`xterm.js` 是一个用于在Web浏览器中实现终端仿真的JavaScript库。它允许您在网页中创建一个类似于命令行终端的界面，可以执行命令、显示输出并与用户进行交互。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`xterm.js` 提供了一种简单而强大的方式来在Web应用程序中集成终端功能。它支持常见的终端特性，如颜色、字体样式、光标控制和键盘输入。您可以使用它来构建各种类型的应用程序，包括基于Web的SSH客户端、远程服务器管理工具、终端编辑器等。</p><p>`xterm.js` 的优点包括：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 轻量级：它是一个轻量级的库，加载速度快，并且在各种浏览器中运行良好。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 可定制性：您可以自定义终端的外观和行为，包括颜色、字体、光标样式等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 跨平台：它可以在各种操作系统和设备上运行，包括桌面电脑、移动设备和嵌入式系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 易于集成：`xterm.js` 提供了简单的API和事件处理机制，使您可以轻松地将终端功能集成到现有的Web应用程序中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;您可以通过 `xterm.js` 创建一个终端仿真界面，并使用JavaScript代码来控制终端的行为和输出。它还提供了与终端交互的方法，例如发送命令、接收输出和处理用户输入。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之，`xterm.js` 是一个功能强大且易于使用的JavaScript库，适用于构建基于Web的终端应用程序。</p></blockquote><p><strong>但是xterm.js是怎么实现直接ctrl + c、ctrl + v复制粘贴的呢？所以我看了源码，有如下发现：</strong></p><p><img alt="" height="891" src="/medias/images/js读取剪切板/08.png" width="1048"></p><p>&nbsp;<img alt="" height="456" src="/medias/images/js读取剪切板/09.png" width="736"></p><p>&nbsp;xterm是利用textarea实现的直接粘贴的功能，并且我去页面中验证了一下，调大textarea的透明度之后，页面的确显示了文本框。</p><p><img alt="" height="1200" src="/medias/images/js读取剪切板/10.png" width="1200"></p><p>&nbsp;最后，不得不感慨，xterm.js这种写法真的妙啊，感兴趣的同学可以去看一下xterm.js的代码。<a data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N658" data-link-title="https://github.com/xtermjs/xterm.js" href="https://github.com/xtermjs/xterm.js" title="https://github.com/xtermjs/xterm.js">https://github.com/xtermjs/xterm.js</a></p><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p><p></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS3 </tag>
            
            <tag> 剪切板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css实现优惠券，波浪条纹，百度前端面试题</title>
      <link href="/2023/07/11/07-css-shi-xian-you-hui-quan-bo-lang-tiao-wen-bai-du-qian-duan-mian-shi-ti/"/>
      <url>/2023/07/11/07-css-shi-xian-you-hui-quan-bo-lang-tiao-wen-bai-du-qian-duan-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>在网上看到一道面试题，用css实现下图，觉得比较有趣，所以试着实现了一下&nbsp;</p></blockquote><p>&nbsp;<img alt="" height="261" src="/medias/images/css波浪百度面试题/01.png" width="552"></p><blockquote><p>直接放代码，用了比较蠢的办法，如果有大佬知道更好的实现，还请多多指导</p></blockquote><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .card1 {            width: 150px;            height: 100px;            position: relative;            background-image:                radial-gradient(circle at 40px top, #fff 9px, #eb692d 10px, transparent 11px),                radial-gradient(circle at 40px bottom, #fff 9px, #eb692d 10px, transparent 11px);            background-color: #fcedce;            border-radius: 4px;        }        .card1&gt;.line {            position: absolute;            bottom: 18px;            left: 40px;            width: 1px;            height: 66px;            background-color: #eb692d;        }        .card1&gt;.top-left-border {            position: absolute;            top: 0;            left: 2px;            height: 1px;            width: 28px;            background-color: #eb692d;        }        .card1&gt;.top-right-border {            position: absolute;            top: 0;            left: 50px;            height: 1px;            width: 100px;            background-color: #eb692d;        }        .card1&gt;.bottom-left-border {            position: absolute;            bottom: 0;            left: 2px;            height: 1px;            width: 28px;            background-color: #eb692d;        }        .card1&gt;.bottom-right-border {            position: absolute;            bottom: 0;            left: 50px;            height: 1px;            width: 100px;            background-color: #eb692d;        }        .card1::after {            content: '';            position: absolute;            top: 0;            bottom: 0;            right: -3px;            width: 10px;            height: 100%;            background: radial-gradient(circle at right, #ffffff 8px, #eb692d 10px, transparent 8px);            background-size: 14px 16px;        }        .card1::before {            content: '';            position: absolute;            top: 0;            bottom: 0;            left: -5px;            width: 10px;            height: 100%;            background: radial-gradient(circle at left, #ffffff 8px, #eb692d 10px, transparent 8px);            background-size: 14px 16px;        }        .card1&gt;span {            position: absolute;            right: 30px;            top: 16px;            font-size: 50px;            color: #eb692d;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="card1"&gt;        &lt;div class="top-left-border"&gt;&lt;/div&gt;        &lt;div class="top-right-border"&gt;&lt;/div&gt;        &lt;div class="bottom-left-border"&gt;&lt;/div&gt;        &lt;div class="bottom-right-border"&gt;&lt;/div&gt;        &lt;div class="top-border"&gt;&lt;/div&gt;        &lt;span&gt;券&lt;/span&gt;        &lt;div class="line"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果如下：&nbsp;</p><p><img alt="" height="153" src="/medias/images/css波浪百度面试题/02.png" width="208"></p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;半圆和波浪实现起来都不难，但是，不同颜色的上下边框，在下才疏学浅没想到其他好办法，只能通过元素的定位加上边框的效果。radial-gradient径向渐变在实际工作用的并不是很多，对径向渐变感兴趣的同学可以参考如下博客：</p><p><a data-link-desc="在实际 Web 开发过程中，总会遇到各种各样的布局。有公司同事问我这样一种布局有没有什么好的实现方式，就是一种在活动充值页非常普遍的优惠券效果，如下 首先，碰到这类布局的最佳实现肯定是mask遮罩。关于遮罩，可以看一下CSS3 Mask 安利报告。这里简单介绍一下 这里的遮罩图…" data-link-icon="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web//static/favicons/apple-touch-icon.png" data-link-title="CSS 实现优惠券的技巧 - 掘金" href="https://juejin.cn/post/6945023989555134494#heading-1" title="CSS 实现优惠券的技巧 - 掘金">CSS 实现优惠券的技巧 - 掘金</a></p><p><a data-link-desc="实际开发的时候，当要使用radial-gradient径向渐变的时候，脑中会有大概的语法，但是细节却记不住，于是想快捷找个案例看看具体怎么用，然后直接套一下，本文就是满足类似此需求而写，共展示了10例常见使用案例，相信一定可以覆盖你的使用场景的。" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.3.3/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N658" data-link-title="10个demo示例学会CSS3 radial-gradient径向渐变 «  张鑫旭-鑫空间-鑫生活" href="https://www.zhangxinxu.com/wordpress/2017/11/css3-radial-gradient-syntax-example/?fileGuid=fKc3ePJfifoZewha" title="10个demo示例学会CSS3 radial-gradient径向渐变 «  张鑫旭-鑫空间-鑫生活">10个demo示例学会CSS3 radial-gradient径向渐变 « 张鑫旭-鑫空间-鑫生活</a></p></blockquote><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p><p></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue实现多栏布局（拖拽改变盒子的宽度和高度）</title>
      <link href="/2023/07/04/06-vue-shi-xian-duo-lan-bu-ju-tuo-zhuai-gai-bian-he-zi-de-kuan-du-he-gao-du-ren-yi-qu-yu-zui-da-hua-zui-xiao-hua-bing-qie-shi-xian-lei-si-vscode-yi-jian-zhe-die-zhan-kai-xiang-ying-qu-yu/"/>
      <url>/2023/07/04/06-vue-shi-xian-duo-lan-bu-ju-tuo-zhuai-gai-bian-he-zi-de-kuan-du-he-gao-du-ren-yi-qu-yu-zui-da-hua-zui-xiao-hua-bing-qie-shi-xian-lei-si-vscode-yi-jian-zhe-die-zhan-kai-xiang-ying-qu-yu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>项目中要实现分栏布局效果的需求，各区域的宽高可以随意改变（拖拽改变盒子的宽度和高度），并且每个区域可以实现最大化/最小化，并且底部实现类似vscode中的分栏图标按钮，点击随意折叠/展开每个区域。</p><p></p></blockquote><h3>&nbsp;直接看效果</h3><p><img alt="" src="/medias/images/vue拖拽布局/01.gif"></p><blockquote><p>在CSDN中查找到，vue-split-pane组件，由于我有定制化的需求，就没有直接npm install vue-splitpane使用，而是重新写了一下。如果要了解vue-split-pane组件，源码链接：</p><p></p><p>GitHub - PanJiaChen/vue-split-pane: Split-Pane component built with vue2.0, can be split vertically or horizontally. http://panjiachen.github.io/split-pane/demo/index.html</p></blockquote><p>demo的github地址：<a data-link-desc="Contribute to MonkeyKingYY/vue-split-pane-demo development by creating an account on GitHub." data-link-icon="https://github.com/fluidicon.png" data-link-title="GitHub - MonkeyKingYY/vue-split-pane-demo" href="https://github.com/MonkeyKingYY/vue-split-pane-demo" title="GitHub - MonkeyKingYY/vue-split-pane-demo">GitHub - MonkeyKingYY/vue-split-pane-demo</a></p><p>下面直接放代码：</p><h3>APP.vue&nbsp;</h3><pre><code class="language-javascript">&lt;template&gt;    &lt;div id="app" class="app-main-contain"&gt;        &lt;div class="center-contain" style="width: 100%; height: calc(100% - 25px)"&gt;            &lt;SplitPane @resize="leftResize" :default-percent="leftPercent" split="vertical"&gt;                &lt;template slot="paneL"&gt;                    &lt;div class="title-contain" v-show="leftPercent &gt; 0"&gt;                        &lt;p&gt;资源导航&lt;/p&gt;                        &lt;i class="iconfont icon-zuidahua" v-show="leftPercent &gt; 0 &amp;&amp; leftPercent &lt; 100" @click="leftMaxFunc()"&gt;&lt;/i&gt;                        &lt;i class="iconfont icon-zuixiaohua" v-show="leftPercent &gt;= 100" @click="leftMinFunc()"&gt;&lt;/i&gt;                    &lt;/div&gt;                    1111111                &lt;/template&gt;                &lt;template slot="paneR"&gt;                    &lt;SplitPane split="vertical" @resize="rightResize" :default-percent="rightPercent"&gt;                        &lt;template slot="paneL"&gt;                            &lt;SplitPane split="horizontal" @resize="topBottomResize" :default-percent="topPercent"&gt;                                &lt;template slot="paneL"&gt;                                    &lt;div class="title-contain" v-show="topPercent &gt; 0 &amp;&amp; rightPercent &gt; 0"&gt;                                        &lt;p&gt;查询编辑器&lt;/p&gt;                                        &lt;i class="iconfont icon-zuidahua" v-show="leftPercent !== 100 &amp;&amp; rightPercent !== 100" @click="topMaxFunc()"&gt;&lt;/i&gt;                                        &lt;i class="iconfont icon-zuixiaohua" v-show="leftPercent == 0 &amp;&amp; topPercent == 100 &amp;&amp; rightPercent == 100" @click="topMinFunc()"&gt;&lt;/i&gt;                                    &lt;/div&gt;                                    &lt;div style="height: calc(100% - 25px)"&gt;2222222&lt;/div&gt;                                &lt;/template&gt;                                &lt;template slot="paneR"&gt;                                    &lt;div class="title-contain" v-show="topPercent &lt; 100 &amp;&amp; rightPercent &gt; 0"&gt;                                        &lt;p&gt;结果区&lt;/p&gt;                                        &lt;i class="iconfont icon-zuidahua" v-show="leftPercent !== 100 &amp;&amp; topPercent !== 0 &amp;&amp; rightPercent !== 0" @click="bottomMaxFunc()"&gt;&lt;/i&gt;                                        &lt;i class="iconfont icon-zuixiaohua" v-show="leftPercent == 0 &amp;&amp; topPercent == 0 &amp;&amp; rightPercent &gt;= 100" @click="bottomMinFunc()"&gt;&lt;/i&gt;                                    &lt;/div&gt;                                    &lt;div v-show="topPercent &lt; 100 &amp;&amp; rightPercent &gt; 0" style="height: calc(100% - 25px)"&gt;3333333&lt;/div&gt;                                &lt;/template&gt;                            &lt;/SplitPane&gt;                        &lt;/template&gt;                        &lt;template slot="paneR"&gt;                            &lt;div class="title-contain" v-show="rightPercent &lt; 100"&gt;                                &lt;p&gt;辅助区&lt;/p&gt;                                &lt;i class="iconfont icon-zuidahua" v-show="leftPercent !== 100 &amp;&amp; rightPercent !== 0" @click="rightMaxFunc()"&gt;&lt;/i&gt;                                &lt;i class="iconfont icon-zuixiaohua" v-show="leftPercent == 0 &amp;&amp; rightPercent == 0" @click="rightMinFunc()"&gt;&lt;/i&gt;                            &lt;/div&gt;                            &lt;div v-show="rightPercent &lt; 100" style="height: calc(100% - 25px)"&gt;444444&lt;/div&gt;                        &lt;/template&gt;                    &lt;/SplitPane&gt;                &lt;/template&gt;            &lt;/SplitPane&gt;        &lt;/div&gt;        &lt;div class="buttom-contain"&gt;            &lt;BottomTaskBar :rightPercent="rightPercent" :leftPercent="leftPercent" :topPercent="topPercent" @leftClose="leftClose" @rightClose="rightClose" @bottomClose="bottomClose" @openBottom="openBottom" @openLeft="openLeft" @openRight="openRight"&gt;&lt;/BottomTaskBar&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import SplitPane from './components/SplitPane.vue'    export default {        name: 'index',        components: {            SplitPane,            BottomTaskBar: () =&gt; import('./components/BottomTaskBar.vue'),        },        created() {            this.leftPercent = parseInt(localStorage.getItem('leftPercent') || 20)            this.rightPercent = parseInt(localStorage.getItem('rightPercent') || 70)            this.topPercent = parseInt(localStorage.getItem('topPercent') || 70)        },        data() {            return {                GLayoutRoot: null,                leftPercent: 20,                rightPercent: 70,                topPercent: 70,                oldLeftPercent: 20,                oldRightPercent: 70,                oldTopPercent: 70,            }        },        watch: {            leftPercent: {                handler(percent) {                    console.log('watchleftPercent', percent)                    localStorage.setItem('leftPercent', percent)                },                deep: true,            },            rightPercent: {                handler(percent) {                    console.log('watchrightPercent', percent)                    localStorage.setItem('rightPercent', percent)                },                deep: true,            },            topPercent: {                handler(percent) {                    console.log('watchtopPercent', percent)                    localStorage.setItem('topPercent', percent)                },                deep: true,            },        },        methods: {            leftResize(percent) {                this.oldLeftPercent = percent                this.leftPercent = percent            },            rightResize(percent) {                this.oldRightPercent = percent                this.rightPercent = percent            },            topBottomResize(percent) {                this.oldTopPercent = percent                this.topPercent = percent            },            leftClose() {                this.leftPercent = 0            },            rightClose() {                this.rightPercent = 100            },            bottomClose() {                this.topPercent = 100            },            openBottom() {                this.topPercent = this.oldTopPercent            },            openLeft() {                this.leftPercent = this.oldLeftPercent            },            openRight() {                this.rightPercent = this.oldRightPercent            },            leftMaxFunc() {                this.leftPercent = 100            },            leftMinFunc() {                this.leftPercent = this.oldLeftPercent            },            topMaxFunc() {                this.topPercent = 100                this.leftPercent = 0                this.rightPercent = 100            },            topMinFunc() {                this.topPercent = this.oldTopPercent                this.leftPercent = this.oldLeftPercent                this.rightPercent = this.oldRightPercent            },            bottomMaxFunc() {                this.topPercent = 0                this.leftPercent = 0                this.rightPercent = 100            },            bottomMinFunc() {                this.topPercent = this.oldTopPercent                this.leftPercent = this.oldLeftPercent                this.rightPercent = this.oldRightPercent            },            rightMaxFunc() {                this.leftPercent = 0                this.rightPercent = 0            },            rightMinFunc() {                this.topPercent = this.oldTopPercent                this.leftPercent = this.oldLeftPercent                this.rightPercent = this.oldRightPercent            },        },    }&lt;/script&gt;&lt;style scoped&gt;    .app-main-contain {        height: 100%;        display: flex;        flex-direction: column;    }    .center-contain .title-contain {        display: flex;        align-items: center;        padding: 0 10px 0 10px;        justify-content: space-between;        background-color: #eee;    }    .center-contain .title-contain p {        margin: 0;        height: 25px;        line-height: 25px;        font-size: 12px;    }    .center-contain .title-contain i {        font-size: 14px;        cursor: pointer;    }    .app-main-contain .buttom-contain {        position: fixed;        bottom: 0;        height: 25px;        width: 100%;        background-color: #0074c8;        z-index: 999999;    }&lt;/style&gt;</code></pre><h3>SplitPane.vue:</h3><pre><code class="language-javascript">&lt;template&gt;    &lt;div :style="{ cursor, userSelect }" class="vue-splitter-container clearfix" @mouseup="onMouseUp" @mousemove="onMouseMove"&gt;        &lt;Pane class="splitter-pane splitter-paneL" :split="split" :style="{ [type]: percent + '%' }"&gt;            &lt;slot name="paneL"&gt;&lt;/slot&gt;        &lt;/Pane&gt;        &lt;Resizer            :className="className"            :style="{ [resizeType]: percent + '%' }"            :split="split"            @mousedown.native="onMouseDown"            @click.native="onClick"        &gt;&lt;/Resizer&gt;        &lt;Pane class="splitter-pane splitter-paneR" :split="split" :style="{ [type]: 100 - percent + '%' }"&gt;            &lt;slot name="paneR"&gt;&lt;/slot&gt;        &lt;/Pane&gt;        &lt;div class="vue-splitter-container-mask" v-if="active"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Resizer from './Resizer.vue'import Pane from './Pane.vue'export default {    name: 'splitPane',    components: { Resizer, Pane },    props: {        minPercent: {            type: Number,            default: 0,        },        defaultPercent: {            type: Number,            default: 50,        },        split: {            validator(value) {                return ['vertical', 'horizontal'].indexOf(value) &gt;= 0            },            required: true,        },        className: String,    },    computed: {        userSelect() {            return this.active ? 'none' : ''        },        cursor() {            return this.active ? (this.split === 'vertical' ? 'col-resize' : 'row-resize') : ''        },    },    watch: {        defaultPercent(newValue, oldValue) {            console.log(oldValue)            this.percent = newValue        },    },    data() {        return {            active: false,            hasMoved: false,            height: null,            percent: this.defaultPercent,            type: this.split === 'vertical' ? 'width' : 'height',            resizeType: this.split === 'vertical' ? 'left' : 'top',            firstTime: 0,            lastTime: 0,            key: false,        }    },    methods: {        onClick() {            console.log(111)            if (this.key) {                this.percent = 50                this.$emit('resize', this.percent)                this.key = false            }        },        onMouseDown() {            console.log('mouseDown')            this.firstTime = new Date().getTime()            this.active = true            this.hasMoved = false        },        onMouseUp() {            console.log('mouseUp')            this.active = false            this.lastTime = new Date().getTime()            if (this.lastTime - this.firstTime &lt; 500) {                this.key = true                console.log(this.key)            }        },        onMouseMove(e) {            if (e.buttons === 0 || e.which === 0) {                this.active = false            }            if (this.active) {                let offset = 0                let target = e.currentTarget                if (this.split === 'vertical') {                    while (target) {                        offset += target.offsetLeft                        target = target.offsetParent                    }                } else {                    while (target) {                        offset += target.offsetTop                        target = target.offsetParent                    }                }                const currentPage = this.split === 'vertical' ? e.pageX : e.pageY                const targetOffset = this.split === 'vertical' ? e.currentTarget.offsetWidth : e.currentTarget.offsetHeight                const percent = Math.floor(((currentPage - offset) / targetOffset) * 10000) / 100                if (percent &gt; this.minPercent &amp;&amp; percent &lt; 100 - this.minPercent) {                    this.percent = percent                }                this.$emit('resize', this.percent)                this.hasMoved = true            }        },    },}&lt;/script&gt;&lt;style scoped&gt;.clearfix:after {    visibility: hidden;    display: block;    font-size: 0;    content: ' ';    clear: both;    height: 0;}.vue-splitter-container {    height: 100%;    position: relative;}.vue-splitter-container-mask {    z-index: 9999;    width: 100%;    height: 100%;    position: absolute;    top: 0;    left: 0;}&lt;/style&gt;</code></pre><h3>&nbsp;Resizer.vue:</h3><pre><code class="language-javascript">&lt;template&gt;    &lt;div :class="classes"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    props: {      split: {        validator(value) {          return ['vertical', 'horizontal'].indexOf(value) &gt;= 0        },        required: true      },      className: String    },    computed: {      classes() {        const classes = ['splitter-pane-resizer', this.split, this.className]        return classes.join(' ')      }    }  }&lt;/script&gt;&lt;style scoped&gt;.splitter-pane-resizer {  -moz-box-sizing: border-box;    -webkit-box-sizing: border-box;    box-sizing: border-box;    background: #000;    position: absolute;    opacity: .2;    z-index: 1;    -moz-background-clip: padding;    -webkit-background-clip: padding;    background-clip: padding-box;}.splitter-pane-resizer.horizontal {  height: 11px;    margin: -5px 0;    border-top: 5px solid rgba(255, 255, 255, 0);    border-bottom: 5px solid rgba(255, 255, 255, 0);    cursor: row-resize;    width: 100%;}.splitter-pane-resizer.vertical {  width: 11px;    height: 100%;    margin-left: -5px;    border-left: 5px solid rgba(255, 255, 255, 0);    border-right: 5px solid rgba(255, 255, 255, 0);    cursor: col-resize;}&lt;/style&gt;</code></pre><h3>Pane.vue:</h3><pre><code class="language-javascript">&lt;template&gt;    &lt;div :class="classes"&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: 'Pane',    props: {      className: String    },    data() {      const classes = [this.$parent.split, this.className]      return {        classes: classes.join(' '),        percent: 50      }    }  }&lt;/script&gt;&lt;style scoped&gt;.splitter-pane.vertical.splitter-paneL {  position: absolute;  left: 0px;  height: 100%;  padding-right: 3px;}.splitter-pane.vertical.splitter-paneR {  position: absolute;  right: 0px;  height: 100%;  padding-left: 3px;}.splitter-pane.horizontal.splitter-paneL {  position: absolute;  top: 0px;  width: 100%;}.splitter-pane.horizontal.splitter-paneR {  position: absolute;  bottom: 0px;  width: 100%;  padding-top: 3px;}&lt;/style&gt;</code></pre><h3>BottomTaskBar.vue:</h3><pre><code class="language-javascript">&lt;template&gt;    &lt;div id="BottomTaskBar"&gt;        &lt;div class="img-contain"&gt;            &lt;img @click="leftClose" v-if="leftPercent !== 0" src="../assets/bottomTask/left_show.png" /&gt;            &lt;img @click="openLeft" v-if="leftPercent == 0" src="../assets/bottomTask/left_hidden.png" /&gt;            &lt;img @click="bottomClose" v-if="topPercent !== 100" src="../assets/bottomTask/bottom_show.png" /&gt;            &lt;img @click="openBottom" v-if="topPercent == 100" src="../assets/bottomTask/bottom_hidden.png" /&gt;            &lt;img @click="rightClose" v-if="rightPercent !== 100" src="../assets/bottomTask/right_show.png" style="margin-bottom: 1px" /&gt;            &lt;img @click="openRight" v-if="rightPercent == 100" src="../assets/bottomTask/right_hidden.png" /&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    props: {        leftPercent: {            type: Number,        },        rightPercent: {            type: Number,        },        topPercent: {            type: Number,        },    },    data() {        return {}    },    methods: {        leftClose() {            this.$emit('leftClose')        },        rightClose() {            this.$emit('rightClose')        },        bottomClose() {            this.$emit('bottomClose')        },        openBottom() {            this.$emit('openBottom')        },        openLeft() {            this.$emit('openLeft')        },        openRight() {            this.$emit('openRight')        },    },}&lt;/script&gt;&lt;style scoped&gt;#BottomTaskBar {    color: #fff;    padding: 0 20px;    display: flex;    align-items: center;    justify-content: flex-end;}#BottomTaskBar p {    margin: 0;    height: 25px;    line-height: 25px;}#BottomTaskBar .img-contain img {    width: 20px;    height: 20px;    cursor: pointer;    margin-right: 10px;}&lt;/style&gt;</code></pre><blockquote><p>注意⚠️：静态资源包括图标和图标就不上传了，如果需要运行代码，可以直接从github上clone下来运行即可。关于这种类似vscode的分栏布局，曾经是让我很头疼的需求，解决了之后很开心。如果能帮助大家解决自己的问题，我会更开心😊。最后再次感谢这个插件：<a data-link-desc="Split-Pane component built with vue2.0, can be split vertically or horizontally. http://panjiachen.github.io/split-pane/demo/index.html - GitHub - PanJiaChen/vue-split-pane: Split-Pane component built with vue2.0, can be split vertically or horizontally. http://panjiachen.github.io/split-pane/demo/index.html" data-link-icon="https://github.com/fluidicon.png" data-link-title="GitHub - PanJiaChen/vue-split-pane: Split-Pane component built with vue2.0, can be split vertically or horizontally. http://panjiachen.github.io/split-pane/demo/index.html" href="https://github.com/PanJiaChen/vue-split-pane" title="GitHub - PanJiaChen/vue-split-pane: Split-Pane component built with vue2.0, can be split vertically or horizontally. http://panjiachen.github.io/split-pane/demo/index.html">GitHub - PanJiaChen/vue-split-pane: Split-Pane component built with vue2.0, can be split vertically or horizontally. http://panjiachen.github.io/split-pane/demo/index.html</a></p></blockquote><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js如何判断数组类型，以及instanceof和Array.isArray()的区别</title>
      <link href="/2023/06/25/05-js-ru-he-pan-duan-shu-zu-lei-xing-yi-ji-instanceof-he-array.isarray-de-qu-bie/"/>
      <url>/2023/06/25/05-js-ru-he-pan-duan-shu-zu-lei-xing-yi-ji-instanceof-he-array.isarray-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; 众所周知，js中使用 typeof 只能检测基本数据类型，包括：number、string、boolean、undefined、symbol。函数的 typeof 返回值是function。而null、Array、Object以及除 Function 外的所有构造函数的类型都是 'object'。所以无法使用typeof去判断js的数组类型</p></blockquote><blockquote><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;关于typeof的知识点可以查看我另一篇博客：<a data-link-desc="typeof 总是返回一个字符串，返回值共八种包括：'number'、'bigint'、'string'、'boolean'、'undefined'、'symbol'、'object'、'function'" data-link-icon="https://g.csdnimg.cn/static/logo/favicon32.ico" data-link-title="整理typeof返回值_程序猿小野的博客-CSDN博客" href="https://blog.csdn.net/weixin_42289279/article/details/131373980" title="整理typeof返回值_程序猿小野的博客-CSDN博客">整理typeof返回值_程序猿小野的博客-CSDN博客</a>。下面说明js如何判断数组类型：</p></blockquote><h4>1. 通过 Array.isArray() 判断&nbsp; （推荐使用）</h4><blockquote><p>Array.isArray() 用于判断的值是否是一个数组，返回一个布尔值。是数组返回true，不是返回false</p></blockquote><pre><code class="language-javascript">let arr = [1, 2, 3];console.log(Array.isArray(arr)); // truelet obj = { name: 'Yee' };console.log(Array.isArray(obj)); // false</code></pre><blockquote><p>IE8 及以下版本：不支持<br>IE9+、Edge、Chrome、Firefox、Safari：支持</p></blockquote><h3>2. 通过Object.prototype.toString.call() 判断</h3><blockquote><p>Object.prototype.toString.call()可以获取到对象的不同类型，比如：'[object Number]'、'[object String]'、'[object Object]'、'[object Null]'、'[object Undefined]' 等等。</p></blockquote><pre><code class="language-javascript">let arr = [1, 2, 3];console.log(Object.prototype.toString.call(arr)); // [object Array]console.log(Object.prototype.toString.call(arr) === '[object Array]'); // truelet obj = { name: 'Yee' };console.log(Object.prototype.toString.call(obj)); // [object Object]console.log(Object.prototype.toString.call(obj) === '[object Array]'); // false</code></pre><blockquote><p>上面说到，IE8及以下版本不支持Array.isArray()，如果需要考虑兼容性问题可以做如下封装：</p></blockquote><pre><code class="language-javascript">if (!Array.isArray) {    Array.isArray = function(argument) {        return Object.prototype.toString.call(argument) === '[object Array]';    }}</code></pre><h3>&nbsp;3. 通过 constructor 判断</h3><blockquote><p>每一个引用类型都有一个constructor属性，由于自定义构造函数会创建一个特殊的对象类型，因此它的constructor属性<strong>在原型未被重写时也就是使用默认原型时</strong>指向创建它的构造函数。</p></blockquote><pre><code class="language-javascript">let arr = [1, 2, 3];console.log(arr.constructor === Array); // truelet obj = { name: 'Yee' };console.log(obj.constructor === Array); // false</code></pre><h3>4. 通过 instanceof 判断</h3><blockquote><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，返回一个布尔值</p></blockquote><pre><code class="language-javascript">let arr = [1, 2, 3];console.log(arr instanceof Array); // truelet obj = { name: 'Yee' };console.log(obj instanceof Array); // false</code></pre><h3>instanceof 和&nbsp;Array.isArray() 的差异</h3><ul><li>Array.isArray()</li></ul><pre><code class="language-javascript">//  Array.prototype 也是一个数组。console.log(Array.isArray(Array.prototype)); // true<p>// 修改原型对象指向数组原型的对象，也可以被分辨出来<br>let obj = { name: ‘Yee’, <strong>proto</strong>: Array.prototype }<br>console.log(Array.isArray(obj)); // false</p></code><p><code class="language-javascript">// isArray可以跨iframe工作<br>let iframe = document.createElement(‘iframe’);<br>document.body.appendChild(iframe);<br>xArray = window.frames[window.frames.length - 1].Array;<br>let arr = new xArray(1, 2, 3);<br>console.log(arr); // [1,2,3]<br>console.log(Array.isArray(arr)); // true</code></p></pre><p></p><ul><li>instanceof</li></ul><pre><code class="language-javascript">// 不能正确判断 Array.prototypeconsole.log(Array.prototype instanceof Array); // false<p>// 如果修改原型对象指向，instanceof 无法准确分辨<br>let obj = { name: ‘Yee’, <strong>proto</strong>: Array.prototype }<br>console.log(obj instanceof Array); // true</p></code><p><code class="language-javascript">// 不能跨iframe 工作<br>let iframe = document.createElement(‘iframe’);<br>document.body.appendChild(iframe);<br>xArray = window.frames[window.frames.length - 1].Array;<br>let arr = new xArray(1, 2, 3);<br>console.log(arr); // [1,2,3]<br>console.log(arr instanceof Array); // false</code></p></pre><p></p><blockquote><p>综上，在判断对象是否为数组时，采用<code>Array.isArray()</code>&nbsp;更加可靠</p></blockquote><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理typeof返回值</title>
      <link href="/2023/06/25/04-zheng-li-typeof-fan-hui-zhi/"/>
      <url>/2023/06/25/04-zheng-li-typeof-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>typeof 总是返回一个字符串，返回值共八种包括：'number'、'bigint'、'string'、'boolean'、'undefined'、'symbol'、'object'、'function'</p></blockquote><pre><code class="language-javascript">// 数值类型number和bigintconsole.log(typeof 28); // numberconsole.log(typeof(28)); // numberconsole.log(typeof Math.PI); // numberconsole.log(typeof Infinity); // numberconsole.log(typeof NaN); // numberconsole.log(typeof Number(28)); // numberconsole.log(typeof 828n); // bigint// stringconsole.log(typeof ''); // stringconsole.log(typeof '1'); // stringconsole.log(typeof '猿小野'); // stringconsole.log(typeof typeof 1); // stringconsole.log(typeof String(1)); // string 将任意值转换为字符串，比 toString 更安全// booleanconsole.log(typeof true); // booleanconsole.log(typeof false); // booleanconsole.log(typeof Boolean(1)); // booleanconsole.log(typeof !!1); // boolean// symbolconsole.log(typeof Symbol()); // symbolconsole.log(typeof Symbol('Yee')); // symbolconsole.log(typeof Symbol.iterator); // symbol// undefinedconsole.log(typeof undefined); // undefinedconsole.log(typeof declaredButUndefinedVariable); // undefinedconsole.log(typeof undeclaredVariable); // undefined// objectconsole.log(typeof null); // objectconsole.log(typeof new Object(null)); // objectconsole.log(typeof { name: 'Yee' }); // objectconsole.log(typeof new Array()); // objectconsole.log(typeof [1, 2, 3]); // objectconsole.log(typeof new Date()); // objectconsole.log(typeof new String('111')); // objectconsole.log(typeof new Number(111)); // objectconsole.log(typeof /regex/); // object// functionconsole.log(typeof function() {}); // functionconsole.log(typeof new Function()); // functionconsole.log(typeof class person {}); // functionconsole.log(typeof Math.random); // function</code></pre><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-input-number 如何添加单位</title>
      <link href="/2023/06/13/03-el-input-number-ru-he-tian-jia-dan-wei/"/>
      <url>/2023/06/13/03-el-input-number-ru-he-tian-jia-dan-wei/</url>
      
        <content type="html"><![CDATA[<p>需求原型图上，el-input-number的文本框里要加上单位：</p><p><img alt="" height="99" src="/medias/images/el-input-number如何添加单位/01.png" width="271"></p><p>查看element-ui的文档，好像没有提供类似的配置。于是自己利用css的伪类选择器::after实现了：</p><blockquote><p>&lt;el-input-number size="small" class="my-el-input-number"&gt;&lt;/el-input-number&gt;&nbsp;</p></blockquote><pre><code class="language-html">&lt;el-input-number size="small" class="my-el-input-number"&gt;&lt;/el-input-number&gt;</code></pre><p>css：</p><blockquote><p>.my-el-input-number {<br>&nbsp; &nbsp; position: relative;<br>}<br>.my-el-input-number::after {<br>&nbsp; &nbsp; content: '%';<br>&nbsp; &nbsp; display: inline-block;<br>&nbsp; &nbsp; height: 20px;<br>&nbsp; &nbsp; line-height: 20px;<br>&nbsp; &nbsp; width: 20px;<br>&nbsp; &nbsp; text-align: center;<br>&nbsp; &nbsp; position: absolute;<br>&nbsp; &nbsp; right: 32px;<br>&nbsp; &nbsp; top: 50%;<br>&nbsp; &nbsp; transform: translateY(-50%);<br>}<br>.my-el-input-number .el-input__inner{ // 不加这行的话，当文本框里数值很大时，会和单位重叠<br>&nbsp; &nbsp; padding-left: 30px;<br>&nbsp; &nbsp; padding-right: 48px;<br>}</p></blockquote><p>源代码：&nbsp;</p><pre><code class="language-css">.my-el-input-number {    position: relative;}.my-el-input-number::after {    content: '%';    display: inline-block;    height: 20px;    line-height: 20px;    width: 20px;    text-align: center;    position: absolute;    right: 32px;    top: 50%;    transform: translateY(-50%);}.my-el-input-number .el-input__inner{ // 不加这行的话，当文本框里数值很大时，会和单位重叠    padding-left: 30px;    padding-right: 48px;}</code></pre><p>效果图如下：</p><p><img alt="" height="97" src="/medias/images/el-input-number如何添加单位/02.png" width="320"></p><p>后来，又发现另外一个地方也需要用到，可是单位不一样，重复写样式太麻烦，于是优化了一版，将单位当作变量传递进css中，可以做到一段css满足多个不同单位的需求。</p><blockquote><p>&lt;el-input-number size="small" data-unit="%" class="my-el-input-number" /&gt;</p></blockquote><p>HTML源代码：&nbsp;</p><pre><code class="language-html">&lt;el-input-number size="small" data-unit="%" class="my-el-input-number" /&gt;</code></pre><blockquote><p>.my-el-input-number[data-unit] {<br>&nbsp; &nbsp; --el-input-number-unit-offset-x: 35px;<br>&nbsp; &nbsp; position: relative;<br>}<br>.my-el-input-number[data-unit]::after {<br>&nbsp; &nbsp; content: attr(data-unit);<br>&nbsp; &nbsp; height: 100%;<br>&nbsp; &nbsp; display: flex;<br>&nbsp; &nbsp; align-items: center;<br>&nbsp; &nbsp; position: absolute;<br>&nbsp; &nbsp; top: 0;<br>&nbsp; &nbsp; right: var(--el-input-number-unit-offset-x);<br>&nbsp; &nbsp; color: #999999;<br>}<br>.my-el-input-number[data-unit] .el-input__inner {<br>&nbsp; &nbsp; padding-left: 30px;<br>&nbsp; &nbsp; padding-right: calc(var(--el-input-number-unit-offset-x) + 12px);<br>}</p></blockquote><p>css源代码：&nbsp;</p><pre><code class="language-css">.my-el-input-number[data-unit] {    --el-input-number-unit-offset-x: 35px;    position: relative;}.my-el-input-number[data-unit]::after {    content: attr(data-unit);    height: 100%;    display: flex;    align-items: center;    position: absolute;    top: 0;    right: var(--el-input-number-unit-offset-x);    color: #999999;}.my-el-input-number[data-unit] .el-input__inner {    padding-left: 30px;    padding-right: calc(var(--el-input-number-unit-offset-x) + 12px);}</code></pre><p>&nbsp;data-unit传%就显示%，传G就显示G。</p><p><img alt="" height="106" src="/medias/images/el-input-number如何添加单位/03.png" width="320"><img alt="" height="112" src="/medias/images/el-input-number如何添加单位/04.png" width="298"></p><p>&nbsp;如果帮助到你了，希望留下一个赞👍吧，那是我继续前进的动力</p><p></p><p></p><p></p>]]></content>
      
      
      <categories>
          
          <category> ElementUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElementUI </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Array.from()和Array.of()</title>
      <link href="/2023/06/09/02-shen-ru-qian-chu-array.from-he-array.of/"/>
      <url>/2023/06/09/02-shen-ru-qian-chu-array.from-he-array.of/</url>
      
        <content type="html"><![CDATA[<h1>Array.from()</h1><p>Array.from 方法用于将两类对象转为真正的数组：1.类似数组的对象；2.可遍历对象（包括ES6新增的数据结构Set和Map）。</p><p>下面是一个类似数组的对象，Array.from将它转为真正的数组。</p><pre><code class="language-javascript">let arrLike = {    '0': 'a',    '1': 'b',    '2': 'c',    length: 3}// ES5的写法var arr1 = [].slice.call(arrLike);console.log(arr1); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrLike);console.log(arr2); // ['a', 'b', 'c']</code></pre><p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from()都可以将它们转为真正的数组。</p><p>// NodeList对象</p><pre><code class="language-javascript">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;body&gt;    &lt;p&gt;&lt;/p&gt;    &lt;p&gt;&lt;/p&gt;    &lt;p&gt;&lt;/p&gt;    &lt;p&gt;&lt;/p&gt;    &lt;p&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt;    let ps = document.querySelectorAll('p');    console.log(ps);&lt;/script&gt;&lt;/html&gt;</code></pre><p><img alt="" height="347" src="/medias/images/深入浅出ArrayFormOf/01.png" width="592"></p><blockquote><p>&nbsp;在ES6标准入门一书中提到：“querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法”。<span style="color:#fe2c24;">这句话是错误的</span>，因为从上图可以看到，querySelectorAll方法返回的NodeList类数组对象中是有forEach方法的，NodeList可以使用forEach方法，但是不能使用数组身上的其他方法。例如：map、concat等方法。</p></blockquote><pre><code class="language-javascript">&lt;script&gt;    let ps = document.querySelectorAll('p');    console.log(ps);    ps.forEach((p) =&gt; {        console.log(p);    })    ps.map((p) =&gt; {        console.log(p);    })&lt;/script&gt;</code></pre><p>forEach成功输出、map报错</p><p><img alt="" height="248" src="/medias/images/深入浅出ArrayFormOf/02.png" width="483"></p><p>// arguments对象</p><p>如果直接遍历arguments对象就会报错，因为arguments对象身上并没有forEach方法</p><pre><code class="language-javascript">function fn() {    console.log(arguments);    arguments.forEach(arg =&gt; {        console.log(arg);    });}fn('程序', '猿', '小野');</code></pre><p><img alt="" height="1006" src="/medias/images/深入浅出ArrayFormOf/03.png" width="1200"></p><p>使用Array.from()之后，就可以使用forEach方法了。</p><pre><code class="language-javascript">function fn() {    console.log(arguments);    Array.from(arguments).forEach((arg) =&gt; {        console.log(arg);    })}fn('程序', '猿', '小野');</code></pre><p><img alt="" height="436" src="/medias/images/深入浅出ArrayFormOf/04.png" width="1200"></p><p>另外，只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。</p><p><img alt="" height="96" src="/medias/images/深入浅出ArrayFormOf/05.png" width="576"></p><p><img alt="" height="186" src="/medias/images/深入浅出ArrayFormOf/06.png" width="772"></p><p>值得一提的是，扩展运算符（...）也可以将某些数据结构转为数组。</p><pre><code class="language-javascript">function fn() {    console.log(arguments);    console.log([...arguments]);    // Array.from(arguments).forEach((arg) =&gt; {    //     console.log(arg);    // })}fn('程序', '猿', '小野');</code></pre><p><img alt="" height="342" src="/medias/images/深入浅出ArrayFormOf/07.png" width="1200"></p><p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署该接口，就无法转换。</p><p>可以用Array.prototype.slice方法替代：</p><pre><code class="language-javascript">    let ps = document.querySelectorAll('p');    console.log(ps);    const toArray = (() =&gt;        obj =&gt; [].slice.call(obj)    )();    console.log(toArray(ps));</code></pre><p><img alt="" height="560" src="/medias/images/深入浅出ArrayFormOf/08.png" width="864"></p><p>Array.from方法还可以传多个参数：</p><blockquote><p>Array.from(arraylLike, MapFn, thisArg)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrayLike：第一个参数，指定一个类数组对象or可迭代对象</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapFn(可选)：第二个参数，新数组中的每一个元素执行该回调函数</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thisArg(可选)：第三个参数，执行回调函数MapFn时的this对象</p><p>返回值：一个新数组实例</p></blockquote><p>&nbsp;第二个参数：</p><pre><code class="language-javascript">const arr1 = [2, 4, 6, 8];const arr2 = Array.from(arr1, x =&gt; x + 1);console.log(arr2);// [3, 5, 7, 9]</code></pre><p>&nbsp;第三个参数：</p><pre><code class="language-javascript">let obj = {    add(value) {        return value * 2;    }}const arr1 = [2, 4, 6, 8];const arr2 = Array.from(arr1, obj.add, obj);console.log(arr2);// [4, 8, 12, 16]</code></pre><h1>Array.of()&nbsp;</h1><p>Array.of方法用于将一组值转换为数组。</p><pre><code class="language-javascript">Array.of(1,2,3)    // [1,2,3]Array.of(3)        // [3]Array.of(3).length // 1</code></pre><blockquote><p>这个方法的主要目的是弥补数组构造函数Array的不足。因为参数个数的不同会导致Array()的行为有差异。比如：</p><pre><code class="language-javascript">​console.log(Array());           // []console.log(Array(3));          // [empty × 3]console.log(Array(3).length);   // 3console.log(Array(1, 2, 3));    // [1, 2, 3]​</code></pre><p>上面的代码中，Array方法没有参数、有1个参数或3个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有1个时，实际上是指定数组的长度。</p></blockquote><p>Array.of()方法基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一，&nbsp;Array.of()&nbsp;总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><pre><code class="language-javascript">Array.of()           // []Array.of(undefined)  // [undefined]Array.of(3)          // [3]Array.of(1, 2, 3)    // [1, 2, 3]</code></pre><p>Array.of 方法可以用下面的代码模拟实现：</p><pre><code class="language-javascript">function ArrayOf() {    return [].slice.call(arguments)}console.log(ArrayOf());            // []console.log(ArrayOf(undefined));   // [undefined]console.log(ArrayOf(3));           // [3]console.log(ArrayOf(1, 2, 3));     // [1,2,3]</code></pre><p>&nbsp;如果帮助到您了，可以留下一个赞👍告诉我&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生js实现vue双向数据绑定</title>
      <link href="/2023/06/06/01-yuan-sheng-js-shi-xian-vue-shuang-xiang-shu-ju-bang-ding/"/>
      <url>/2023/06/06/01-yuan-sheng-js-shi-xian-vue-shuang-xiang-shu-ju-bang-ding/</url>
      
        <content type="html"><![CDATA[<p>html:<br>在HTML中使用v-model的指令，并且引入自定义的vue.js</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>姓名：{{ name }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>input</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>更多：{{ more.like }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>more.like<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./vue.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">        <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>            <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'猿小野'</span><span class="token punctuation">,</span>                <span class="token literal-property property">more</span><span class="token operator">:</span> <span class="token punctuation">{</span>                    <span class="token literal-property property">like</span><span class="token operator">:</span> <span class="token string">'打篮球'</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义的js文件，命名为vue.js，在上面的html中引入</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">{</span><span class="token operator">%</span> codeblock lang<span class="token operator">:</span>javascript <span class="token operator">%</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">Vue</span> <span class="token punctuation">{</span>     <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">obj_instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> obj_instance<span class="token punctuation">.</span>data<span class="token punctuation">;</span>         <span class="token comment">// 数据监听函数</span>         <span class="token function">Observer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 模版解析函数</span>         <span class="token function">Compile</span><span class="token punctuation">(</span>obj_instance<span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span>  <span class="token comment">// 数据劫持 - 监听实例里的数据</span> <span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span><span class="token parameter">data_instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data_instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 递归出口</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data_instance <span class="token operator">||</span> <span class="token keyword">typeof</span> data_instance <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token keyword">const</span> dependency <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dependency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data_instance<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>         <span class="token keyword">let</span> value <span class="token operator">=</span> data_instance<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token function">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 递归 - 子属性数据劫持</span>         Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data_instance<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>             <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">// 是否可以遍历/枚举</span>             <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">// 是否可再次修改/删除配置项</span>             <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">访问了属性：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> -&gt; 值：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> value <span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>Dependency<span class="token punctuation">.</span>temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Dependency<span class="token punctuation">.</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>                 <span class="token comment">// 订阅者加入依赖实例的数组</span>                 Dependency<span class="token punctuation">.</span>temp <span class="token operator">&amp;&amp;</span> dependency<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dependency<span class="token punctuation">.</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">return</span> value<span class="token punctuation">;</span>             <span class="token punctuation">}</span><span class="token punctuation">,</span>             <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">属性</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">的值</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">修改为 -&gt; </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>newValue<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>                 <span class="token function">Observer</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                 dependency<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token comment">// HTML模版解析 - 替换DOM</span> <span class="token keyword">function</span> <span class="token function">Compile</span><span class="token punctuation">(</span><span class="token parameter">element<span class="token punctuation">,</span> vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">let</span> child<span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>firstChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>        fragment<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fragment<span class="token punctuation">.</span>childNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">fragment_compile</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 替换文档碎片内容</span>     <span class="token keyword">function</span> <span class="token function">fragment_compile</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">const</span> pattern <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\{\{\s*(\S+)\s*\}\}</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">const</span> xxx <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">;</span>             <span class="token keyword">const</span> result_regex <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>result_regex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result_regex<span class="token punctuation">)</span><span class="token punctuation">;</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$data<span class="token punctuation">[</span>result_regex<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">const</span> arr <span class="token operator">=</span> result_regex<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">const</span> value <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> current</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                 node<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> xxx<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 创建订阅者</span>                 <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> result_regex<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token parameter">newValue</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                     node<span class="token punctuation">.</span>nodeValue <span class="token operator">=</span> xxx<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span><span class="token punctuation">)</span>             <span class="token punctuation">}</span>             <span class="token keyword">return</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>nodeName <span class="token operator">===</span> <span class="token string">'INPUT'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">const</span> attr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>             attr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span>nodeName <span class="token operator">===</span> <span class="token string">'v-model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>nodeValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token keyword">const</span> value <span class="token operator">=</span> i<span class="token punctuation">.</span>nodeValue<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> current</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>                     node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                     <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> i<span class="token punctuation">.</span>nodeValue<span class="token punctuation">,</span> <span class="token parameter">newValue</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                         node<span class="token punctuation">.</span>value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>                     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                         <span class="token comment">// ['more', 'like']</span>                         <span class="token keyword">const</span> arr1 <span class="token operator">=</span> i<span class="token punctuation">.</span>nodeValue<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// ['more']</span>                         <span class="token keyword">const</span> arr2 <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> arr1<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// vm.$data.more</span>                         <span class="token keyword">const</span> final <span class="token operator">=</span> arr2<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> current</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// vm.$data.more['like'] = e.target.value</span>                         final<span class="token punctuation">[</span>arr1<span class="token punctuation">[</span>arr1<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                     <span class="token punctuation">}</span><span class="token punctuation">)</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span>         node<span class="token punctuation">.</span>childNodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token function">fragment_compile</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 依赖 - 收集和通知订阅者</span> <span class="token keyword">class</span> <span class="token class-name">Dependency</span> <span class="token punctuation">{</span>     <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>subscribers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">sub</span> <span class="token operator">=&gt;</span> sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span>  <span class="token comment">// 订阅者</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>     <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>vm <span class="token operator">=</span> vm<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>callback <span class="token operator">=</span> callback<span class="token punctuation">;</span>         <span class="token comment">// 临时属性 - 触发getter</span>         Dependency<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">用属性</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">创建订阅者</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>         key<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> current</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>         Dependency<span class="token punctuation">.</span>temp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> current</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total<span class="token punctuation">[</span>current<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vm<span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
